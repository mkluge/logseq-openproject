/* tslint:disable */
/* eslint-disable */
/**
 * OpenProject API V3 (Stable)
 * You\'re looking at the current **stable** documentation of the OpenProject APIv3. If you\'re interested in the current development version, please go to [github.com/opf](https://github.com/opf/openproject/tree/dev/docs/api/apiv3).  ## Introduction  The documentation for the APIv3 is written according to the [OpenAPI 3.0 Specification](https://swagger.io/specification/). You can either view the static version of this documentation on the [website](https://www.openproject.org/docs/api/introduction/) or the interactive Swagger UI version in your OpenProject installation under `/api/docs`. In the latter you can try out the various API endpoints directly interacting with our OpenProject data. Moreover you can access the specification source itself under `/api/v3/spec.json` and `/api/v3/spec.yml` (e.g. [here](https://community.openproject.org/api/v3/spec.yml)).  The APIv3 is a hypermedia REST API, a shorthand for \"Hypermedia As The Engine Of Application State\" (HATEOAS). This means that each endpoint of this API will have links to other resources or actions defined in the resulting body.  These related resources and actions for any given resource will be context sensitive. For example, only actions that the authenticated user can take are being rendered. This can be used to dynamically identify actions that the user might take for any given response.  As an example, if you fetch a work package through the [Work Package endpoint](https://www.openproject.org/docs/api/endpoints/work-packages/), the `update` link will only be present when the user you authenticated has been granted a permission to update the work package in the assigned project.  ## HAL+JSON  HAL is a simple format that gives a consistent and easy way to hyperlink between resources in your API. Read more in the following specification: [https://tools.ietf.org/html/draft-kelly-json-hal-08](https://tools.ietf.org/html/draft-kelly-json-hal-08)  **OpenProject API implementation of HAL+JSON format** enriches JSON and introduces a few meta properties:  - `_type` - specifies the type of the resource (e.g.: WorkPackage, Project) - `_links` - contains all related resource and action links available for the resource - `_embedded` - contains all embedded objects  HAL does not guarantee that embedded resources are embedded in their full representation, they might as well be partially represented (e.g. some properties can be left out). However in this API you have the guarantee that whenever a resource is **embedded**, it is embedded in its **full representation**.  ## API response structure  All API responses contain a single HAL+JSON object, even collections of objects are technically represented by a single HAL+JSON object that itself contains its members. More details on collections can be found in the [Collections Section](https://www.openproject.org/docs/api/group-objects/).  ## Authentication  The API supports the following authentication schemes: OAuth2, session based authentication, and basic auth.  Depending on the settings of the OpenProject instance many resources can be accessed without being authenticated. In case the instance requires authentication on all requests the client will receive an **HTTP 401** status code in response to any request.  Otherwise unauthenticated clients have all the permissions of the anonymous user.  ### Session-based Authentication  This means you have to login to OpenProject via the Web-Interface to be authenticated in the API. This method is well-suited for clients acting within the browser, like the Angular-Client built into OpenProject.  In this case, you always need to pass the HTTP header `X-Requested-With \"XMLHttpRequest\"` for authentication.  ### API Key through Basic Auth  Users can authenticate towards the API v3 using basic auth with the user name `apikey` (NOT your login) and the API key as the password. Users can find their API key on their account page.  Example:  ```bash API_KEY=2519132cdf62dcf5a66fd96394672079f9e9cad1 curl -u apikey:$API_KEY https://community.openproject.com/api/v3/users/42 ```  ### OAuth2.0 authentication  OpenProject allows authentication and authorization with OAuth2 with *Authorization code flow*, as well as *Client credentials* operation modes.  To get started, you first need to register an application in the OpenProject OAuth administration section of your installation. This will save an entry for your application with a client unique identifier (`client_id`) and an accompanying secret key (`client_secret`).  You can then use one the following guides to perform the supported OAuth 2.0 flows:  - [Authorization code flow](https://oauth.net/2/grant-types/authorization-code)  - [Authorization code flow with PKCE](https://doorkeeper.gitbook.io/guides/ruby-on-rails/pkce-flow), recommended for clients unable to keep the client_secret confidential.  - [Client credentials](https://oauth.net/2/grant-types/client-credentials/) - Requires an application to be bound to an impersonating user for non-public access  ### Why not username and password?  The simplest way to do basic auth would be to use a user\'s username and password naturally. However, OpenProject already has supported API keys in the past for the API v2, though not through basic auth.  Using **username and password** directly would have some advantages:  * It is intuitive for the user who then just has to provide those just as they would when logging into OpenProject.  * No extra logic for token management necessary.  On the other hand using **API keys** has some advantages too, which is why we went for that:  * If compromised while saved on an insecure client the user only has to regenerate the API key instead of changing their password, too.  * They are naturally long and random which makes them invulnerable to dictionary attacks and harder to crack in general.  Most importantly users may not actually have a password to begin with. Specifically when they have registered through an OpenID Connect provider.  ## Cross-Origin Resource Sharing (CORS)  By default, the OpenProject API is _not_ responding with any CORS headers. If you want to allow cross-domain AJAX calls against your OpenProject instance, you need to enable CORS headers being returned.  Please see [our API settings documentation](https://www.openproject.org/docs/system-admin-guide/system-settings/api-settings/) on how to selectively enable CORS.  ## Allowed HTTP methods  - `GET` - Get a single resource or collection of resources  - `POST` - Create a new resource or perform  - `PATCH` - Update a resource  - `DELETE` - Delete a resource  ## Compression  Responses are compressed if requested by the client. Currently [gzip](https://www.gzip.org/) and [deflate](https://tools.ietf.org/html/rfc1951) are supported. The client signals the desired compression by setting the [`Accept-Encoding` header](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3). If no `Accept-Encoding` header is send, `Accept-Encoding: identity` is assumed which will result in the API responding uncompressed.
 *
 * The version of the OpenAPI document: 3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActivityModel
 */
export interface ActivityModel {
    /**
     * Activity id
     * @type {number}
     * @memberof ActivityModel
     */
    'id'?: number;
    /**
     * Activity version
     * @type {number}
     * @memberof ActivityModel
     */
    'version'?: number;
    /**
     * 
     * @type {ActivityModelComment}
     * @memberof ActivityModel
     */
    'comment'?: ActivityModelComment;
    /**
     * 
     * @type {Array<ActivityModelDetailsInner>}
     * @memberof ActivityModel
     */
    'details'?: Array<ActivityModelDetailsInner>;
    /**
     * Time of creation
     * @type {string}
     * @memberof ActivityModel
     */
    'createdAt'?: string;
    /**
     * Time of update
     * @type {string}
     * @memberof ActivityModel
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ActivityModelComment
 */
export interface ActivityModelComment {
    /**
     * Indicates the formatting language of the raw text
     * @type {string}
     * @memberof ActivityModelComment
     */
    'format': ActivityModelCommentFormatEnum;
    /**
     * The raw text, as entered by the user
     * @type {string}
     * @memberof ActivityModelComment
     */
    'raw'?: string;
    /**
     * The text converted to HTML according to the format
     * @type {string}
     * @memberof ActivityModelComment
     */
    'html'?: string;
}

export const ActivityModelCommentFormatEnum = {
    Plain: 'plain',
    Markdown: 'markdown',
    Custom: 'custom'
} as const;

export type ActivityModelCommentFormatEnum = typeof ActivityModelCommentFormatEnum[keyof typeof ActivityModelCommentFormatEnum];

/**
 * 
 * @export
 * @interface ActivityModelDetailsInner
 */
export interface ActivityModelDetailsInner {
    /**
     * Indicates the formatting language of the raw text
     * @type {string}
     * @memberof ActivityModelDetailsInner
     */
    'format': ActivityModelDetailsInnerFormatEnum;
    /**
     * The raw text, as entered by the user
     * @type {string}
     * @memberof ActivityModelDetailsInner
     */
    'raw'?: string;
    /**
     * The text converted to HTML according to the format
     * @type {string}
     * @memberof ActivityModelDetailsInner
     */
    'html'?: string;
}

export const ActivityModelDetailsInnerFormatEnum = {
    Plain: 'plain',
    Markdown: 'markdown',
    Custom: 'custom'
} as const;

export type ActivityModelDetailsInnerFormatEnum = typeof ActivityModelDetailsInnerFormatEnum[keyof typeof ActivityModelDetailsInnerFormatEnum];

/**
 * 
 * @export
 * @interface AddWatcherRequest
 */
export interface AddWatcherRequest {
    /**
     * 
     * @type {ExecuteCustomActionRequestLinksWorkPackage}
     * @memberof AddWatcherRequest
     */
    'user'?: ExecuteCustomActionRequestLinksWorkPackage;
}
/**
 * 
 * @export
 * @interface AttachmentModel
 */
export interface AttachmentModel {
    /**
     * Attachment\'s id
     * @type {number}
     * @memberof AttachmentModel
     */
    'id'?: number;
    /**
     * The name of the file
     * @type {string}
     * @memberof AttachmentModel
     */
    'title': string;
    /**
     * The name of the uploaded file
     * @type {string}
     * @memberof AttachmentModel
     */
    'fileName': string;
    /**
     * The size of the uploaded file in Bytes
     * @type {number}
     * @memberof AttachmentModel
     */
    'fileSize'?: number;
    /**
     * 
     * @type {AttachmentModelDescription}
     * @memberof AttachmentModel
     */
    'description': AttachmentModelDescription;
    /**
     * The files MIME-Type as determined by the server
     * @type {string}
     * @memberof AttachmentModel
     */
    'contentType': string;
    /**
     * A checksum for the files content
     * @type {string}
     * @memberof AttachmentModel
     */
    'digest': string;
    /**
     * Time of creation
     * @type {string}
     * @memberof AttachmentModel
     */
    'createdAt': string;
    /**
     * 
     * @type {AttachmentModelLinks}
     * @memberof AttachmentModel
     */
    '_links'?: AttachmentModelLinks;
}
/**
 * 
 * @export
 * @interface AttachmentModelDescription
 */
export interface AttachmentModelDescription {
    /**
     * Indicates the formatting language of the raw text
     * @type {string}
     * @memberof AttachmentModelDescription
     */
    'format': AttachmentModelDescriptionFormatEnum;
    /**
     * The raw text, as entered by the user
     * @type {string}
     * @memberof AttachmentModelDescription
     */
    'raw'?: string;
    /**
     * The text converted to HTML according to the format
     * @type {string}
     * @memberof AttachmentModelDescription
     */
    'html'?: string;
}

export const AttachmentModelDescriptionFormatEnum = {
    Plain: 'plain',
    Markdown: 'markdown',
    Custom: 'custom'
} as const;

export type AttachmentModelDescriptionFormatEnum = typeof AttachmentModelDescriptionFormatEnum[keyof typeof AttachmentModelDescriptionFormatEnum];

/**
 * 
 * @export
 * @interface AttachmentModelLinks
 */
export interface AttachmentModelLinks {
    /**
     * 
     * @type {AttachmentModelLinksDelete}
     * @memberof AttachmentModelLinks
     */
    'delete'?: AttachmentModelLinksDelete;
    /**
     * 
     * @type {AttachmentModelLinksSelf}
     * @memberof AttachmentModelLinks
     */
    'self': AttachmentModelLinksSelf;
    /**
     * 
     * @type {AttachmentModelLinksContainer}
     * @memberof AttachmentModelLinks
     */
    'container': AttachmentModelLinksContainer;
    /**
     * 
     * @type {AttachmentModelLinksAuthor}
     * @memberof AttachmentModelLinks
     */
    'author': AttachmentModelLinksAuthor;
    /**
     * 
     * @type {AttachmentModelLinksDownloadLocation}
     * @memberof AttachmentModelLinks
     */
    'downloadLocation': AttachmentModelLinksDownloadLocation;
}
/**
 * 
 * @export
 * @interface AttachmentModelLinksAuthor
 */
export interface AttachmentModelLinksAuthor {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof AttachmentModelLinksAuthor
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof AttachmentModelLinksAuthor
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof AttachmentModelLinksAuthor
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof AttachmentModelLinksAuthor
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof AttachmentModelLinksAuthor
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof AttachmentModelLinksAuthor
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface AttachmentModelLinksContainer
 */
export interface AttachmentModelLinksContainer {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof AttachmentModelLinksContainer
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof AttachmentModelLinksContainer
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof AttachmentModelLinksContainer
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof AttachmentModelLinksContainer
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof AttachmentModelLinksContainer
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof AttachmentModelLinksContainer
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface AttachmentModelLinksDelete
 */
export interface AttachmentModelLinksDelete {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof AttachmentModelLinksDelete
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof AttachmentModelLinksDelete
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof AttachmentModelLinksDelete
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof AttachmentModelLinksDelete
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof AttachmentModelLinksDelete
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof AttachmentModelLinksDelete
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface AttachmentModelLinksDownloadLocation
 */
export interface AttachmentModelLinksDownloadLocation {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof AttachmentModelLinksDownloadLocation
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof AttachmentModelLinksDownloadLocation
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof AttachmentModelLinksDownloadLocation
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof AttachmentModelLinksDownloadLocation
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof AttachmentModelLinksDownloadLocation
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof AttachmentModelLinksDownloadLocation
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface AttachmentModelLinksSelf
 */
export interface AttachmentModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof AttachmentModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof AttachmentModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof AttachmentModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof AttachmentModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof AttachmentModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof AttachmentModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface AttachmentsModel
 */
export interface AttachmentsModel {
    /**
     * The total amount of elements available in the collection
     * @type {number}
     * @memberof AttachmentsModel
     */
    'total'?: number;
    /**
     * Amount of elements that a response will hold
     * @type {number}
     * @memberof AttachmentsModel
     */
    'pageSize'?: number;
    /**
     * Actual amount of elements in this response
     * @type {number}
     * @memberof AttachmentsModel
     */
    'count'?: number;
    /**
     * The page number that is requested from paginated collection
     * @type {number}
     * @memberof AttachmentsModel
     */
    'offset'?: number;
    /**
     * Summarized information about aggregation groups
     * @type {object}
     * @memberof AttachmentsModel
     */
    'groups'?: object;
    /**
     * Aggregations of supported values for elements of the collection
     * @type {object}
     * @memberof AttachmentsModel
     */
    'totalSums'?: object;
    /**
     * 
     * @type {AttachmentsModelAllOfLinks}
     * @memberof AttachmentsModel
     */
    '_links': AttachmentsModelAllOfLinks;
    /**
     * 
     * @type {AttachmentsModelAllOfEmbedded}
     * @memberof AttachmentsModel
     */
    '_embedded': AttachmentsModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface AttachmentsModelAllOf
 */
export interface AttachmentsModelAllOf {
    /**
     * 
     * @type {AttachmentsModelAllOfLinks}
     * @memberof AttachmentsModelAllOf
     */
    '_links': AttachmentsModelAllOfLinks;
    /**
     * 
     * @type {AttachmentsModelAllOfEmbedded}
     * @memberof AttachmentsModelAllOf
     */
    '_embedded': AttachmentsModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface AttachmentsModelAllOfEmbedded
 */
export interface AttachmentsModelAllOfEmbedded {
    /**
     * 
     * @type {Array<AttachmentModel>}
     * @memberof AttachmentsModelAllOfEmbedded
     */
    'elements'?: Array<AttachmentModel>;
}
/**
 * 
 * @export
 * @interface AttachmentsModelAllOfLinks
 */
export interface AttachmentsModelAllOfLinks {
    /**
     * 
     * @type {Link}
     * @memberof AttachmentsModelAllOfLinks
     */
    'self': Link;
}
/**
 * 
 * @export
 * @interface BudgetModel
 */
export interface BudgetModel {
    /**
     * 
     * @type {BudgetModelLinks}
     * @memberof BudgetModel
     */
    '_links'?: BudgetModelLinks;
}
/**
 * 
 * @export
 * @interface BudgetModelLinks
 */
export interface BudgetModelLinks {
    /**
     * 
     * @type {BudgetModelLinksSelf}
     * @memberof BudgetModelLinks
     */
    'self': BudgetModelLinksSelf;
}
/**
 * 
 * @export
 * @interface BudgetModelLinksSelf
 */
export interface BudgetModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof BudgetModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof BudgetModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof BudgetModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof BudgetModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof BudgetModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof BudgetModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface CategoryModel
 */
export interface CategoryModel {
    /**
     * Category id
     * @type {number}
     * @memberof CategoryModel
     */
    'id'?: number;
    /**
     * Category name
     * @type {string}
     * @memberof CategoryModel
     */
    'name'?: string;
    /**
     * 
     * @type {CategoryModelLinks}
     * @memberof CategoryModel
     */
    '_links'?: CategoryModelLinks;
}
/**
 * 
 * @export
 * @interface CategoryModelLinks
 */
export interface CategoryModelLinks {
    /**
     * 
     * @type {CategoryModelLinksSelf}
     * @memberof CategoryModelLinks
     */
    'self': CategoryModelLinksSelf;
    /**
     * 
     * @type {CategoryModelLinksProject}
     * @memberof CategoryModelLinks
     */
    'project': CategoryModelLinksProject;
    /**
     * 
     * @type {CategoryModelLinksDefaultAssignee}
     * @memberof CategoryModelLinks
     */
    'defaultAssignee'?: CategoryModelLinksDefaultAssignee;
}
/**
 * 
 * @export
 * @interface CategoryModelLinksDefaultAssignee
 */
export interface CategoryModelLinksDefaultAssignee {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof CategoryModelLinksDefaultAssignee
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof CategoryModelLinksDefaultAssignee
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof CategoryModelLinksDefaultAssignee
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof CategoryModelLinksDefaultAssignee
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof CategoryModelLinksDefaultAssignee
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof CategoryModelLinksDefaultAssignee
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface CategoryModelLinksProject
 */
export interface CategoryModelLinksProject {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof CategoryModelLinksProject
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof CategoryModelLinksProject
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof CategoryModelLinksProject
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof CategoryModelLinksProject
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof CategoryModelLinksProject
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof CategoryModelLinksProject
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface CategoryModelLinksSelf
 */
export interface CategoryModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof CategoryModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof CategoryModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof CategoryModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof CategoryModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof CategoryModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof CategoryModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface CollectionModel
 */
export interface CollectionModel {
    /**
     * The total amount of elements available in the collection
     * @type {number}
     * @memberof CollectionModel
     */
    'total'?: number;
    /**
     * Amount of elements that a response will hold
     * @type {number}
     * @memberof CollectionModel
     */
    'pageSize'?: number;
    /**
     * Actual amount of elements in this response
     * @type {number}
     * @memberof CollectionModel
     */
    'count'?: number;
    /**
     * The page number that is requested from paginated collection
     * @type {number}
     * @memberof CollectionModel
     */
    'offset'?: number;
    /**
     * Summarized information about aggregation groups
     * @type {object}
     * @memberof CollectionModel
     */
    'groups'?: object;
    /**
     * Aggregations of supported values for elements of the collection
     * @type {object}
     * @memberof CollectionModel
     */
    'totalSums'?: object;
}
/**
 * 
 * @export
 * @interface CommentWorkPackageRequest
 */
export interface CommentWorkPackageRequest {
    /**
     * 
     * @type {UpdateActivityRequestComment}
     * @memberof CommentWorkPackageRequest
     */
    'comment'?: UpdateActivityRequestComment;
}
/**
 * 
 * @export
 * @interface ConfigurationModel
 */
export interface ConfigurationModel {
    /**
     * The maximum allowed size of an attachment in Bytes
     * @type {number}
     * @memberof ConfigurationModel
     */
    'maximumAttachmentFileSize'?: number;
    /**
     * The host name configured for the system
     * @type {string}
     * @memberof ConfigurationModel
     */
    'hostName'?: string;
    /**
     * Page size steps to be offered in paginated list UI
     * @type {Array<number>}
     * @memberof ConfigurationModel
     */
    'perPageOptions'?: Array<number>;
    /**
     * The list of all feature flags that are active
     * @type {Array<string>}
     * @memberof ConfigurationModel
     */
    'activeFeatureFlags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateGroupRequest
 */
export interface CreateGroupRequest {
    /**
     * 
     * @type {CreateGroupRequestLinks}
     * @memberof CreateGroupRequest
     */
    '_links'?: CreateGroupRequestLinks;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateGroupRequestLinks
 */
export interface CreateGroupRequestLinks {
    /**
     * 
     * @type {Array<ExecuteCustomActionRequestLinksWorkPackage>}
     * @memberof CreateGroupRequestLinks
     */
    'members'?: Array<ExecuteCustomActionRequestLinksWorkPackage>;
}
/**
 * 
 * @export
 * @interface CreateViewsRequest
 */
export interface CreateViewsRequest {
    /**
     * 
     * @type {CreateViewsRequestLinks}
     * @memberof CreateViewsRequest
     */
    '_links'?: CreateViewsRequestLinks;
}
/**
 * 
 * @export
 * @interface CreateViewsRequestLinks
 */
export interface CreateViewsRequestLinks {
    /**
     * 
     * @type {CreateViewsRequestLinksQuery}
     * @memberof CreateViewsRequestLinks
     */
    'query'?: CreateViewsRequestLinksQuery;
}
/**
 * 
 * @export
 * @interface CreateViewsRequestLinksQuery
 */
export interface CreateViewsRequestLinksQuery {
    /**
     * 
     * @type {string}
     * @memberof CreateViewsRequestLinksQuery
     */
    'href'?: string;
}
/**
 * 
 * @export
 * @interface CustomOptionModel
 */
export interface CustomOptionModel {
    /**
     * The identifier
     * @type {number}
     * @memberof CustomOptionModel
     */
    'id'?: number;
    /**
     * The value defined for this custom option
     * @type {string}
     * @memberof CustomOptionModel
     */
    'value'?: string;
    /**
     * 
     * @type {CustomOptionModelLinks}
     * @memberof CustomOptionModel
     */
    '_links'?: CustomOptionModelLinks;
}
/**
 * 
 * @export
 * @interface CustomOptionModelLinks
 */
export interface CustomOptionModelLinks {
    /**
     * 
     * @type {CustomOptionModelLinksSelf}
     * @memberof CustomOptionModelLinks
     */
    'self': CustomOptionModelLinksSelf;
}
/**
 * 
 * @export
 * @interface CustomOptionModelLinksSelf
 */
export interface CustomOptionModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof CustomOptionModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof CustomOptionModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof CustomOptionModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof CustomOptionModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof CustomOptionModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof CustomOptionModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface CustomactionModel
 */
export interface CustomactionModel {
    /**
     * Custom action id
     * @type {number}
     * @memberof CustomactionModel
     */
    'id'?: number;
    /**
     * The user selected name of the custom action
     * @type {string}
     * @memberof CustomactionModel
     */
    'name'?: string;
    /**
     * A text describing the custom action
     * @type {string}
     * @memberof CustomactionModel
     */
    'description'?: string;
    /**
     * 
     * @type {CustomactionModelLinks}
     * @memberof CustomactionModel
     */
    '_links'?: CustomactionModelLinks;
}
/**
 * 
 * @export
 * @interface CustomactionModelLinks
 */
export interface CustomactionModelLinks {
    /**
     * 
     * @type {CustomactionModelLinksExecuteImmediately}
     * @memberof CustomactionModelLinks
     */
    'executeImmediately'?: CustomactionModelLinksExecuteImmediately;
}
/**
 * 
 * @export
 * @interface CustomactionModelLinksExecuteImmediately
 */
export interface CustomactionModelLinksExecuteImmediately {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof CustomactionModelLinksExecuteImmediately
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof CustomactionModelLinksExecuteImmediately
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof CustomactionModelLinksExecuteImmediately
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof CustomactionModelLinksExecuteImmediately
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof CustomactionModelLinksExecuteImmediately
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof CustomactionModelLinksExecuteImmediately
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface DayCollectionModel
 */
export interface DayCollectionModel {
    /**
     * The total amount of elements available in the collection
     * @type {number}
     * @memberof DayCollectionModel
     */
    'total'?: number;
    /**
     * Amount of elements that a response will hold
     * @type {number}
     * @memberof DayCollectionModel
     */
    'pageSize'?: number;
    /**
     * Actual amount of elements in this response
     * @type {number}
     * @memberof DayCollectionModel
     */
    'count'?: number;
    /**
     * The page number that is requested from paginated collection
     * @type {number}
     * @memberof DayCollectionModel
     */
    'offset'?: number;
    /**
     * Summarized information about aggregation groups
     * @type {object}
     * @memberof DayCollectionModel
     */
    'groups'?: object;
    /**
     * Aggregations of supported values for elements of the collection
     * @type {object}
     * @memberof DayCollectionModel
     */
    'totalSums'?: object;
    /**
     * 
     * @type {DayCollectionModelAllOfLinks}
     * @memberof DayCollectionModel
     */
    '_links': DayCollectionModelAllOfLinks;
    /**
     * 
     * @type {DayCollectionModelAllOfEmbedded}
     * @memberof DayCollectionModel
     */
    '_embedded': DayCollectionModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface DayCollectionModelAllOf
 */
export interface DayCollectionModelAllOf {
    /**
     * 
     * @type {DayCollectionModelAllOfLinks}
     * @memberof DayCollectionModelAllOf
     */
    '_links': DayCollectionModelAllOfLinks;
    /**
     * 
     * @type {DayCollectionModelAllOfEmbedded}
     * @memberof DayCollectionModelAllOf
     */
    '_embedded': DayCollectionModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface DayCollectionModelAllOfEmbedded
 */
export interface DayCollectionModelAllOfEmbedded {
    /**
     * The array of days. Each day has a name and a working status indicating if it is a working or a non-working day.
     * @type {Array<DayModel>}
     * @memberof DayCollectionModelAllOfEmbedded
     */
    'elements': Array<DayModel>;
}
/**
 * 
 * @export
 * @interface DayCollectionModelAllOfLinks
 */
export interface DayCollectionModelAllOfLinks {
    /**
     * 
     * @type {Link}
     * @memberof DayCollectionModelAllOfLinks
     */
    'self': Link;
}
/**
 * 
 * @export
 * @interface DayModel
 */
export interface DayModel {
    /**
     * 
     * @type {string}
     * @memberof DayModel
     */
    '_type': DayModelTypeEnum;
    /**
     * Date of the day.
     * @type {string}
     * @memberof DayModel
     */
    'date': string;
    /**
     * Descriptive name for the day.
     * @type {string}
     * @memberof DayModel
     */
    'name': string;
    /**
     * `true` for a working day, `false` otherwise.
     * @type {boolean}
     * @memberof DayModel
     */
    'working': boolean;
    /**
     * 
     * @type {DayModelLinks}
     * @memberof DayModel
     */
    '_links'?: DayModelLinks;
}

export const DayModelTypeEnum = {
    Day: 'Day'
} as const;

export type DayModelTypeEnum = typeof DayModelTypeEnum[keyof typeof DayModelTypeEnum];

/**
 * 
 * @export
 * @interface DayModelLinks
 */
export interface DayModelLinks {
    /**
     * 
     * @type {Link}
     * @memberof DayModelLinks
     */
    'self': Link;
    /**
     * A list of resources describing why this day is a non-working day. Linked resources can be `NonWorkingDay` and `WeekDay` resources. This property is absent for working days.
     * @type {Array<Link>}
     * @memberof DayModelLinks
     */
    'nonWorkingReasons'?: Array<Link>;
    /**
     * 
     * @type {DayModelLinksWeekDay}
     * @memberof DayModelLinks
     */
    'weekDay'?: DayModelLinksWeekDay;
}
/**
 * 
 * @export
 * @interface DayModelLinksWeekDay
 */
export interface DayModelLinksWeekDay {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof DayModelLinksWeekDay
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof DayModelLinksWeekDay
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof DayModelLinksWeekDay
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof DayModelLinksWeekDay
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof DayModelLinksWeekDay
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof DayModelLinksWeekDay
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface DocumentModel
 */
export interface DocumentModel {
    /**
     * Document\'s id
     * @type {number}
     * @memberof DocumentModel
     */
    'id'?: number;
    /**
     * The title chosen for the collection of documents
     * @type {string}
     * @memberof DocumentModel
     */
    'title'?: string;
    /**
     * A text describing the documents
     * @type {string}
     * @memberof DocumentModel
     */
    'description'?: string;
    /**
     * The time the document was created at
     * @type {string}
     * @memberof DocumentModel
     */
    'createdAt'?: string;
    /**
     * 
     * @type {DocumentModelLinks}
     * @memberof DocumentModel
     */
    '_links'?: DocumentModelLinks;
}
/**
 * 
 * @export
 * @interface DocumentModelLinks
 */
export interface DocumentModelLinks {
    /**
     * 
     * @type {DocumentModelLinksSelf}
     * @memberof DocumentModelLinks
     */
    'self': DocumentModelLinksSelf;
    /**
     * 
     * @type {DocumentModelLinksProject}
     * @memberof DocumentModelLinks
     */
    'project': DocumentModelLinksProject;
    /**
     * 
     * @type {DocumentModelLinksAttachments}
     * @memberof DocumentModelLinks
     */
    'attachments': DocumentModelLinksAttachments;
}
/**
 * 
 * @export
 * @interface DocumentModelLinksAttachments
 */
export interface DocumentModelLinksAttachments {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof DocumentModelLinksAttachments
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof DocumentModelLinksAttachments
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof DocumentModelLinksAttachments
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof DocumentModelLinksAttachments
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof DocumentModelLinksAttachments
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof DocumentModelLinksAttachments
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface DocumentModelLinksProject
 */
export interface DocumentModelLinksProject {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof DocumentModelLinksProject
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof DocumentModelLinksProject
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof DocumentModelLinksProject
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof DocumentModelLinksProject
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof DocumentModelLinksProject
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof DocumentModelLinksProject
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface DocumentModelLinksSelf
 */
export interface DocumentModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof DocumentModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof DocumentModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof DocumentModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof DocumentModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof DocumentModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof DocumentModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface EditQueryRequest
 */
export interface EditQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof EditQueryRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorResponseEmbedded}
     * @memberof ErrorResponse
     */
    '_embedded'?: ErrorResponseEmbedded;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    '_type': ErrorResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'errorIdentifier': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
}

export const ErrorResponseTypeEnum = {
    Error: 'Error'
} as const;

export type ErrorResponseTypeEnum = typeof ErrorResponseTypeEnum[keyof typeof ErrorResponseTypeEnum];

/**
 * 
 * @export
 * @interface ErrorResponseEmbedded
 */
export interface ErrorResponseEmbedded {
    /**
     * 
     * @type {ErrorResponseEmbeddedDetails}
     * @memberof ErrorResponseEmbedded
     */
    'details'?: ErrorResponseEmbeddedDetails;
}
/**
 * 
 * @export
 * @interface ErrorResponseEmbeddedDetails
 */
export interface ErrorResponseEmbeddedDetails {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseEmbeddedDetails
     */
    'attribute'?: string;
}
/**
 * 
 * @export
 * @interface ExecuteCustomActionRequest
 */
export interface ExecuteCustomActionRequest {
    /**
     * 
     * @type {ExecuteCustomActionRequestLinks}
     * @memberof ExecuteCustomActionRequest
     */
    '_links'?: ExecuteCustomActionRequestLinks;
    /**
     * 
     * @type {string}
     * @memberof ExecuteCustomActionRequest
     */
    'lockVersion'?: string;
}
/**
 * 
 * @export
 * @interface ExecuteCustomActionRequestLinks
 */
export interface ExecuteCustomActionRequestLinks {
    /**
     * 
     * @type {ExecuteCustomActionRequestLinksWorkPackage}
     * @memberof ExecuteCustomActionRequestLinks
     */
    'workPackage'?: ExecuteCustomActionRequestLinksWorkPackage;
}
/**
 * 
 * @export
 * @interface ExecuteCustomActionRequestLinksWorkPackage
 */
export interface ExecuteCustomActionRequestLinksWorkPackage {
    /**
     * 
     * @type {string}
     * @memberof ExecuteCustomActionRequestLinksWorkPackage
     */
    'href'?: string;
}
/**
 * 
 * @export
 * @interface FileCollectionModel
 */
export interface FileCollectionModel {
    /**
     * The total amount of elements available in the collection
     * @type {number}
     * @memberof FileCollectionModel
     */
    'total'?: number;
    /**
     * Amount of elements that a response will hold
     * @type {number}
     * @memberof FileCollectionModel
     */
    'pageSize'?: number;
    /**
     * Actual amount of elements in this response
     * @type {number}
     * @memberof FileCollectionModel
     */
    'count'?: number;
    /**
     * The page number that is requested from paginated collection
     * @type {number}
     * @memberof FileCollectionModel
     */
    'offset'?: number;
    /**
     * Summarized information about aggregation groups
     * @type {object}
     * @memberof FileCollectionModel
     */
    'groups'?: object;
    /**
     * Aggregations of supported values for elements of the collection
     * @type {object}
     * @memberof FileCollectionModel
     */
    'totalSums'?: object;
    /**
     * 
     * @type {FileCollectionModelAllOfLinks}
     * @memberof FileCollectionModel
     */
    '_links': FileCollectionModelAllOfLinks;
    /**
     * 
     * @type {FileCollectionModelAllOfEmbedded}
     * @memberof FileCollectionModel
     */
    '_embedded': FileCollectionModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface FileCollectionModelAllOf
 */
export interface FileCollectionModelAllOf {
    /**
     * 
     * @type {FileCollectionModelAllOfLinks}
     * @memberof FileCollectionModelAllOf
     */
    '_links': FileCollectionModelAllOfLinks;
    /**
     * 
     * @type {FileCollectionModelAllOfEmbedded}
     * @memberof FileCollectionModelAllOf
     */
    '_embedded': FileCollectionModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface FileCollectionModelAllOfEmbedded
 */
export interface FileCollectionModelAllOfEmbedded {
    /**
     * 
     * @type {Array<StorageFileModel>}
     * @memberof FileCollectionModelAllOfEmbedded
     */
    'elements': Array<StorageFileModel>;
}
/**
 * 
 * @export
 * @interface FileCollectionModelAllOfLinks
 */
export interface FileCollectionModelAllOfLinks {
    /**
     * 
     * @type {Link}
     * @memberof FileCollectionModelAllOfLinks
     */
    'self': Link;
}
/**
 * 
 * @export
 * @interface FileLinkCollectionReadModel
 */
export interface FileLinkCollectionReadModel {
    /**
     * The total amount of elements available in the collection
     * @type {number}
     * @memberof FileLinkCollectionReadModel
     */
    'total'?: number;
    /**
     * Amount of elements that a response will hold
     * @type {number}
     * @memberof FileLinkCollectionReadModel
     */
    'pageSize'?: number;
    /**
     * Actual amount of elements in this response
     * @type {number}
     * @memberof FileLinkCollectionReadModel
     */
    'count'?: number;
    /**
     * The page number that is requested from paginated collection
     * @type {number}
     * @memberof FileLinkCollectionReadModel
     */
    'offset'?: number;
    /**
     * Summarized information about aggregation groups
     * @type {object}
     * @memberof FileLinkCollectionReadModel
     */
    'groups'?: object;
    /**
     * Aggregations of supported values for elements of the collection
     * @type {object}
     * @memberof FileLinkCollectionReadModel
     */
    'totalSums'?: object;
    /**
     * 
     * @type {FileLinkCollectionReadModelAllOfLinks}
     * @memberof FileLinkCollectionReadModel
     */
    '_links': FileLinkCollectionReadModelAllOfLinks;
    /**
     * 
     * @type {FileLinkCollectionReadModelAllOfEmbedded}
     * @memberof FileLinkCollectionReadModel
     */
    '_embedded': FileLinkCollectionReadModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface FileLinkCollectionReadModelAllOf
 */
export interface FileLinkCollectionReadModelAllOf {
    /**
     * 
     * @type {FileLinkCollectionReadModelAllOfLinks}
     * @memberof FileLinkCollectionReadModelAllOf
     */
    '_links': FileLinkCollectionReadModelAllOfLinks;
    /**
     * 
     * @type {FileLinkCollectionReadModelAllOfEmbedded}
     * @memberof FileLinkCollectionReadModelAllOf
     */
    '_embedded': FileLinkCollectionReadModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface FileLinkCollectionReadModelAllOfEmbedded
 */
export interface FileLinkCollectionReadModelAllOfEmbedded {
    /**
     * 
     * @type {Array<FileLinkReadModel>}
     * @memberof FileLinkCollectionReadModelAllOfEmbedded
     */
    'elements': Array<FileLinkReadModel>;
}
/**
 * 
 * @export
 * @interface FileLinkCollectionReadModelAllOfLinks
 */
export interface FileLinkCollectionReadModelAllOfLinks {
    /**
     * 
     * @type {Link}
     * @memberof FileLinkCollectionReadModelAllOfLinks
     */
    'self': Link;
}
/**
 * 
 * @export
 * @interface FileLinkCollectionWriteModel
 */
export interface FileLinkCollectionWriteModel {
    /**
     * The total amount of elements available in the collection
     * @type {number}
     * @memberof FileLinkCollectionWriteModel
     */
    'total'?: number;
    /**
     * Amount of elements that a response will hold
     * @type {number}
     * @memberof FileLinkCollectionWriteModel
     */
    'pageSize'?: number;
    /**
     * Actual amount of elements in this response
     * @type {number}
     * @memberof FileLinkCollectionWriteModel
     */
    'count'?: number;
    /**
     * The page number that is requested from paginated collection
     * @type {number}
     * @memberof FileLinkCollectionWriteModel
     */
    'offset'?: number;
    /**
     * Summarized information about aggregation groups
     * @type {object}
     * @memberof FileLinkCollectionWriteModel
     */
    'groups'?: object;
    /**
     * Aggregations of supported values for elements of the collection
     * @type {object}
     * @memberof FileLinkCollectionWriteModel
     */
    'totalSums'?: object;
    /**
     * 
     * @type {FileLinkCollectionWriteModelAllOfEmbedded}
     * @memberof FileLinkCollectionWriteModel
     */
    '_embedded': FileLinkCollectionWriteModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface FileLinkCollectionWriteModelAllOf
 */
export interface FileLinkCollectionWriteModelAllOf {
    /**
     * 
     * @type {FileLinkCollectionWriteModelAllOfEmbedded}
     * @memberof FileLinkCollectionWriteModelAllOf
     */
    '_embedded': FileLinkCollectionWriteModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface FileLinkCollectionWriteModelAllOfEmbedded
 */
export interface FileLinkCollectionWriteModelAllOfEmbedded {
    /**
     * 
     * @type {Array<FileLinkWriteModel>}
     * @memberof FileLinkCollectionWriteModelAllOfEmbedded
     */
    'elements': Array<FileLinkWriteModel>;
}
/**
 * 
 * @export
 * @interface FileLinkOriginDataModel
 */
export interface FileLinkOriginDataModel {
    /**
     * Linked file\'s id on the origin
     * @type {string}
     * @memberof FileLinkOriginDataModel
     */
    'id': string;
    /**
     * Linked file\'s name on the origin
     * @type {string}
     * @memberof FileLinkOriginDataModel
     */
    'name': string;
    /**
     * MIME type of the linked file.  To link a folder entity, the custom MIME type `application/x-op-directory` MUST be provided. Otherwise it defaults back to an unknown MIME type.
     * @type {string}
     * @memberof FileLinkOriginDataModel
     */
    'mimeType'?: string;
    /**
     * file size on origin in bytes
     * @type {number}
     * @memberof FileLinkOriginDataModel
     */
    'size'?: number;
    /**
     * Timestamp of the creation datetime of the file on the origin
     * @type {string}
     * @memberof FileLinkOriginDataModel
     */
    'createdAt'?: string;
    /**
     * Timestamp of the datetime of the last modification of the file on the origin
     * @type {string}
     * @memberof FileLinkOriginDataModel
     */
    'lastModifiedAt'?: string;
    /**
     * Display name of the author that created the file on the origin
     * @type {string}
     * @memberof FileLinkOriginDataModel
     */
    'createdByName'?: string;
    /**
     * Display name of the author that modified the file on the origin last
     * @type {string}
     * @memberof FileLinkOriginDataModel
     */
    'lastModifiedByName'?: string;
}
/**
 * 
 * @export
 * @interface FileLinkReadModel
 */
export interface FileLinkReadModel {
    /**
     * File link id
     * @type {number}
     * @memberof FileLinkReadModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof FileLinkReadModel
     */
    '_type': FileLinkReadModelTypeEnum;
    /**
     * Time of creation
     * @type {string}
     * @memberof FileLinkReadModel
     */
    'createdAt'?: string;
    /**
     * Time of the most recent change to the file link
     * @type {string}
     * @memberof FileLinkReadModel
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {FileLinkOriginDataModel}
     * @memberof FileLinkReadModel
     */
    'originData': FileLinkOriginDataModel;
    /**
     * 
     * @type {FileLinkReadModelEmbedded}
     * @memberof FileLinkReadModel
     */
    '_embedded'?: FileLinkReadModelEmbedded;
    /**
     * 
     * @type {FileLinkReadModelLinks}
     * @memberof FileLinkReadModel
     */
    '_links': FileLinkReadModelLinks;
}

export const FileLinkReadModelTypeEnum = {
    FileLink: 'FileLink'
} as const;

export type FileLinkReadModelTypeEnum = typeof FileLinkReadModelTypeEnum[keyof typeof FileLinkReadModelTypeEnum];

/**
 * 
 * @export
 * @interface FileLinkReadModelEmbedded
 */
export interface FileLinkReadModelEmbedded {
    /**
     * 
     * @type {StorageModel}
     * @memberof FileLinkReadModelEmbedded
     */
    'storage': StorageModel;
    /**
     * 
     * @type {WorkPackageModel}
     * @memberof FileLinkReadModelEmbedded
     */
    'container': WorkPackageModel;
}
/**
 * 
 * @export
 * @interface FileLinkReadModelLinks
 */
export interface FileLinkReadModelLinks {
    /**
     * 
     * @type {FileLinkReadModelLinksSelf}
     * @memberof FileLinkReadModelLinks
     */
    'self': FileLinkReadModelLinksSelf;
    /**
     * 
     * @type {FileLinkReadModelLinksStorage}
     * @memberof FileLinkReadModelLinks
     */
    'storage': FileLinkReadModelLinksStorage;
    /**
     * 
     * @type {FileLinkReadModelLinksContainer}
     * @memberof FileLinkReadModelLinks
     */
    'container': FileLinkReadModelLinksContainer;
    /**
     * 
     * @type {FileLinkReadModelLinksCreator}
     * @memberof FileLinkReadModelLinks
     */
    'creator': FileLinkReadModelLinksCreator;
    /**
     * 
     * @type {FileLinkReadModelLinksDelete}
     * @memberof FileLinkReadModelLinks
     */
    'delete'?: FileLinkReadModelLinksDelete;
    /**
     * 
     * @type {FileLinkReadModelLinksPermission}
     * @memberof FileLinkReadModelLinks
     */
    'permission': FileLinkReadModelLinksPermission;
    /**
     * 
     * @type {FileLinkReadModelLinksOriginOpen}
     * @memberof FileLinkReadModelLinks
     */
    'originOpen': FileLinkReadModelLinksOriginOpen;
    /**
     * 
     * @type {FileLinkReadModelLinksStaticOriginOpen}
     * @memberof FileLinkReadModelLinks
     */
    'staticOriginOpen': FileLinkReadModelLinksStaticOriginOpen;
    /**
     * 
     * @type {FileLinkReadModelLinksOriginOpenLocation}
     * @memberof FileLinkReadModelLinks
     */
    'originOpenLocation': FileLinkReadModelLinksOriginOpenLocation;
    /**
     * 
     * @type {FileLinkReadModelLinksStaticOriginOpenLocation}
     * @memberof FileLinkReadModelLinks
     */
    'staticOriginOpenLocation': FileLinkReadModelLinksStaticOriginOpenLocation;
    /**
     * 
     * @type {FileLinkReadModelLinksStaticOriginDownload}
     * @memberof FileLinkReadModelLinks
     */
    'staticOriginDownload': FileLinkReadModelLinksStaticOriginDownload;
}
/**
 * 
 * @export
 * @interface FileLinkReadModelLinksContainer
 */
export interface FileLinkReadModelLinksContainer {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FileLinkReadModelLinksContainer
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksContainer
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FileLinkReadModelLinksContainer
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksContainer
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FileLinkReadModelLinksContainer
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FileLinkReadModelLinksContainer
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FileLinkReadModelLinksCreator
 */
export interface FileLinkReadModelLinksCreator {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FileLinkReadModelLinksCreator
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksCreator
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FileLinkReadModelLinksCreator
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksCreator
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FileLinkReadModelLinksCreator
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FileLinkReadModelLinksCreator
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FileLinkReadModelLinksDelete
 */
export interface FileLinkReadModelLinksDelete {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FileLinkReadModelLinksDelete
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksDelete
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FileLinkReadModelLinksDelete
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksDelete
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FileLinkReadModelLinksDelete
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FileLinkReadModelLinksDelete
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FileLinkReadModelLinksOriginOpen
 */
export interface FileLinkReadModelLinksOriginOpen {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FileLinkReadModelLinksOriginOpen
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksOriginOpen
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FileLinkReadModelLinksOriginOpen
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksOriginOpen
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FileLinkReadModelLinksOriginOpen
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FileLinkReadModelLinksOriginOpen
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FileLinkReadModelLinksOriginOpenLocation
 */
export interface FileLinkReadModelLinksOriginOpenLocation {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FileLinkReadModelLinksOriginOpenLocation
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksOriginOpenLocation
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FileLinkReadModelLinksOriginOpenLocation
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksOriginOpenLocation
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FileLinkReadModelLinksOriginOpenLocation
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FileLinkReadModelLinksOriginOpenLocation
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FileLinkReadModelLinksPermission
 */
export interface FileLinkReadModelLinksPermission {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FileLinkReadModelLinksPermission
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksPermission
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FileLinkReadModelLinksPermission
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksPermission
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FileLinkReadModelLinksPermission
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FileLinkReadModelLinksPermission
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FileLinkReadModelLinksSelf
 */
export interface FileLinkReadModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FileLinkReadModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FileLinkReadModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FileLinkReadModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FileLinkReadModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FileLinkReadModelLinksStaticOriginDownload
 */
export interface FileLinkReadModelLinksStaticOriginDownload {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FileLinkReadModelLinksStaticOriginDownload
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksStaticOriginDownload
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FileLinkReadModelLinksStaticOriginDownload
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksStaticOriginDownload
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FileLinkReadModelLinksStaticOriginDownload
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FileLinkReadModelLinksStaticOriginDownload
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FileLinkReadModelLinksStaticOriginOpen
 */
export interface FileLinkReadModelLinksStaticOriginOpen {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FileLinkReadModelLinksStaticOriginOpen
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksStaticOriginOpen
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FileLinkReadModelLinksStaticOriginOpen
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksStaticOriginOpen
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FileLinkReadModelLinksStaticOriginOpen
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FileLinkReadModelLinksStaticOriginOpen
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FileLinkReadModelLinksStaticOriginOpenLocation
 */
export interface FileLinkReadModelLinksStaticOriginOpenLocation {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FileLinkReadModelLinksStaticOriginOpenLocation
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksStaticOriginOpenLocation
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FileLinkReadModelLinksStaticOriginOpenLocation
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksStaticOriginOpenLocation
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FileLinkReadModelLinksStaticOriginOpenLocation
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FileLinkReadModelLinksStaticOriginOpenLocation
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FileLinkReadModelLinksStorage
 */
export interface FileLinkReadModelLinksStorage {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FileLinkReadModelLinksStorage
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksStorage
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FileLinkReadModelLinksStorage
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FileLinkReadModelLinksStorage
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FileLinkReadModelLinksStorage
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FileLinkReadModelLinksStorage
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FileLinkWriteModel
 */
export interface FileLinkWriteModel {
    /**
     * 
     * @type {FileLinkOriginDataModel}
     * @memberof FileLinkWriteModel
     */
    'originData': FileLinkOriginDataModel;
    /**
     * 
     * @type {FileLinkWriteModelLinks}
     * @memberof FileLinkWriteModel
     */
    '_links': FileLinkWriteModelLinks;
}
/**
 * @type FileLinkWriteModelLinks
 * @export
 */
export type FileLinkWriteModelLinks = FileLinkWriteModelLinksOneOf | FileLinkWriteModelLinksOneOf1;

/**
 * 
 * @export
 * @interface FileLinkWriteModelLinksOneOf
 */
export interface FileLinkWriteModelLinksOneOf {
    /**
     * 
     * @type {FileLinkReadModelLinksStorage}
     * @memberof FileLinkWriteModelLinksOneOf
     */
    'storage': FileLinkReadModelLinksStorage;
}
/**
 * 
 * @export
 * @interface FileLinkWriteModelLinksOneOf1
 */
export interface FileLinkWriteModelLinksOneOf1 {
    /**
     * 
     * @type {FileLinkWriteModelLinksOneOf1StorageUrl}
     * @memberof FileLinkWriteModelLinksOneOf1
     */
    'storageUrl': FileLinkWriteModelLinksOneOf1StorageUrl;
}
/**
 * 
 * @export
 * @interface FileLinkWriteModelLinksOneOf1StorageUrl
 */
export interface FileLinkWriteModelLinksOneOf1StorageUrl {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FileLinkWriteModelLinksOneOf1StorageUrl
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FileLinkWriteModelLinksOneOf1StorageUrl
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FileLinkWriteModelLinksOneOf1StorageUrl
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FileLinkWriteModelLinksOneOf1StorageUrl
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FileLinkWriteModelLinksOneOf1StorageUrl
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FileLinkWriteModelLinksOneOf1StorageUrl
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FormModel
 */
export interface FormModel {
    /**
     * 
     * @type {FormModelLinks}
     * @memberof FormModel
     */
    '_links'?: FormModelLinks;
}
/**
 * 
 * @export
 * @interface FormModelLinks
 */
export interface FormModelLinks {
    /**
     * 
     * @type {FormModelLinksValidate}
     * @memberof FormModelLinks
     */
    'validate'?: FormModelLinksValidate;
    /**
     * 
     * @type {FormModelLinksCommit}
     * @memberof FormModelLinks
     */
    'commit'?: FormModelLinksCommit;
    /**
     * 
     * @type {FormModelLinksPreviewMarkup}
     * @memberof FormModelLinks
     */
    'previewMarkup'?: FormModelLinksPreviewMarkup;
    /**
     * 
     * @type {FormModelLinksSelf}
     * @memberof FormModelLinks
     */
    'self'?: FormModelLinksSelf;
}
/**
 * 
 * @export
 * @interface FormModelLinksCommit
 */
export interface FormModelLinksCommit {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FormModelLinksCommit
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FormModelLinksCommit
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FormModelLinksCommit
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FormModelLinksCommit
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FormModelLinksCommit
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FormModelLinksCommit
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FormModelLinksPreviewMarkup
 */
export interface FormModelLinksPreviewMarkup {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FormModelLinksPreviewMarkup
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FormModelLinksPreviewMarkup
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FormModelLinksPreviewMarkup
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FormModelLinksPreviewMarkup
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FormModelLinksPreviewMarkup
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FormModelLinksPreviewMarkup
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FormModelLinksSelf
 */
export interface FormModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FormModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FormModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FormModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FormModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FormModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FormModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface FormModelLinksValidate
 */
export interface FormModelLinksValidate {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof FormModelLinksValidate
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof FormModelLinksValidate
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof FormModelLinksValidate
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof FormModelLinksValidate
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof FormModelLinksValidate
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof FormModelLinksValidate
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface Formattable
 */
export interface Formattable {
    /**
     * Indicates the formatting language of the raw text
     * @type {string}
     * @memberof Formattable
     */
    'format': FormattableFormatEnum;
    /**
     * The raw text, as entered by the user
     * @type {string}
     * @memberof Formattable
     */
    'raw'?: string;
    /**
     * The text converted to HTML according to the format
     * @type {string}
     * @memberof Formattable
     */
    'html'?: string;
}

export const FormattableFormatEnum = {
    Plain: 'plain',
    Markdown: 'markdown',
    Custom: 'custom'
} as const;

export type FormattableFormatEnum = typeof FormattableFormatEnum[keyof typeof FormattableFormatEnum];

/**
 * 
 * @export
 * @interface GridModel
 */
export interface GridModel {
    /**
     * Grid\'s id
     * @type {number}
     * @memberof GridModel
     */
    'id'?: number;
    /**
     * The number of rows the grid has
     * @type {number}
     * @memberof GridModel
     */
    'rowCount'?: number;
    /**
     * The number of columns the grid has
     * @type {number}
     * @memberof GridModel
     */
    'columnCount'?: number;
    /**
     * The set of `GridWidget`s selected for the grid  # Conditions  The widgets cannot overlap
     * @type {Array<object>}
     * @memberof GridModel
     */
    'widgets'?: Array<object>;
    /**
     * The time the grid was created
     * @type {string}
     * @memberof GridModel
     */
    'createdAt'?: string;
    /**
     * The time the grid was last updated
     * @type {string}
     * @memberof GridModel
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {GridModelLinks}
     * @memberof GridModel
     */
    '_links'?: GridModelLinks;
}
/**
 * 
 * @export
 * @interface GridModelLinks
 */
export interface GridModelLinks {
    /**
     * 
     * @type {GridModelLinksUpdateImmediately}
     * @memberof GridModelLinks
     */
    'updateImmediately'?: GridModelLinksUpdateImmediately;
    /**
     * 
     * @type {GridModelLinksUpdate}
     * @memberof GridModelLinks
     */
    'update'?: GridModelLinksUpdate;
    /**
     * 
     * @type {GridModelLinksSelf}
     * @memberof GridModelLinks
     */
    'self': GridModelLinksSelf;
    /**
     * 
     * @type {GridModelLinksPage}
     * @memberof GridModelLinks
     */
    'page': GridModelLinksPage;
}
/**
 * 
 * @export
 * @interface GridModelLinksPage
 */
export interface GridModelLinksPage {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof GridModelLinksPage
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof GridModelLinksPage
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof GridModelLinksPage
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof GridModelLinksPage
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof GridModelLinksPage
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof GridModelLinksPage
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface GridModelLinksSelf
 */
export interface GridModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof GridModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof GridModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof GridModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof GridModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof GridModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof GridModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface GridModelLinksUpdate
 */
export interface GridModelLinksUpdate {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof GridModelLinksUpdate
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof GridModelLinksUpdate
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof GridModelLinksUpdate
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof GridModelLinksUpdate
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof GridModelLinksUpdate
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof GridModelLinksUpdate
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface GridModelLinksUpdateImmediately
 */
export interface GridModelLinksUpdateImmediately {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof GridModelLinksUpdateImmediately
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof GridModelLinksUpdateImmediately
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof GridModelLinksUpdateImmediately
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof GridModelLinksUpdateImmediately
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof GridModelLinksUpdateImmediately
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof GridModelLinksUpdateImmediately
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface GroupModel
 */
export interface GroupModel {
    /**
     * Group\'s id
     * @type {number}
     * @memberof GroupModel
     */
    'id'?: number;
    /**
     * Group\'s full name, formatting depends on instance settings  # Conditions  Admin to write
     * @type {string}
     * @memberof GroupModel
     */
    'name'?: string;
    /**
     * Time of creation  # Conditions  Only visible by admins
     * @type {string}
     * @memberof GroupModel
     */
    'createdAt'?: string;
    /**
     * Time of the most recent change to the user
     * @type {string}
     * @memberof GroupModel
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {GroupModelLinks}
     * @memberof GroupModel
     */
    '_links'?: GroupModelLinks;
}
/**
 * 
 * @export
 * @interface GroupModelLinks
 */
export interface GroupModelLinks {
    /**
     * 
     * @type {GroupModelLinksDelete}
     * @memberof GroupModelLinks
     */
    'delete'?: GroupModelLinksDelete;
    /**
     * 
     * @type {GroupModelLinksUpdateImmediately}
     * @memberof GroupModelLinks
     */
    'updateImmediately'?: GroupModelLinksUpdateImmediately;
    /**
     * 
     * @type {GroupModelLinksSelf}
     * @memberof GroupModelLinks
     */
    'self': GroupModelLinksSelf;
    /**
     * 
     * @type {GroupModelLinksMemberships}
     * @memberof GroupModelLinks
     */
    'memberships'?: GroupModelLinksMemberships;
    /**
     * 
     * @type {GroupModelLinksMembers}
     * @memberof GroupModelLinks
     */
    'members'?: GroupModelLinksMembers;
}
/**
 * 
 * @export
 * @interface GroupModelLinksDelete
 */
export interface GroupModelLinksDelete {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof GroupModelLinksDelete
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof GroupModelLinksDelete
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof GroupModelLinksDelete
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof GroupModelLinksDelete
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof GroupModelLinksDelete
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof GroupModelLinksDelete
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface GroupModelLinksMembers
 */
export interface GroupModelLinksMembers {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof GroupModelLinksMembers
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof GroupModelLinksMembers
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof GroupModelLinksMembers
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof GroupModelLinksMembers
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof GroupModelLinksMembers
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof GroupModelLinksMembers
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface GroupModelLinksMemberships
 */
export interface GroupModelLinksMemberships {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof GroupModelLinksMemberships
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof GroupModelLinksMemberships
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof GroupModelLinksMemberships
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof GroupModelLinksMemberships
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof GroupModelLinksMemberships
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof GroupModelLinksMemberships
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface GroupModelLinksSelf
 */
export interface GroupModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof GroupModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof GroupModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof GroupModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof GroupModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof GroupModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof GroupModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface GroupModelLinksUpdateImmediately
 */
export interface GroupModelLinksUpdateImmediately {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof GroupModelLinksUpdateImmediately
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof GroupModelLinksUpdateImmediately
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof GroupModelLinksUpdateImmediately
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof GroupModelLinksUpdateImmediately
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof GroupModelLinksUpdateImmediately
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof GroupModelLinksUpdateImmediately
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface HelptextModel
 */
export interface HelptextModel {
    /**
     * Help text id
     * @type {number}
     * @memberof HelptextModel
     */
    'id'?: number;
    /**
     * Attribute name
     * @type {string}
     * @memberof HelptextModel
     */
    'attribute'?: string;
    /**
     * Attribute caption
     * @type {string}
     * @memberof HelptextModel
     */
    'attributeCaption'?: string;
    /**
     * 
     * @type {HelptextModelHelpText}
     * @memberof HelptextModel
     */
    'helpText'?: HelptextModelHelpText;
    /**
     * 
     * @type {HelptextModelLinks}
     * @memberof HelptextModel
     */
    '_links'?: HelptextModelLinks;
}
/**
 * 
 * @export
 * @interface HelptextModelHelpText
 */
export interface HelptextModelHelpText {
    /**
     * Indicates the formatting language of the raw text
     * @type {string}
     * @memberof HelptextModelHelpText
     */
    'format': HelptextModelHelpTextFormatEnum;
    /**
     * The raw text, as entered by the user
     * @type {string}
     * @memberof HelptextModelHelpText
     */
    'raw'?: string;
    /**
     * The text converted to HTML according to the format
     * @type {string}
     * @memberof HelptextModelHelpText
     */
    'html'?: string;
}

export const HelptextModelHelpTextFormatEnum = {
    Plain: 'plain',
    Markdown: 'markdown',
    Custom: 'custom'
} as const;

export type HelptextModelHelpTextFormatEnum = typeof HelptextModelHelpTextFormatEnum[keyof typeof HelptextModelHelpTextFormatEnum];

/**
 * 
 * @export
 * @interface HelptextModelLinks
 */
export interface HelptextModelLinks {
    /**
     * 
     * @type {HelptextModelLinksSelf}
     * @memberof HelptextModelLinks
     */
    'self': HelptextModelLinksSelf;
    /**
     * 
     * @type {HelptextModelLinksEditText}
     * @memberof HelptextModelLinks
     */
    'editText'?: HelptextModelLinksEditText;
}
/**
 * 
 * @export
 * @interface HelptextModelLinksEditText
 */
export interface HelptextModelLinksEditText {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof HelptextModelLinksEditText
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof HelptextModelLinksEditText
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof HelptextModelLinksEditText
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof HelptextModelLinksEditText
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof HelptextModelLinksEditText
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof HelptextModelLinksEditText
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface HelptextModelLinksSelf
 */
export interface HelptextModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof HelptextModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof HelptextModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof HelptextModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof HelptextModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof HelptextModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof HelptextModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof Link
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof Link
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof Link
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof Link
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof Link
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof Link
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface MembershipModel
 */
export interface MembershipModel {
    /**
     * Membership id
     * @type {number}
     * @memberof MembershipModel
     */
    'id'?: number;
    /**
     * Time of creation
     * @type {string}
     * @memberof MembershipModel
     */
    'createdAt': string;
    /**
     * Time of latest update
     * @type {string}
     * @memberof MembershipModel
     */
    'updatedAt': string;
    /**
     * 
     * @type {MembershipModelLinks}
     * @memberof MembershipModel
     */
    '_links'?: MembershipModelLinks;
}
/**
 * 
 * @export
 * @interface MembershipModelLinks
 */
export interface MembershipModelLinks {
    /**
     * 
     * @type {MembershipModelLinksSelf}
     * @memberof MembershipModelLinks
     */
    'self': MembershipModelLinksSelf;
    /**
     * 
     * @type {MembershipModelLinksProject}
     * @memberof MembershipModelLinks
     */
    'project'?: MembershipModelLinksProject;
    /**
     * 
     * @type {MembershipModelLinksRoles}
     * @memberof MembershipModelLinks
     */
    'roles': MembershipModelLinksRoles;
    /**
     * 
     * @type {MembershipModelLinksPrincipal}
     * @memberof MembershipModelLinks
     */
    'principal': MembershipModelLinksPrincipal;
}
/**
 * 
 * @export
 * @interface MembershipModelLinksPrincipal
 */
export interface MembershipModelLinksPrincipal {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof MembershipModelLinksPrincipal
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof MembershipModelLinksPrincipal
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof MembershipModelLinksPrincipal
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof MembershipModelLinksPrincipal
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof MembershipModelLinksPrincipal
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof MembershipModelLinksPrincipal
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface MembershipModelLinksProject
 */
export interface MembershipModelLinksProject {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof MembershipModelLinksProject
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof MembershipModelLinksProject
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof MembershipModelLinksProject
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof MembershipModelLinksProject
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof MembershipModelLinksProject
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof MembershipModelLinksProject
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface MembershipModelLinksRoles
 */
export interface MembershipModelLinksRoles {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof MembershipModelLinksRoles
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof MembershipModelLinksRoles
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof MembershipModelLinksRoles
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof MembershipModelLinksRoles
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof MembershipModelLinksRoles
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof MembershipModelLinksRoles
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface MembershipModelLinksSelf
 */
export interface MembershipModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof MembershipModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof MembershipModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof MembershipModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof MembershipModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof MembershipModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof MembershipModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface NewsModel
 */
export interface NewsModel {
    /**
     * News\' id
     * @type {number}
     * @memberof NewsModel
     */
    'id'?: number;
    /**
     * The headline of the news
     * @type {string}
     * @memberof NewsModel
     */
    'title'?: string;
    /**
     * A short summary
     * @type {string}
     * @memberof NewsModel
     */
    'summary'?: string;
    /**
     * The main body of the news with all the details
     * @type {string}
     * @memberof NewsModel
     */
    'description'?: string;
    /**
     * The time the news was created at
     * @type {string}
     * @memberof NewsModel
     */
    'createdAt'?: string;
    /**
     * 
     * @type {NewsModelLinks}
     * @memberof NewsModel
     */
    '_links'?: NewsModelLinks;
}
/**
 * 
 * @export
 * @interface NewsModelLinks
 */
export interface NewsModelLinks {
    /**
     * 
     * @type {NewsModelLinksSelf}
     * @memberof NewsModelLinks
     */
    'self': NewsModelLinksSelf;
    /**
     * 
     * @type {NewsModelLinksProject}
     * @memberof NewsModelLinks
     */
    'project': NewsModelLinksProject;
    /**
     * 
     * @type {NewsModelLinksAuthor}
     * @memberof NewsModelLinks
     */
    'author': NewsModelLinksAuthor;
}
/**
 * 
 * @export
 * @interface NewsModelLinksAuthor
 */
export interface NewsModelLinksAuthor {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof NewsModelLinksAuthor
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof NewsModelLinksAuthor
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof NewsModelLinksAuthor
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof NewsModelLinksAuthor
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof NewsModelLinksAuthor
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof NewsModelLinksAuthor
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface NewsModelLinksProject
 */
export interface NewsModelLinksProject {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof NewsModelLinksProject
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof NewsModelLinksProject
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof NewsModelLinksProject
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof NewsModelLinksProject
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof NewsModelLinksProject
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof NewsModelLinksProject
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface NewsModelLinksSelf
 */
export interface NewsModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof NewsModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof NewsModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof NewsModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof NewsModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof NewsModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof NewsModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface NonWorkingDayModel
 */
export interface NonWorkingDayModel {
    /**
     * 
     * @type {string}
     * @memberof NonWorkingDayModel
     */
    '_type': NonWorkingDayModelTypeEnum;
    /**
     * Date of the non-working day.
     * @type {string}
     * @memberof NonWorkingDayModel
     */
    'date': string;
    /**
     * Descriptive name for the non-working day.
     * @type {string}
     * @memberof NonWorkingDayModel
     */
    'name': string;
    /**
     * 
     * @type {NonWorkingDayModelLinks}
     * @memberof NonWorkingDayModel
     */
    '_links'?: NonWorkingDayModelLinks;
}

export const NonWorkingDayModelTypeEnum = {
    NonWorkingDay: 'NonWorkingDay'
} as const;

export type NonWorkingDayModelTypeEnum = typeof NonWorkingDayModelTypeEnum[keyof typeof NonWorkingDayModelTypeEnum];

/**
 * 
 * @export
 * @interface NonWorkingDayModelLinks
 */
export interface NonWorkingDayModelLinks {
    /**
     * 
     * @type {NonWorkingDayModelLinksSelf}
     * @memberof NonWorkingDayModelLinks
     */
    'self': NonWorkingDayModelLinksSelf;
}
/**
 * 
 * @export
 * @interface NonWorkingDayModelLinksSelf
 */
export interface NonWorkingDayModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof NonWorkingDayModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof NonWorkingDayModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof NonWorkingDayModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof NonWorkingDayModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof NonWorkingDayModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof NonWorkingDayModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface NotificationCollectionModel
 */
export interface NotificationCollectionModel {
    /**
     * The total amount of elements available in the collection
     * @type {number}
     * @memberof NotificationCollectionModel
     */
    'total'?: number;
    /**
     * Amount of elements that a response will hold
     * @type {number}
     * @memberof NotificationCollectionModel
     */
    'pageSize'?: number;
    /**
     * Actual amount of elements in this response
     * @type {number}
     * @memberof NotificationCollectionModel
     */
    'count'?: number;
    /**
     * The page number that is requested from paginated collection
     * @type {number}
     * @memberof NotificationCollectionModel
     */
    'offset'?: number;
    /**
     * Summarized information about aggregation groups
     * @type {object}
     * @memberof NotificationCollectionModel
     */
    'groups'?: object;
    /**
     * Aggregations of supported values for elements of the collection
     * @type {object}
     * @memberof NotificationCollectionModel
     */
    'totalSums'?: object;
    /**
     * 
     * @type {NotificationCollectionModelAllOfLinks}
     * @memberof NotificationCollectionModel
     */
    '_links': NotificationCollectionModelAllOfLinks;
    /**
     * 
     * @type {NotificationCollectionModelAllOfEmbedded}
     * @memberof NotificationCollectionModel
     */
    '_embedded': NotificationCollectionModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface NotificationCollectionModelAllOf
 */
export interface NotificationCollectionModelAllOf {
    /**
     * 
     * @type {NotificationCollectionModelAllOfLinks}
     * @memberof NotificationCollectionModelAllOf
     */
    '_links': NotificationCollectionModelAllOfLinks;
    /**
     * 
     * @type {NotificationCollectionModelAllOfEmbedded}
     * @memberof NotificationCollectionModelAllOf
     */
    '_embedded': NotificationCollectionModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface NotificationCollectionModelAllOfEmbedded
 */
export interface NotificationCollectionModelAllOfEmbedded {
    /**
     * 
     * @type {Array<NotificationModel>}
     * @memberof NotificationCollectionModelAllOfEmbedded
     */
    'elements': Array<NotificationModel>;
    /**
     * 
     * @type {Array<SchemaModel>}
     * @memberof NotificationCollectionModelAllOfEmbedded
     */
    'detailsSchemas': Array<SchemaModel>;
}
/**
 * 
 * @export
 * @interface NotificationCollectionModelAllOfLinks
 */
export interface NotificationCollectionModelAllOfLinks {
    /**
     * 
     * @type {Link}
     * @memberof NotificationCollectionModelAllOfLinks
     */
    'self': Link;
    /**
     * 
     * @type {Link}
     * @memberof NotificationCollectionModelAllOfLinks
     */
    'jumpTo'?: Link;
    /**
     * 
     * @type {Link}
     * @memberof NotificationCollectionModelAllOfLinks
     */
    'changeSize'?: Link;
}
/**
 * 
 * @export
 * @interface NotificationModel
 */
export interface NotificationModel {
    /**
     * 
     * @type {string}
     * @memberof NotificationModel
     */
    '_type'?: NotificationModelTypeEnum;
    /**
     * Notification id
     * @type {number}
     * @memberof NotificationModel
     */
    'id'?: number;
    /**
     * The reason for the notification
     * @type {string}
     * @memberof NotificationModel
     */
    'reason'?: NotificationModelReasonEnum;
    /**
     * Whether the notification is marked as read
     * @type {boolean}
     * @memberof NotificationModel
     */
    'readIAN'?: boolean;
    /**
     * A list of objects including detailed information about the notification.
     * @type {Array<NotificationModelDetailsInner>}
     * @memberof NotificationModel
     */
    'details'?: Array<NotificationModelDetailsInner>;
    /**
     * The time the notification was created at
     * @type {string}
     * @memberof NotificationModel
     */
    'createdAt'?: string;
    /**
     * The time the notification was last updated
     * @type {string}
     * @memberof NotificationModel
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {NotificationModelEmbedded}
     * @memberof NotificationModel
     */
    '_embedded'?: NotificationModelEmbedded;
    /**
     * 
     * @type {NotificationModelLinks}
     * @memberof NotificationModel
     */
    '_links'?: NotificationModelLinks;
}

export const NotificationModelTypeEnum = {
    Notification: 'Notification'
} as const;

export type NotificationModelTypeEnum = typeof NotificationModelTypeEnum[keyof typeof NotificationModelTypeEnum];
export const NotificationModelReasonEnum = {
    Assigned: 'assigned',
    Commented: 'commented',
    Created: 'created',
    DateAlert: 'dateAlert',
    Mentioned: 'mentioned',
    Prioritized: 'prioritized',
    Processed: 'processed',
    Responsible: 'responsible',
    Subscribed: 'subscribed',
    Scheduled: 'scheduled',
    Watched: 'watched'
} as const;

export type NotificationModelReasonEnum = typeof NotificationModelReasonEnum[keyof typeof NotificationModelReasonEnum];

/**
 * @type NotificationModelDetailsInner
 * @export
 */
export type NotificationModelDetailsInner = ValuesPropertyModel;

/**
 * 
 * @export
 * @interface NotificationModelEmbedded
 */
export interface NotificationModelEmbedded {
    /**
     * 
     * @type {UserModel}
     * @memberof NotificationModelEmbedded
     */
    'actor'?: UserModel;
    /**
     * 
     * @type {ProjectModel}
     * @memberof NotificationModelEmbedded
     */
    'project': ProjectModel;
    /**
     * 
     * @type {ActivityModel}
     * @memberof NotificationModelEmbedded
     */
    'activity'?: ActivityModel;
    /**
     * 
     * @type {NotificationModelEmbeddedResource}
     * @memberof NotificationModelEmbedded
     */
    'resource': NotificationModelEmbeddedResource;
}
/**
 * @type NotificationModelEmbeddedResource
 * @export
 */
export type NotificationModelEmbeddedResource = WorkPackageModel;

/**
 * 
 * @export
 * @interface NotificationModelLinks
 */
export interface NotificationModelLinks {
    /**
     * 
     * @type {NotificationModelLinksSelf}
     * @memberof NotificationModelLinks
     */
    'self': NotificationModelLinksSelf;
    /**
     * 
     * @type {NotificationModelLinksReadIAN}
     * @memberof NotificationModelLinks
     */
    'readIAN'?: NotificationModelLinksReadIAN;
    /**
     * 
     * @type {NotificationModelLinksUnreadIAN}
     * @memberof NotificationModelLinks
     */
    'unreadIAN'?: NotificationModelLinksUnreadIAN;
    /**
     * 
     * @type {NotificationModelLinksProject}
     * @memberof NotificationModelLinks
     */
    'project': NotificationModelLinksProject;
    /**
     * 
     * @type {NotificationModelLinksActor}
     * @memberof NotificationModelLinks
     */
    'actor': NotificationModelLinksActor;
    /**
     * 
     * @type {NotificationModelLinksResource}
     * @memberof NotificationModelLinks
     */
    'resource': NotificationModelLinksResource;
    /**
     * 
     * @type {NotificationModelLinksActivity}
     * @memberof NotificationModelLinks
     */
    'activity': NotificationModelLinksActivity;
    /**
     * 
     * @type {Array<NotificationModelLinksDetailsInner>}
     * @memberof NotificationModelLinks
     */
    'details': Array<NotificationModelLinksDetailsInner>;
}
/**
 * 
 * @export
 * @interface NotificationModelLinksActivity
 */
export interface NotificationModelLinksActivity {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof NotificationModelLinksActivity
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof NotificationModelLinksActivity
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof NotificationModelLinksActivity
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof NotificationModelLinksActivity
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof NotificationModelLinksActivity
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof NotificationModelLinksActivity
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface NotificationModelLinksActor
 */
export interface NotificationModelLinksActor {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof NotificationModelLinksActor
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof NotificationModelLinksActor
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof NotificationModelLinksActor
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof NotificationModelLinksActor
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof NotificationModelLinksActor
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof NotificationModelLinksActor
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface NotificationModelLinksDetailsInner
 */
export interface NotificationModelLinksDetailsInner {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof NotificationModelLinksDetailsInner
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof NotificationModelLinksDetailsInner
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof NotificationModelLinksDetailsInner
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof NotificationModelLinksDetailsInner
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof NotificationModelLinksDetailsInner
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof NotificationModelLinksDetailsInner
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface NotificationModelLinksProject
 */
export interface NotificationModelLinksProject {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof NotificationModelLinksProject
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof NotificationModelLinksProject
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof NotificationModelLinksProject
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof NotificationModelLinksProject
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof NotificationModelLinksProject
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof NotificationModelLinksProject
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface NotificationModelLinksReadIAN
 */
export interface NotificationModelLinksReadIAN {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof NotificationModelLinksReadIAN
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof NotificationModelLinksReadIAN
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof NotificationModelLinksReadIAN
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof NotificationModelLinksReadIAN
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof NotificationModelLinksReadIAN
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof NotificationModelLinksReadIAN
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface NotificationModelLinksResource
 */
export interface NotificationModelLinksResource {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof NotificationModelLinksResource
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof NotificationModelLinksResource
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof NotificationModelLinksResource
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof NotificationModelLinksResource
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof NotificationModelLinksResource
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof NotificationModelLinksResource
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface NotificationModelLinksSelf
 */
export interface NotificationModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof NotificationModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof NotificationModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof NotificationModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof NotificationModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof NotificationModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof NotificationModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface NotificationModelLinksUnreadIAN
 */
export interface NotificationModelLinksUnreadIAN {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof NotificationModelLinksUnreadIAN
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof NotificationModelLinksUnreadIAN
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof NotificationModelLinksUnreadIAN
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof NotificationModelLinksUnreadIAN
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof NotificationModelLinksUnreadIAN
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof NotificationModelLinksUnreadIAN
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface NotificationSettingsModelInner
 */
export interface NotificationSettingsModelInner {
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'documentAdded': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'forumMessages': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'involved': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'membershipAdded': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'membershipUpdated': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'mentioned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'newsAdded': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'newsCommented': boolean;
    /**
     * Sets an overdue notification for work packages. It is null when no notification is set, otherwise it holds an ISO8601 formatted duration string with the possible values listed below. The possible values are: none, every day, every 3 days, every week.
     * @type {string}
     * @memberof NotificationSettingsModelInner
     */
    'overdue'?: NotificationSettingsModelInnerOverdueEnum;
    /**
     * Sets a startDate notification for work packages. It is null when no notification is set, otherwise it holds an ISO8601 formatted duration string with the possible values listed below. The possible values are: none, same day, 1 day before, 3 days before, 1 week before.
     * @type {string}
     * @memberof NotificationSettingsModelInner
     */
    'startDate'?: NotificationSettingsModelInnerStartDateEnum;
    /**
     * Sets a dueDate notification for work packages. It is null when no notification is set, otherwise it holds an ISO8601 formatted duration string with the possible values listed below. The possible values are: none, same day, 1 day before, 3 days before, 1 week before.
     * @type {string}
     * @memberof NotificationSettingsModelInner
     */
    'dueDate'?: NotificationSettingsModelInnerDueDateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'watched': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'workPackageCreated': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'workPackageCommented': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'workPackageProcessed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'workPackagePrioritized': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'workPackageScheduled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'wikiPageAdded': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingsModelInner
     */
    'wikiPageUpdated': boolean;
    /**
     * 
     * @type {NotificationSettingsModelInnerLinks}
     * @memberof NotificationSettingsModelInner
     */
    '_links': NotificationSettingsModelInnerLinks;
}

export const NotificationSettingsModelInnerOverdueEnum = {
    Empty: '',
    P1D: 'P1D',
    P3D: 'P3D',
    P1W: 'P1W'
} as const;

export type NotificationSettingsModelInnerOverdueEnum = typeof NotificationSettingsModelInnerOverdueEnum[keyof typeof NotificationSettingsModelInnerOverdueEnum];
export const NotificationSettingsModelInnerStartDateEnum = {
    Empty: '',
    Pt0S: 'PT0S',
    P1D: 'P1D',
    P3D: 'P3D',
    P1W: 'P1W'
} as const;

export type NotificationSettingsModelInnerStartDateEnum = typeof NotificationSettingsModelInnerStartDateEnum[keyof typeof NotificationSettingsModelInnerStartDateEnum];
export const NotificationSettingsModelInnerDueDateEnum = {
    Empty: '',
    Pt0S: 'PT0S',
    P1D: 'P1D',
    P3D: 'P3D',
    P1W: 'P1W'
} as const;

export type NotificationSettingsModelInnerDueDateEnum = typeof NotificationSettingsModelInnerDueDateEnum[keyof typeof NotificationSettingsModelInnerDueDateEnum];

/**
 * 
 * @export
 * @interface NotificationSettingsModelInnerLinks
 */
export interface NotificationSettingsModelInnerLinks {
    /**
     * 
     * @type {NotificationSettingsModelInnerLinksProject}
     * @memberof NotificationSettingsModelInnerLinks
     */
    'project': NotificationSettingsModelInnerLinksProject;
}
/**
 * 
 * @export
 * @interface NotificationSettingsModelInnerLinksProject
 */
export interface NotificationSettingsModelInnerLinksProject {
    /**
     * 
     * @type {string}
     * @memberof NotificationSettingsModelInnerLinksProject
     */
    'href': string;
}
/**
 * 
 * @export
 * @interface PostModel
 */
export interface PostModel {
    /**
     * Identifier of this post
     * @type {number}
     * @memberof PostModel
     */
    'id'?: number;
    /**
     * The post\'s subject
     * @type {string}
     * @memberof PostModel
     */
    'subject': string;
    /**
     * 
     * @type {PostModelLinks}
     * @memberof PostModel
     */
    '_links'?: PostModelLinks;
}
/**
 * 
 * @export
 * @interface PostModelLinks
 */
export interface PostModelLinks {
    /**
     * 
     * @type {PostModelLinksAddAttachment}
     * @memberof PostModelLinks
     */
    'addAttachment'?: PostModelLinksAddAttachment;
}
/**
 * 
 * @export
 * @interface PostModelLinksAddAttachment
 */
export interface PostModelLinksAddAttachment {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof PostModelLinksAddAttachment
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof PostModelLinksAddAttachment
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof PostModelLinksAddAttachment
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof PostModelLinksAddAttachment
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof PostModelLinksAddAttachment
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof PostModelLinksAddAttachment
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface PriorityModel
 */
export interface PriorityModel {
    /**
     * Priority id
     * @type {number}
     * @memberof PriorityModel
     */
    'id'?: number;
    /**
     * Priority name
     * @type {string}
     * @memberof PriorityModel
     */
    'name'?: string;
    /**
     * Sort index of the priority
     * @type {number}
     * @memberof PriorityModel
     */
    'position'?: number;
    /**
     * Indicates whether this is the default value
     * @type {boolean}
     * @memberof PriorityModel
     */
    'isDefault'?: boolean;
    /**
     * Indicates whether the priority is available
     * @type {boolean}
     * @memberof PriorityModel
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {PriorityModelLinks}
     * @memberof PriorityModel
     */
    '_links'?: PriorityModelLinks;
}
/**
 * 
 * @export
 * @interface PriorityModelLinks
 */
export interface PriorityModelLinks {
    /**
     * 
     * @type {PriorityModelLinksSelf}
     * @memberof PriorityModelLinks
     */
    'self': PriorityModelLinksSelf;
}
/**
 * 
 * @export
 * @interface PriorityModelLinksSelf
 */
export interface PriorityModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof PriorityModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof PriorityModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof PriorityModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof PriorityModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof PriorityModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof PriorityModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModel
 */
export interface ProjectModel {
    /**
     * 
     * @type {string}
     * @memberof ProjectModel
     */
    '_type'?: ProjectModelTypeEnum;
    /**
     * Projects\' id
     * @type {number}
     * @memberof ProjectModel
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectModel
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectModel
     */
    'name'?: string;
    /**
     * Indicates whether the project is currently active or already archived
     * @type {boolean}
     * @memberof ProjectModel
     */
    'active'?: boolean;
    /**
     * 
     * @type {ProjectModelStatusExplanation}
     * @memberof ProjectModel
     */
    'statusExplanation'?: ProjectModelStatusExplanation;
    /**
     * Indicates whether the project is accessible for everybody
     * @type {boolean}
     * @memberof ProjectModel
     */
    'public'?: boolean;
    /**
     * 
     * @type {Formattable}
     * @memberof ProjectModel
     */
    'description'?: Formattable;
    /**
     * Time of creation
     * @type {string}
     * @memberof ProjectModel
     */
    'createdAt'?: string;
    /**
     * Time of the most recent change to the project
     * @type {string}
     * @memberof ProjectModel
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {ProjectModelLinks}
     * @memberof ProjectModel
     */
    '_links'?: ProjectModelLinks;
}

export const ProjectModelTypeEnum = {
    Project: 'Project'
} as const;

export type ProjectModelTypeEnum = typeof ProjectModelTypeEnum[keyof typeof ProjectModelTypeEnum];

/**
 * 
 * @export
 * @interface ProjectModelLinks
 */
export interface ProjectModelLinks {
    /**
     * 
     * @type {ProjectModelLinksUpdate}
     * @memberof ProjectModelLinks
     */
    'update'?: ProjectModelLinksUpdate;
    /**
     * 
     * @type {ProjectModelLinksUpdateImmediately}
     * @memberof ProjectModelLinks
     */
    'updateImmediately'?: ProjectModelLinksUpdateImmediately;
    /**
     * 
     * @type {ProjectModelLinksDelete}
     * @memberof ProjectModelLinks
     */
    'delete'?: ProjectModelLinksDelete;
    /**
     * 
     * @type {ProjectModelLinksCreateWorkPackage}
     * @memberof ProjectModelLinks
     */
    'createWorkPackage'?: ProjectModelLinksCreateWorkPackage;
    /**
     * 
     * @type {ProjectModelLinksCreateWorkPackageImmediately}
     * @memberof ProjectModelLinks
     */
    'createWorkPackageImmediately'?: ProjectModelLinksCreateWorkPackageImmediately;
    /**
     * 
     * @type {ProjectModelLinksSelf}
     * @memberof ProjectModelLinks
     */
    'self': ProjectModelLinksSelf;
    /**
     * 
     * @type {ProjectModelLinksCategories}
     * @memberof ProjectModelLinks
     */
    'categories': ProjectModelLinksCategories;
    /**
     * 
     * @type {ProjectModelLinksTypes}
     * @memberof ProjectModelLinks
     */
    'types': ProjectModelLinksTypes;
    /**
     * 
     * @type {ProjectModelLinksVersions}
     * @memberof ProjectModelLinks
     */
    'versions': ProjectModelLinksVersions;
    /**
     * 
     * @type {ProjectModelLinksMemberships}
     * @memberof ProjectModelLinks
     */
    'memberships': ProjectModelLinksMemberships;
    /**
     * 
     * @type {ProjectModelLinksWorkPackages}
     * @memberof ProjectModelLinks
     */
    'workPackages': ProjectModelLinksWorkPackages;
    /**
     * 
     * @type {ProjectModelLinksParent}
     * @memberof ProjectModelLinks
     */
    'parent'?: ProjectModelLinksParent;
    /**
     * 
     * @type {ProjectModelLinksStatus}
     * @memberof ProjectModelLinks
     */
    'status'?: ProjectModelLinksStatus;
    /**
     * 
     * @type {Array<ProjectModelLinksStoragesInner>}
     * @memberof ProjectModelLinks
     */
    'storages'?: Array<ProjectModelLinksStoragesInner>;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksCategories
 */
export interface ProjectModelLinksCategories {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksCategories
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksCategories
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksCategories
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksCategories
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksCategories
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksCategories
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksCreateWorkPackage
 */
export interface ProjectModelLinksCreateWorkPackage {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksCreateWorkPackage
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksCreateWorkPackage
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksCreateWorkPackage
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksCreateWorkPackage
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksCreateWorkPackage
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksCreateWorkPackage
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksCreateWorkPackageImmediately
 */
export interface ProjectModelLinksCreateWorkPackageImmediately {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksCreateWorkPackageImmediately
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksCreateWorkPackageImmediately
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksCreateWorkPackageImmediately
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksCreateWorkPackageImmediately
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksCreateWorkPackageImmediately
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksCreateWorkPackageImmediately
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksDelete
 */
export interface ProjectModelLinksDelete {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksDelete
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksDelete
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksDelete
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksDelete
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksDelete
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksDelete
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksMemberships
 */
export interface ProjectModelLinksMemberships {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksMemberships
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksMemberships
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksMemberships
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksMemberships
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksMemberships
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksMemberships
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksParent
 */
export interface ProjectModelLinksParent {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksParent
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksParent
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksParent
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksParent
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksParent
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksParent
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksSelf
 */
export interface ProjectModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksStatus
 */
export interface ProjectModelLinksStatus {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksStatus
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksStatus
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksStatus
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksStatus
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksStatus
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksStatus
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksStoragesInner
 */
export interface ProjectModelLinksStoragesInner {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksStoragesInner
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksStoragesInner
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksStoragesInner
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksStoragesInner
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksStoragesInner
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksStoragesInner
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksTypes
 */
export interface ProjectModelLinksTypes {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksTypes
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksTypes
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksTypes
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksTypes
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksTypes
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksTypes
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksUpdate
 */
export interface ProjectModelLinksUpdate {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksUpdate
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksUpdate
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksUpdate
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksUpdate
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksUpdate
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksUpdate
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksUpdateImmediately
 */
export interface ProjectModelLinksUpdateImmediately {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksUpdateImmediately
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksUpdateImmediately
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksUpdateImmediately
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksUpdateImmediately
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksUpdateImmediately
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksUpdateImmediately
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksVersions
 */
export interface ProjectModelLinksVersions {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksVersions
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksVersions
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksVersions
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksVersions
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksVersions
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksVersions
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelLinksWorkPackages
 */
export interface ProjectModelLinksWorkPackages {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ProjectModelLinksWorkPackages
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ProjectModelLinksWorkPackages
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ProjectModelLinksWorkPackages
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ProjectModelLinksWorkPackages
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ProjectModelLinksWorkPackages
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ProjectModelLinksWorkPackages
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ProjectModelStatusExplanation
 */
export interface ProjectModelStatusExplanation {
    /**
     * Indicates the formatting language of the raw text
     * @type {string}
     * @memberof ProjectModelStatusExplanation
     */
    'format': ProjectModelStatusExplanationFormatEnum;
    /**
     * The raw text, as entered by the user
     * @type {string}
     * @memberof ProjectModelStatusExplanation
     */
    'raw'?: string;
    /**
     * The text converted to HTML according to the format
     * @type {string}
     * @memberof ProjectModelStatusExplanation
     */
    'html'?: string;
}

export const ProjectModelStatusExplanationFormatEnum = {
    Plain: 'plain',
    Markdown: 'markdown',
    Custom: 'custom'
} as const;

export type ProjectModelStatusExplanationFormatEnum = typeof ProjectModelStatusExplanationFormatEnum[keyof typeof ProjectModelStatusExplanationFormatEnum];

/**
 * 
 * @export
 * @interface QueryColumnModel
 */
export interface QueryColumnModel {
    /**
     * Query column id
     * @type {string}
     * @memberof QueryColumnModel
     */
    'id': string;
    /**
     * Query column name
     * @type {string}
     * @memberof QueryColumnModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface QueryFilterInstanceSchemaModel
 */
export interface QueryFilterInstanceSchemaModel {
    /**
     * Describes the name attribute
     * @type {string}
     * @memberof QueryFilterInstanceSchemaModel
     */
    'name': string;
    /**
     * QuerySortBy name
     * @type {string}
     * @memberof QueryFilterInstanceSchemaModel
     */
    'filter': string;
    /**
     * 
     * @type {QueryFilterInstanceSchemaModelLinks}
     * @memberof QueryFilterInstanceSchemaModel
     */
    '_links'?: QueryFilterInstanceSchemaModelLinks;
}
/**
 * 
 * @export
 * @interface QueryFilterInstanceSchemaModelLinks
 */
export interface QueryFilterInstanceSchemaModelLinks {
    /**
     * 
     * @type {QueryFilterInstanceSchemaModelLinksSelf}
     * @memberof QueryFilterInstanceSchemaModelLinks
     */
    'self': QueryFilterInstanceSchemaModelLinksSelf;
    /**
     * 
     * @type {QueryFilterInstanceSchemaModelLinksFilter}
     * @memberof QueryFilterInstanceSchemaModelLinks
     */
    'filter': QueryFilterInstanceSchemaModelLinksFilter;
}
/**
 * 
 * @export
 * @interface QueryFilterInstanceSchemaModelLinksFilter
 */
export interface QueryFilterInstanceSchemaModelLinksFilter {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof QueryFilterInstanceSchemaModelLinksFilter
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof QueryFilterInstanceSchemaModelLinksFilter
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof QueryFilterInstanceSchemaModelLinksFilter
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof QueryFilterInstanceSchemaModelLinksFilter
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof QueryFilterInstanceSchemaModelLinksFilter
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof QueryFilterInstanceSchemaModelLinksFilter
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface QueryFilterInstanceSchemaModelLinksSelf
 */
export interface QueryFilterInstanceSchemaModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof QueryFilterInstanceSchemaModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof QueryFilterInstanceSchemaModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof QueryFilterInstanceSchemaModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof QueryFilterInstanceSchemaModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof QueryFilterInstanceSchemaModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof QueryFilterInstanceSchemaModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface QueryFilterModel
 */
export interface QueryFilterModel {
    /**
     * QueryFilter id
     * @type {string}
     * @memberof QueryFilterModel
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface QueryModel
 */
export interface QueryModel {
    /**
     * Query id
     * @type {number}
     * @memberof QueryModel
     */
    'id'?: number;
    /**
     * Query name
     * @type {string}
     * @memberof QueryModel
     */
    'name'?: string;
    /**
     * A set of QueryFilters which will be applied to the work packages to determine the resulting work packages
     * @type {Array<QueryFilterInstanceSchemaModel>}
     * @memberof QueryModel
     */
    'filters'?: Array<QueryFilterInstanceSchemaModel>;
    /**
     * Should sums (of supported properties) be shown?
     * @type {boolean}
     * @memberof QueryModel
     */
    'sums'?: boolean;
    /**
     * Should the timeline mode be shown?
     * @type {boolean}
     * @memberof QueryModel
     * @deprecated
     */
    'timelineVisible'?: boolean;
    /**
     * Which labels are shown in the timeline, empty when default
     * @type {Array<string>}
     * @memberof QueryModel
     * @deprecated
     */
    'timelineLabels'?: Array<string>;
    /**
     * Which zoom level should the timeline be rendered in?
     * @type {string}
     * @memberof QueryModel
     * @deprecated
     */
    'timelineZoomLevel'?: string;
    /**
     * Which highlighting mode should the table have?
     * @type {string}
     * @memberof QueryModel
     * @deprecated
     */
    'highlightingMode'?: string;
    /**
     * Should the hierarchy mode be enabled?
     * @type {boolean}
     * @memberof QueryModel
     * @deprecated
     */
    'showHierarchies'?: boolean;
    /**
     * Should the query be hidden from the query list?
     * @type {boolean}
     * @memberof QueryModel
     * @deprecated
     */
    'hidden'?: boolean;
    /**
     * Can users besides the owner see the query?
     * @type {boolean}
     * @memberof QueryModel
     */
    'public'?: boolean;
    /**
     * Should the query be highlighted to the user?
     * @type {boolean}
     * @memberof QueryModel
     */
    'starred'?: boolean;
    /**
     * Time of creation
     * @type {string}
     * @memberof QueryModel
     */
    'createdAt': string;
    /**
     * Time of the most recent change to the query
     * @type {string}
     * @memberof QueryModel
     */
    'updatedAt': string;
    /**
     * 
     * @type {QueryModelLinks}
     * @memberof QueryModel
     */
    '_links'?: QueryModelLinks;
}
/**
 * 
 * @export
 * @interface QueryModelLinks
 */
export interface QueryModelLinks {
    /**
     * 
     * @type {QueryModelLinksStar}
     * @memberof QueryModelLinks
     */
    'star'?: QueryModelLinksStar;
    /**
     * 
     * @type {QueryModelLinksUnstar}
     * @memberof QueryModelLinks
     */
    'unstar'?: QueryModelLinksUnstar;
    /**
     * 
     * @type {QueryModelLinksUpdate}
     * @memberof QueryModelLinks
     */
    'update'?: QueryModelLinksUpdate;
    /**
     * 
     * @type {QueryModelLinksUpdateImmediately}
     * @memberof QueryModelLinks
     */
    'updateImmediately'?: QueryModelLinksUpdateImmediately;
}
/**
 * 
 * @export
 * @interface QueryModelLinksStar
 */
export interface QueryModelLinksStar {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof QueryModelLinksStar
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof QueryModelLinksStar
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof QueryModelLinksStar
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof QueryModelLinksStar
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof QueryModelLinksStar
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof QueryModelLinksStar
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface QueryModelLinksUnstar
 */
export interface QueryModelLinksUnstar {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof QueryModelLinksUnstar
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof QueryModelLinksUnstar
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof QueryModelLinksUnstar
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof QueryModelLinksUnstar
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof QueryModelLinksUnstar
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof QueryModelLinksUnstar
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface QueryModelLinksUpdate
 */
export interface QueryModelLinksUpdate {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof QueryModelLinksUpdate
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof QueryModelLinksUpdate
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof QueryModelLinksUpdate
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof QueryModelLinksUpdate
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof QueryModelLinksUpdate
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof QueryModelLinksUpdate
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface QueryModelLinksUpdateImmediately
 */
export interface QueryModelLinksUpdateImmediately {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof QueryModelLinksUpdateImmediately
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof QueryModelLinksUpdateImmediately
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof QueryModelLinksUpdateImmediately
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof QueryModelLinksUpdateImmediately
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof QueryModelLinksUpdateImmediately
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof QueryModelLinksUpdateImmediately
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface QueryOperatorModel
 */
export interface QueryOperatorModel {
    /**
     * Query operator id
     * @type {string}
     * @memberof QueryOperatorModel
     */
    'id': string;
    /**
     * Query operator name
     * @type {string}
     * @memberof QueryOperatorModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface QuerySortByModel
 */
export interface QuerySortByModel {
    /**
     * QuerySortBy id
     * @type {string}
     * @memberof QuerySortByModel
     */
    'id': string;
    /**
     * QuerySortBy name
     * @type {string}
     * @memberof QuerySortByModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface RelationModel
 */
export interface RelationModel {
    /**
     * Relation ID
     * @type {number}
     * @memberof RelationModel
     */
    'id'?: number;
    /**
     * The internationalized name of this kind of relation
     * @type {string}
     * @memberof RelationModel
     */
    'name'?: string;
    /**
     * Which kind of relation (blocks, precedes, etc.)
     * @type {string}
     * @memberof RelationModel
     */
    'type'?: string;
    /**
     * The kind of relation from the other WP\'s perspective
     * @type {string}
     * @memberof RelationModel
     */
    'reverseType'?: string;
    /**
     * Short text further describing the relation
     * @type {string}
     * @memberof RelationModel
     */
    'description'?: string;
    /**
     * The delay in days between closing of `from` and start of `to`
     * @type {number}
     * @memberof RelationModel
     */
    'delay*'?: number;
    /**
     * 
     * @type {RelationModelLinks}
     * @memberof RelationModel
     */
    '_links'?: RelationModelLinks;
}
/**
 * 
 * @export
 * @interface RelationModelLinks
 */
export interface RelationModelLinks {
    /**
     * 
     * @type {RelationModelLinksUpdate}
     * @memberof RelationModelLinks
     */
    'update'?: RelationModelLinksUpdate;
    /**
     * 
     * @type {RelationModelLinksUpdateImmediately}
     * @memberof RelationModelLinks
     */
    'updateImmediately'?: RelationModelLinksUpdateImmediately;
    /**
     * 
     * @type {RelationModelLinksDelete}
     * @memberof RelationModelLinks
     */
    'delete'?: RelationModelLinksDelete;
    /**
     * 
     * @type {RelationModelLinksSelf}
     * @memberof RelationModelLinks
     */
    'self': RelationModelLinksSelf;
    /**
     * 
     * @type {RelationModelLinksSchema}
     * @memberof RelationModelLinks
     */
    'schema': RelationModelLinksSchema;
    /**
     * 
     * @type {RelationModelLinksFrom}
     * @memberof RelationModelLinks
     */
    'from': RelationModelLinksFrom;
    /**
     * 
     * @type {RelationModelLinksTo}
     * @memberof RelationModelLinks
     */
    'to': RelationModelLinksTo;
}
/**
 * 
 * @export
 * @interface RelationModelLinksDelete
 */
export interface RelationModelLinksDelete {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RelationModelLinksDelete
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RelationModelLinksDelete
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RelationModelLinksDelete
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RelationModelLinksDelete
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RelationModelLinksDelete
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RelationModelLinksDelete
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RelationModelLinksFrom
 */
export interface RelationModelLinksFrom {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RelationModelLinksFrom
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RelationModelLinksFrom
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RelationModelLinksFrom
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RelationModelLinksFrom
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RelationModelLinksFrom
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RelationModelLinksFrom
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RelationModelLinksSchema
 */
export interface RelationModelLinksSchema {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RelationModelLinksSchema
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RelationModelLinksSchema
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RelationModelLinksSchema
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RelationModelLinksSchema
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RelationModelLinksSchema
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RelationModelLinksSchema
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RelationModelLinksSelf
 */
export interface RelationModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RelationModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RelationModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RelationModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RelationModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RelationModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RelationModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RelationModelLinksTo
 */
export interface RelationModelLinksTo {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RelationModelLinksTo
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RelationModelLinksTo
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RelationModelLinksTo
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RelationModelLinksTo
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RelationModelLinksTo
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RelationModelLinksTo
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RelationModelLinksUpdate
 */
export interface RelationModelLinksUpdate {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RelationModelLinksUpdate
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RelationModelLinksUpdate
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RelationModelLinksUpdate
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RelationModelLinksUpdate
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RelationModelLinksUpdate
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RelationModelLinksUpdate
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RelationModelLinksUpdateImmediately
 */
export interface RelationModelLinksUpdateImmediately {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RelationModelLinksUpdateImmediately
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RelationModelLinksUpdateImmediately
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RelationModelLinksUpdateImmediately
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RelationModelLinksUpdateImmediately
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RelationModelLinksUpdateImmediately
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RelationModelLinksUpdateImmediately
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RevisionModel
 */
export interface RevisionModel {
    /**
     * Revision\'s id, assigned by OpenProject
     * @type {number}
     * @memberof RevisionModel
     */
    'id'?: number;
    /**
     * The raw SCM identifier of the revision (e.g. full SHA hash)
     * @type {string}
     * @memberof RevisionModel
     */
    'identifier': string;
    /**
     * The SCM identifier of the revision, formatted (e.g. shortened unambiguous SHA hash). May be identical to identifier in many cases
     * @type {string}
     * @memberof RevisionModel
     */
    'formattedIdentifier': string;
    /**
     * The name of the author that committed this revision. Note that this name is retrieved from the repository and does not identify a user in OpenProject.
     * @type {string}
     * @memberof RevisionModel
     */
    'authorName': string;
    /**
     * 
     * @type {RevisionModelMessage}
     * @memberof RevisionModel
     */
    'message': RevisionModelMessage;
    /**
     * The time this revision was committed to the repository
     * @type {string}
     * @memberof RevisionModel
     */
    'createdAt': string;
    /**
     * 
     * @type {RevisionModelLinks}
     * @memberof RevisionModel
     */
    '_links'?: RevisionModelLinks;
}
/**
 * 
 * @export
 * @interface RevisionModelLinks
 */
export interface RevisionModelLinks {
    /**
     * 
     * @type {RevisionModelLinksSelf}
     * @memberof RevisionModelLinks
     */
    'self': RevisionModelLinksSelf;
    /**
     * 
     * @type {RevisionModelLinksProject}
     * @memberof RevisionModelLinks
     */
    'project': RevisionModelLinksProject;
    /**
     * 
     * @type {RevisionModelLinksAuthor}
     * @memberof RevisionModelLinks
     */
    'author'?: RevisionModelLinksAuthor;
    /**
     * 
     * @type {RevisionModelLinksShowRevision}
     * @memberof RevisionModelLinks
     */
    'showRevision': RevisionModelLinksShowRevision;
}
/**
 * 
 * @export
 * @interface RevisionModelLinksAuthor
 */
export interface RevisionModelLinksAuthor {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RevisionModelLinksAuthor
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RevisionModelLinksAuthor
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RevisionModelLinksAuthor
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RevisionModelLinksAuthor
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RevisionModelLinksAuthor
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RevisionModelLinksAuthor
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RevisionModelLinksProject
 */
export interface RevisionModelLinksProject {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RevisionModelLinksProject
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RevisionModelLinksProject
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RevisionModelLinksProject
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RevisionModelLinksProject
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RevisionModelLinksProject
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RevisionModelLinksProject
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RevisionModelLinksSelf
 */
export interface RevisionModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RevisionModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RevisionModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RevisionModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RevisionModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RevisionModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RevisionModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RevisionModelLinksShowRevision
 */
export interface RevisionModelLinksShowRevision {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RevisionModelLinksShowRevision
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RevisionModelLinksShowRevision
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RevisionModelLinksShowRevision
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RevisionModelLinksShowRevision
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RevisionModelLinksShowRevision
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RevisionModelLinksShowRevision
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RevisionModelMessage
 */
export interface RevisionModelMessage {
    /**
     * Indicates the formatting language of the raw text
     * @type {string}
     * @memberof RevisionModelMessage
     */
    'format': RevisionModelMessageFormatEnum;
    /**
     * The raw text, as entered by the user
     * @type {string}
     * @memberof RevisionModelMessage
     */
    'raw'?: string;
    /**
     * The text converted to HTML according to the format
     * @type {string}
     * @memberof RevisionModelMessage
     */
    'html'?: string;
}

export const RevisionModelMessageFormatEnum = {
    Plain: 'plain',
    Markdown: 'markdown',
    Custom: 'custom'
} as const;

export type RevisionModelMessageFormatEnum = typeof RevisionModelMessageFormatEnum[keyof typeof RevisionModelMessageFormatEnum];

/**
 * 
 * @export
 * @interface RoleModel
 */
export interface RoleModel {
    /**
     * Role id
     * @type {number}
     * @memberof RoleModel
     */
    'id'?: number;
    /**
     * Role name
     * @type {string}
     * @memberof RoleModel
     */
    'name': string;
    /**
     * 
     * @type {RoleModelLinks}
     * @memberof RoleModel
     */
    '_links'?: RoleModelLinks;
}
/**
 * 
 * @export
 * @interface RoleModelLinks
 */
export interface RoleModelLinks {
    /**
     * 
     * @type {RoleModelLinksSelf}
     * @memberof RoleModelLinks
     */
    'self': RoleModelLinksSelf;
}
/**
 * 
 * @export
 * @interface RoleModelLinksSelf
 */
export interface RoleModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RoleModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RoleModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RoleModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RoleModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RoleModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RoleModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RootModel
 */
export interface RootModel {
    /**
     * 
     * @type {string}
     * @memberof RootModel
     */
    '_type': RootModelTypeEnum;
    /**
     * The name of the OpenProject instance
     * @type {string}
     * @memberof RootModel
     */
    'instanceName': string;
    /**
     * The OpenProject core version number for the instance  # Conditions  **Permission** requires admin privileges
     * @type {string}
     * @memberof RootModel
     */
    'coreVersion'?: string;
    /**
     * 
     * @type {RootModelLinks}
     * @memberof RootModel
     */
    '_links': RootModelLinks;
}

export const RootModelTypeEnum = {
    Root: 'Root'
} as const;

export type RootModelTypeEnum = typeof RootModelTypeEnum[keyof typeof RootModelTypeEnum];

/**
 * 
 * @export
 * @interface RootModelLinks
 */
export interface RootModelLinks {
    /**
     * 
     * @type {RootModelLinksSelf}
     * @memberof RootModelLinks
     */
    'self': RootModelLinksSelf;
    /**
     * 
     * @type {RootModelLinksConfiguration}
     * @memberof RootModelLinks
     */
    'configuration': RootModelLinksConfiguration;
    /**
     * 
     * @type {RootModelLinksMemberships}
     * @memberof RootModelLinks
     */
    'memberships': RootModelLinksMemberships;
    /**
     * 
     * @type {RootModelLinksPriorities}
     * @memberof RootModelLinks
     */
    'priorities': RootModelLinksPriorities;
    /**
     * 
     * @type {RootModelLinksRelations}
     * @memberof RootModelLinks
     */
    'relations': RootModelLinksRelations;
    /**
     * 
     * @type {RootModelLinksStatuses}
     * @memberof RootModelLinks
     */
    'statuses': RootModelLinksStatuses;
    /**
     * 
     * @type {RootModelLinksTimeEntries}
     * @memberof RootModelLinks
     */
    'time_entries': RootModelLinksTimeEntries;
    /**
     * 
     * @type {RootModelLinksTypes}
     * @memberof RootModelLinks
     */
    'types': RootModelLinksTypes;
    /**
     * 
     * @type {RootModelLinksUser}
     * @memberof RootModelLinks
     */
    'user': RootModelLinksUser;
    /**
     * 
     * @type {RootModelLinksUserPreferences}
     * @memberof RootModelLinks
     */
    'userPreferences': RootModelLinksUserPreferences;
    /**
     * 
     * @type {RootModelLinksWorkPackages}
     * @memberof RootModelLinks
     */
    'workPackages': RootModelLinksWorkPackages;
}
/**
 * 
 * @export
 * @interface RootModelLinksConfiguration
 */
export interface RootModelLinksConfiguration {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RootModelLinksConfiguration
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RootModelLinksConfiguration
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RootModelLinksConfiguration
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RootModelLinksConfiguration
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RootModelLinksConfiguration
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RootModelLinksConfiguration
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RootModelLinksMemberships
 */
export interface RootModelLinksMemberships {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RootModelLinksMemberships
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RootModelLinksMemberships
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RootModelLinksMemberships
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RootModelLinksMemberships
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RootModelLinksMemberships
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RootModelLinksMemberships
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RootModelLinksPriorities
 */
export interface RootModelLinksPriorities {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RootModelLinksPriorities
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RootModelLinksPriorities
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RootModelLinksPriorities
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RootModelLinksPriorities
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RootModelLinksPriorities
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RootModelLinksPriorities
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RootModelLinksRelations
 */
export interface RootModelLinksRelations {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RootModelLinksRelations
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RootModelLinksRelations
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RootModelLinksRelations
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RootModelLinksRelations
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RootModelLinksRelations
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RootModelLinksRelations
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RootModelLinksSelf
 */
export interface RootModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RootModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RootModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RootModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RootModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RootModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RootModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RootModelLinksStatuses
 */
export interface RootModelLinksStatuses {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RootModelLinksStatuses
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RootModelLinksStatuses
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RootModelLinksStatuses
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RootModelLinksStatuses
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RootModelLinksStatuses
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RootModelLinksStatuses
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RootModelLinksTimeEntries
 */
export interface RootModelLinksTimeEntries {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RootModelLinksTimeEntries
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RootModelLinksTimeEntries
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RootModelLinksTimeEntries
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RootModelLinksTimeEntries
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RootModelLinksTimeEntries
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RootModelLinksTimeEntries
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RootModelLinksTypes
 */
export interface RootModelLinksTypes {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RootModelLinksTypes
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RootModelLinksTypes
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RootModelLinksTypes
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RootModelLinksTypes
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RootModelLinksTypes
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RootModelLinksTypes
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RootModelLinksUser
 */
export interface RootModelLinksUser {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RootModelLinksUser
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RootModelLinksUser
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RootModelLinksUser
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RootModelLinksUser
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RootModelLinksUser
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RootModelLinksUser
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RootModelLinksUserPreferences
 */
export interface RootModelLinksUserPreferences {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RootModelLinksUserPreferences
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RootModelLinksUserPreferences
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RootModelLinksUserPreferences
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RootModelLinksUserPreferences
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RootModelLinksUserPreferences
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RootModelLinksUserPreferences
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface RootModelLinksWorkPackages
 */
export interface RootModelLinksWorkPackages {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof RootModelLinksWorkPackages
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof RootModelLinksWorkPackages
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof RootModelLinksWorkPackages
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof RootModelLinksWorkPackages
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof RootModelLinksWorkPackages
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof RootModelLinksWorkPackages
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface SchemaModel
 */
export interface SchemaModel {
    /**
     * 
     * @type {string}
     * @memberof SchemaModel
     */
    '_type': SchemaModelTypeEnum;
    /**
     * A list of dependencies between one property\'s value and another property
     * @type {Array<string>}
     * @memberof SchemaModel
     */
    '_dependencies'?: Array<string>;
    /**
     * 
     * @type {SchemaModelLinks}
     * @memberof SchemaModel
     */
    '_links': SchemaModelLinks;
}

export const SchemaModelTypeEnum = {
    Schema: 'Schema'
} as const;

export type SchemaModelTypeEnum = typeof SchemaModelTypeEnum[keyof typeof SchemaModelTypeEnum];

/**
 * 
 * @export
 * @interface SchemaModelLinks
 */
export interface SchemaModelLinks {
    /**
     * 
     * @type {SchemaModelLinksSelf}
     * @memberof SchemaModelLinks
     */
    'self'?: SchemaModelLinksSelf;
}
/**
 * 
 * @export
 * @interface SchemaModelLinksSelf
 */
export interface SchemaModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof SchemaModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof SchemaModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof SchemaModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof SchemaModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof SchemaModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof SchemaModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ShowOrValidateFormRequest
 */
export interface ShowOrValidateFormRequest {
    /**
     * 
     * @type {string}
     * @memberof ShowOrValidateFormRequest
     */
    '_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShowOrValidateFormRequest
     */
    'lockVersion'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShowOrValidateFormRequest
     */
    'subject'?: string;
}
/**
 * 
 * @export
 * @interface StatusModel
 */
export interface StatusModel {
    /**
     * Status id
     * @type {number}
     * @memberof StatusModel
     */
    'id'?: number;
    /**
     * Status name
     * @type {string}
     * @memberof StatusModel
     */
    'name'?: string;
    /**
     * Sort index of the status
     * @type {number}
     * @memberof StatusModel
     */
    'position'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StatusModel
     */
    'isDefault'?: boolean;
    /**
     * are tickets of this status considered closed?
     * @type {boolean}
     * @memberof StatusModel
     */
    'isClosed'?: boolean;
    /**
     * are tickets of this status read only?
     * @type {boolean}
     * @memberof StatusModel
     */
    'isReadonly'?: boolean;
    /**
     * The percentageDone being applied when changing to this status
     * @type {number}
     * @memberof StatusModel
     */
    'defaultDoneRatio'?: number;
    /**
     * 
     * @type {StatusModelLinks}
     * @memberof StatusModel
     */
    '_links'?: StatusModelLinks;
}
/**
 * 
 * @export
 * @interface StatusModelLinks
 */
export interface StatusModelLinks {
    /**
     * 
     * @type {StatusModelLinksSelf}
     * @memberof StatusModelLinks
     */
    'self': StatusModelLinksSelf;
}
/**
 * 
 * @export
 * @interface StatusModelLinksSelf
 */
export interface StatusModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof StatusModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof StatusModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof StatusModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof StatusModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof StatusModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof StatusModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface StorageFileLocationModel
 */
export interface StorageFileLocationModel {
    /**
     * Location identification for file in storage
     * @type {string}
     * @memberof StorageFileLocationModel
     */
    'location': string;
    /**
     * 
     * @type {StorageFileLocationModelLinks}
     * @memberof StorageFileLocationModel
     */
    '_links'?: StorageFileLocationModelLinks;
}
/**
 * 
 * @export
 * @interface StorageFileLocationModelLinks
 */
export interface StorageFileLocationModelLinks {
    /**
     * 
     * @type {StorageFileLocationModelLinksSelf}
     * @memberof StorageFileLocationModelLinks
     */
    'self': StorageFileLocationModelLinksSelf;
}
/**
 * 
 * @export
 * @interface StorageFileLocationModelLinksSelf
 */
export interface StorageFileLocationModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof StorageFileLocationModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof StorageFileLocationModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof StorageFileLocationModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof StorageFileLocationModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof StorageFileLocationModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof StorageFileLocationModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface StorageFileModel
 */
export interface StorageFileModel {
    /**
     * Linked file\'s id on the origin
     * @type {string}
     * @memberof StorageFileModel
     */
    'id': string;
    /**
     * Linked file\'s name on the origin
     * @type {string}
     * @memberof StorageFileModel
     */
    'name': string;
    /**
     * MIME type of the linked file.  To link a folder entity, the custom MIME type `application/x-op-directory` MUST be provided. Otherwise it defaults back to an unknown MIME type.
     * @type {string}
     * @memberof StorageFileModel
     */
    'mimeType'?: string;
    /**
     * file size on origin in bytes
     * @type {number}
     * @memberof StorageFileModel
     */
    'size'?: number;
    /**
     * Timestamp of the creation datetime of the file on the origin
     * @type {string}
     * @memberof StorageFileModel
     */
    'createdAt'?: string;
    /**
     * Timestamp of the datetime of the last modification of the file on the origin
     * @type {string}
     * @memberof StorageFileModel
     */
    'lastModifiedAt'?: string;
    /**
     * Display name of the author that created the file on the origin
     * @type {string}
     * @memberof StorageFileModel
     */
    'createdByName'?: string;
    /**
     * Display name of the author that modified the file on the origin last
     * @type {string}
     * @memberof StorageFileModel
     */
    'lastModifiedByName'?: string;
    /**
     * Location identification for file in storage
     * @type {string}
     * @memberof StorageFileModel
     */
    'location': string;
    /**
     * 
     * @type {StorageFileLocationModelLinks}
     * @memberof StorageFileModel
     */
    '_links'?: StorageFileLocationModelLinks;
}
/**
 * 
 * @export
 * @interface StorageModel
 */
export interface StorageModel {
    /**
     * Storage id
     * @type {number}
     * @memberof StorageModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StorageModel
     */
    '_type': StorageModelTypeEnum;
    /**
     * Storage name
     * @type {string}
     * @memberof StorageModel
     */
    'name': string;
    /**
     * Time of creation
     * @type {string}
     * @memberof StorageModel
     */
    'createdAt'?: string;
    /**
     * Time of the most recent change to the storage
     * @type {string}
     * @memberof StorageModel
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {StorageModelLinks}
     * @memberof StorageModel
     */
    '_links': StorageModelLinks;
}

export const StorageModelTypeEnum = {
    Storage: 'Storage'
} as const;

export type StorageModelTypeEnum = typeof StorageModelTypeEnum[keyof typeof StorageModelTypeEnum];

/**
 * 
 * @export
 * @interface StorageModelLinks
 */
export interface StorageModelLinks {
    /**
     * 
     * @type {StorageModelLinksSelf}
     * @memberof StorageModelLinks
     */
    'self': StorageModelLinksSelf;
    /**
     * 
     * @type {StorageModelLinksType}
     * @memberof StorageModelLinks
     */
    'type': StorageModelLinksType;
    /**
     * 
     * @type {StorageModelLinksOrigin}
     * @memberof StorageModelLinks
     */
    'origin': StorageModelLinksOrigin;
    /**
     * 
     * @type {StorageModelLinksOpen}
     * @memberof StorageModelLinks
     */
    'open': StorageModelLinksOpen;
    /**
     * 
     * @type {StorageModelLinksAuthorizationState}
     * @memberof StorageModelLinks
     */
    'authorizationState': StorageModelLinksAuthorizationState;
    /**
     * 
     * @type {StorageModelLinksAuthorize}
     * @memberof StorageModelLinks
     */
    'authorize'?: StorageModelLinksAuthorize;
}
/**
 * 
 * @export
 * @interface StorageModelLinksAuthorizationState
 */
export interface StorageModelLinksAuthorizationState {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof StorageModelLinksAuthorizationState
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof StorageModelLinksAuthorizationState
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof StorageModelLinksAuthorizationState
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof StorageModelLinksAuthorizationState
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof StorageModelLinksAuthorizationState
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof StorageModelLinksAuthorizationState
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface StorageModelLinksAuthorize
 */
export interface StorageModelLinksAuthorize {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof StorageModelLinksAuthorize
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof StorageModelLinksAuthorize
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof StorageModelLinksAuthorize
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof StorageModelLinksAuthorize
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof StorageModelLinksAuthorize
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof StorageModelLinksAuthorize
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface StorageModelLinksOpen
 */
export interface StorageModelLinksOpen {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof StorageModelLinksOpen
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof StorageModelLinksOpen
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof StorageModelLinksOpen
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof StorageModelLinksOpen
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof StorageModelLinksOpen
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof StorageModelLinksOpen
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface StorageModelLinksOrigin
 */
export interface StorageModelLinksOrigin {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof StorageModelLinksOrigin
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof StorageModelLinksOrigin
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof StorageModelLinksOrigin
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof StorageModelLinksOrigin
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof StorageModelLinksOrigin
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof StorageModelLinksOrigin
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface StorageModelLinksSelf
 */
export interface StorageModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof StorageModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof StorageModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof StorageModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof StorageModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof StorageModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof StorageModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface StorageModelLinksType
 */
export interface StorageModelLinksType {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof StorageModelLinksType
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof StorageModelLinksType
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof StorageModelLinksType
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof StorageModelLinksType
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof StorageModelLinksType
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof StorageModelLinksType
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface TimeEntryActivityModel
 */
export interface TimeEntryActivityModel {
    /**
     * Time entries\' id
     * @type {number}
     * @memberof TimeEntryActivityModel
     */
    'id'?: number;
    /**
     * The human readable name chosen for this activity
     * @type {string}
     * @memberof TimeEntryActivityModel
     */
    'name'?: string;
    /**
     * The rank the activity has in a list of activities
     * @type {string}
     * @memberof TimeEntryActivityModel
     */
    'position'?: string;
    /**
     * Flag to signal whether this activity is the default activity
     * @type {boolean}
     * @memberof TimeEntryActivityModel
     */
    'default'?: boolean;
    /**
     * 
     * @type {TimeEntryActivityModelLinks}
     * @memberof TimeEntryActivityModel
     */
    '_links'?: TimeEntryActivityModelLinks;
}
/**
 * 
 * @export
 * @interface TimeEntryActivityModelLinks
 */
export interface TimeEntryActivityModelLinks {
    /**
     * 
     * @type {TimeEntryActivityModelLinksSelf}
     * @memberof TimeEntryActivityModelLinks
     */
    'self': TimeEntryActivityModelLinksSelf;
    /**
     * 
     * @type {TimeEntryActivityModelLinksProjects}
     * @memberof TimeEntryActivityModelLinks
     */
    'projects': TimeEntryActivityModelLinksProjects;
}
/**
 * 
 * @export
 * @interface TimeEntryActivityModelLinksProjects
 */
export interface TimeEntryActivityModelLinksProjects {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof TimeEntryActivityModelLinksProjects
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof TimeEntryActivityModelLinksProjects
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof TimeEntryActivityModelLinksProjects
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof TimeEntryActivityModelLinksProjects
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof TimeEntryActivityModelLinksProjects
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof TimeEntryActivityModelLinksProjects
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface TimeEntryActivityModelLinksSelf
 */
export interface TimeEntryActivityModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof TimeEntryActivityModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof TimeEntryActivityModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof TimeEntryActivityModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof TimeEntryActivityModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof TimeEntryActivityModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof TimeEntryActivityModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface TimeEntryModel
 */
export interface TimeEntryModel {
    /**
     * Time entries\' id
     * @type {number}
     * @memberof TimeEntryModel
     */
    'id'?: number;
    /**
     * A text provided by the user detailing the time entry
     * @type {string}
     * @memberof TimeEntryModel
     */
    'comment'?: string;
    /**
     * The date the expenditure is booked for
     * @type {string}
     * @memberof TimeEntryModel
     */
    'spentOn'?: string;
    /**
     * The time quantifying the expenditure
     * @type {string}
     * @memberof TimeEntryModel
     */
    'hours'?: string;
    /**
     * The time the time entry was created
     * @type {string}
     * @memberof TimeEntryModel
     */
    'createdAt'?: string;
    /**
     * The time the time entry was last updated
     * @type {string}
     * @memberof TimeEntryModel
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {TimeEntryModelLinks}
     * @memberof TimeEntryModel
     */
    '_links'?: TimeEntryModelLinks;
}
/**
 * 
 * @export
 * @interface TimeEntryModelLinks
 */
export interface TimeEntryModelLinks {
    /**
     * 
     * @type {TimeEntryModelLinksUpdateImmediately}
     * @memberof TimeEntryModelLinks
     */
    'updateImmediately'?: TimeEntryModelLinksUpdateImmediately;
    /**
     * 
     * @type {TimeEntryModelLinksUpdate}
     * @memberof TimeEntryModelLinks
     */
    'update'?: TimeEntryModelLinksUpdate;
    /**
     * 
     * @type {TimeEntryModelLinksDelete}
     * @memberof TimeEntryModelLinks
     */
    'delete'?: TimeEntryModelLinksDelete;
    /**
     * 
     * @type {TimeEntryModelLinksSelf}
     * @memberof TimeEntryModelLinks
     */
    'self': TimeEntryModelLinksSelf;
    /**
     * 
     * @type {TimeEntryModelLinksProject}
     * @memberof TimeEntryModelLinks
     */
    'project': TimeEntryModelLinksProject;
    /**
     * 
     * @type {TimeEntryModelLinksWorkPackage}
     * @memberof TimeEntryModelLinks
     */
    'workPackage'?: TimeEntryModelLinksWorkPackage;
    /**
     * 
     * @type {TimeEntryModelLinksUser}
     * @memberof TimeEntryModelLinks
     */
    'user': TimeEntryModelLinksUser;
    /**
     * 
     * @type {TimeEntryModelLinksActivity}
     * @memberof TimeEntryModelLinks
     */
    'activity': TimeEntryModelLinksActivity;
}
/**
 * 
 * @export
 * @interface TimeEntryModelLinksActivity
 */
export interface TimeEntryModelLinksActivity {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof TimeEntryModelLinksActivity
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof TimeEntryModelLinksActivity
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof TimeEntryModelLinksActivity
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof TimeEntryModelLinksActivity
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof TimeEntryModelLinksActivity
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof TimeEntryModelLinksActivity
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface TimeEntryModelLinksDelete
 */
export interface TimeEntryModelLinksDelete {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof TimeEntryModelLinksDelete
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof TimeEntryModelLinksDelete
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof TimeEntryModelLinksDelete
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof TimeEntryModelLinksDelete
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof TimeEntryModelLinksDelete
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof TimeEntryModelLinksDelete
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface TimeEntryModelLinksProject
 */
export interface TimeEntryModelLinksProject {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof TimeEntryModelLinksProject
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof TimeEntryModelLinksProject
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof TimeEntryModelLinksProject
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof TimeEntryModelLinksProject
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof TimeEntryModelLinksProject
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof TimeEntryModelLinksProject
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface TimeEntryModelLinksSelf
 */
export interface TimeEntryModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof TimeEntryModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof TimeEntryModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof TimeEntryModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof TimeEntryModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof TimeEntryModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof TimeEntryModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface TimeEntryModelLinksUpdate
 */
export interface TimeEntryModelLinksUpdate {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof TimeEntryModelLinksUpdate
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof TimeEntryModelLinksUpdate
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof TimeEntryModelLinksUpdate
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof TimeEntryModelLinksUpdate
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof TimeEntryModelLinksUpdate
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof TimeEntryModelLinksUpdate
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface TimeEntryModelLinksUpdateImmediately
 */
export interface TimeEntryModelLinksUpdateImmediately {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof TimeEntryModelLinksUpdateImmediately
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof TimeEntryModelLinksUpdateImmediately
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof TimeEntryModelLinksUpdateImmediately
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof TimeEntryModelLinksUpdateImmediately
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof TimeEntryModelLinksUpdateImmediately
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof TimeEntryModelLinksUpdateImmediately
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface TimeEntryModelLinksUser
 */
export interface TimeEntryModelLinksUser {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof TimeEntryModelLinksUser
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof TimeEntryModelLinksUser
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof TimeEntryModelLinksUser
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof TimeEntryModelLinksUser
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof TimeEntryModelLinksUser
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof TimeEntryModelLinksUser
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface TimeEntryModelLinksWorkPackage
 */
export interface TimeEntryModelLinksWorkPackage {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof TimeEntryModelLinksWorkPackage
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof TimeEntryModelLinksWorkPackage
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof TimeEntryModelLinksWorkPackage
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof TimeEntryModelLinksWorkPackage
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof TimeEntryModelLinksWorkPackage
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof TimeEntryModelLinksWorkPackage
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface TypeModel
 */
export interface TypeModel {
    /**
     * Type id
     * @type {number}
     * @memberof TypeModel
     */
    'id'?: number;
    /**
     * Type name
     * @type {string}
     * @memberof TypeModel
     */
    'name'?: string;
    /**
     * The color used to represent this type
     * @type {string}
     * @memberof TypeModel
     */
    'color'?: string;
    /**
     * Sort index of the type
     * @type {number}
     * @memberof TypeModel
     */
    'position'?: number;
    /**
     * Is this type active by default in new projects?
     * @type {boolean}
     * @memberof TypeModel
     */
    'isDefault'?: boolean;
    /**
     * Do work packages of this type represent a milestone?
     * @type {boolean}
     * @memberof TypeModel
     */
    'isMilestone'?: boolean;
    /**
     * Time of creation
     * @type {string}
     * @memberof TypeModel
     */
    'createdAt'?: string;
    /**
     * Time of the most recent change to the user
     * @type {string}
     * @memberof TypeModel
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {TypeModelLinks}
     * @memberof TypeModel
     */
    '_links'?: TypeModelLinks;
}
/**
 * 
 * @export
 * @interface TypeModelLinks
 */
export interface TypeModelLinks {
    /**
     * 
     * @type {TypeModelLinksSelf}
     * @memberof TypeModelLinks
     */
    'self': TypeModelLinksSelf;
}
/**
 * 
 * @export
 * @interface TypeModelLinksSelf
 */
export interface TypeModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof TypeModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof TypeModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof TypeModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof TypeModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof TypeModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof TypeModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface UpdateActivityRequest
 */
export interface UpdateActivityRequest {
    /**
     * 
     * @type {UpdateActivityRequestComment}
     * @memberof UpdateActivityRequest
     */
    'comment'?: UpdateActivityRequestComment;
}
/**
 * 
 * @export
 * @interface UpdateActivityRequestComment
 */
export interface UpdateActivityRequestComment {
    /**
     * 
     * @type {string}
     * @memberof UpdateActivityRequestComment
     */
    'raw'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserPreferencesRequest
 */
export interface UpdateUserPreferencesRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserPreferencesRequest
     */
    'autoHidePopups'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPreferencesRequest
     */
    'timeZone'?: string;
}
/**
 * 
 * @export
 * @interface UserCollectionModel
 */
export interface UserCollectionModel {
    /**
     * The total amount of elements available in the collection
     * @type {number}
     * @memberof UserCollectionModel
     */
    'total'?: number;
    /**
     * Amount of elements that a response will hold
     * @type {number}
     * @memberof UserCollectionModel
     */
    'pageSize'?: number;
    /**
     * Actual amount of elements in this response
     * @type {number}
     * @memberof UserCollectionModel
     */
    'count'?: number;
    /**
     * The page number that is requested from paginated collection
     * @type {number}
     * @memberof UserCollectionModel
     */
    'offset'?: number;
    /**
     * Summarized information about aggregation groups
     * @type {object}
     * @memberof UserCollectionModel
     */
    'groups'?: object;
    /**
     * Aggregations of supported values for elements of the collection
     * @type {object}
     * @memberof UserCollectionModel
     */
    'totalSums'?: object;
    /**
     * 
     * @type {UserCollectionModelAllOfLinks}
     * @memberof UserCollectionModel
     */
    '_links': UserCollectionModelAllOfLinks;
    /**
     * 
     * @type {UserCollectionModelAllOfEmbedded}
     * @memberof UserCollectionModel
     */
    '_embedded': UserCollectionModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface UserCollectionModelAllOf
 */
export interface UserCollectionModelAllOf {
    /**
     * 
     * @type {UserCollectionModelAllOfLinks}
     * @memberof UserCollectionModelAllOf
     */
    '_links': UserCollectionModelAllOfLinks;
    /**
     * 
     * @type {UserCollectionModelAllOfEmbedded}
     * @memberof UserCollectionModelAllOf
     */
    '_embedded': UserCollectionModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface UserCollectionModelAllOfEmbedded
 */
export interface UserCollectionModelAllOfEmbedded {
    /**
     * 
     * @type {Array<UserModel>}
     * @memberof UserCollectionModelAllOfEmbedded
     */
    'elements': Array<UserModel>;
}
/**
 * 
 * @export
 * @interface UserCollectionModelAllOfLinks
 */
export interface UserCollectionModelAllOfLinks {
    /**
     * 
     * @type {Link}
     * @memberof UserCollectionModelAllOfLinks
     */
    'self': Link;
}
/**
 * 
 * @export
 * @interface UserCreateModel
 */
export interface UserCreateModel {
    /**
     * 
     * @type {boolean}
     * @memberof UserCreateModel
     */
    'admin': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCreateModel
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateModel
     */
    'login': string;
    /**
     * The users password.  *Conditions:*  Only writable on creation, not on update.
     * @type {string}
     * @memberof UserCreateModel
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateModel
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateModel
     */
    'lastName': string;
    /**
     * The current activation status of the user.  *Conditions:*  Only writable on creation, not on update.
     * @type {string}
     * @memberof UserCreateModel
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateModel
     */
    'language': string;
}
/**
 * 
 * @export
 * @interface UserModel
 */
export interface UserModel {
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    '_type': UserModelTypeEnum;
    /**
     * User\'s id
     * @type {number}
     * @memberof UserModel
     */
    'id': number;
    /**
     * User\'s login name  # Conditions  **Permission**: Administrator, manage_user global permission
     * @type {string}
     * @memberof UserModel
     */
    'login'?: string;
    /**
     * User\'s first name  # Conditions  **Permission**: Administrator, manage_user global permission
     * @type {string}
     * @memberof UserModel
     */
    'firstName'?: string;
    /**
     * User\'s last name  # Conditions  **Permission**: Administrator, manage_user global permission
     * @type {string}
     * @memberof UserModel
     */
    'lastName'?: string;
    /**
     * User\'s full name, formatting depends on instance settings
     * @type {string}
     * @memberof UserModel
     */
    'name': string;
    /**
     * User\'s email address  # Conditions  E-Mail address not hidden, **Permission**: Administrator, manage_user global permission
     * @type {string}
     * @memberof UserModel
     */
    'email'?: string;
    /**
     * Flag indicating whether or not the user is an admin  # Conditions  **Permission**: Administrator
     * @type {boolean}
     * @memberof UserModel
     */
    'admin'?: boolean;
    /**
     * URL to user\'s avatar
     * @type {string}
     * @memberof UserModel
     */
    'avatar': string;
    /**
     * The current activation status of the user (see below)
     * @type {string}
     * @memberof UserModel
     */
    'status'?: string;
    /**
     * User\'s language | ISO 639-1 format  # Conditions  **Permission**: Administrator, manage_user global permission
     * @type {string}
     * @memberof UserModel
     */
    'language'?: string;
    /**
     * User\'s identity_url for OmniAuth authentication  # Conditions  **Permission**: Administrator
     * @type {string}
     * @memberof UserModel
     */
    'identityUrl'?: string | null;
    /**
     * Time of creation
     * @type {string}
     * @memberof UserModel
     */
    'createdAt'?: string;
    /**
     * Time of the most recent change to the user
     * @type {string}
     * @memberof UserModel
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {UserModelLinks}
     * @memberof UserModel
     */
    '_links': UserModelLinks;
}

export const UserModelTypeEnum = {
    User: 'User'
} as const;

export type UserModelTypeEnum = typeof UserModelTypeEnum[keyof typeof UserModelTypeEnum];

/**
 * 
 * @export
 * @interface UserModelLinks
 */
export interface UserModelLinks {
    /**
     * 
     * @type {UserModelLinksSelf}
     * @memberof UserModelLinks
     */
    'self': UserModelLinksSelf;
    /**
     * 
     * @type {UserModelLinksMemberships}
     * @memberof UserModelLinks
     */
    'memberships': UserModelLinksMemberships;
    /**
     * 
     * @type {UserModelLinksShowUser}
     * @memberof UserModelLinks
     */
    'showUser': UserModelLinksShowUser;
    /**
     * 
     * @type {UserModelLinksUpdateImmediately}
     * @memberof UserModelLinks
     */
    'updateImmediately'?: UserModelLinksUpdateImmediately;
    /**
     * 
     * @type {UserModelLinksLock}
     * @memberof UserModelLinks
     */
    'lock'?: UserModelLinksLock;
    /**
     * 
     * @type {UserModelLinksUnlock}
     * @memberof UserModelLinks
     */
    'unlock'?: UserModelLinksUnlock;
    /**
     * 
     * @type {UserModelLinksDelete}
     * @memberof UserModelLinks
     */
    'delete'?: UserModelLinksDelete;
}
/**
 * 
 * @export
 * @interface UserModelLinksDelete
 */
export interface UserModelLinksDelete {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof UserModelLinksDelete
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof UserModelLinksDelete
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof UserModelLinksDelete
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof UserModelLinksDelete
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof UserModelLinksDelete
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof UserModelLinksDelete
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface UserModelLinksLock
 */
export interface UserModelLinksLock {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof UserModelLinksLock
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof UserModelLinksLock
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof UserModelLinksLock
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof UserModelLinksLock
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof UserModelLinksLock
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof UserModelLinksLock
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface UserModelLinksMemberships
 */
export interface UserModelLinksMemberships {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof UserModelLinksMemberships
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof UserModelLinksMemberships
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof UserModelLinksMemberships
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof UserModelLinksMemberships
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof UserModelLinksMemberships
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof UserModelLinksMemberships
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface UserModelLinksSelf
 */
export interface UserModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof UserModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof UserModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof UserModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof UserModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof UserModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof UserModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface UserModelLinksShowUser
 */
export interface UserModelLinksShowUser {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof UserModelLinksShowUser
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof UserModelLinksShowUser
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof UserModelLinksShowUser
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof UserModelLinksShowUser
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof UserModelLinksShowUser
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof UserModelLinksShowUser
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface UserModelLinksUnlock
 */
export interface UserModelLinksUnlock {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof UserModelLinksUnlock
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof UserModelLinksUnlock
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof UserModelLinksUnlock
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof UserModelLinksUnlock
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof UserModelLinksUnlock
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof UserModelLinksUnlock
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface UserModelLinksUpdateImmediately
 */
export interface UserModelLinksUpdateImmediately {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof UserModelLinksUpdateImmediately
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof UserModelLinksUpdateImmediately
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof UserModelLinksUpdateImmediately
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof UserModelLinksUpdateImmediately
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof UserModelLinksUpdateImmediately
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof UserModelLinksUpdateImmediately
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface UserPreferenceModel
 */
export interface UserPreferenceModel {
    /**
     * Whether to hide popups (e.g. success messages) after 5 seconds
     * @type {boolean}
     * @memberof UserPreferenceModel
     */
    'autoHidePopups'?: boolean;
    /**
     * Hide mail address from other users
     * @type {boolean}
     * @memberof UserPreferenceModel
     */
    'hideMail'?: boolean;
    /**
     * The settings for the notifications to be received by the user
     * @type {Array<NotificationSettingsModelInner>}
     * @memberof UserPreferenceModel
     */
    'notifications'?: Array<NotificationSettingsModelInner>;
    /**
     * Current selected time zone
     * @type {string}
     * @memberof UserPreferenceModel
     */
    'timeZone'?: string;
    /**
     * Sort comments in descending order
     * @type {boolean}
     * @memberof UserPreferenceModel
     */
    'commentSortDescending'?: boolean;
    /**
     * Issue warning when leaving a page with unsaved text
     * @type {boolean}
     * @memberof UserPreferenceModel
     */
    'warnOnLeavingUnsaved'?: boolean;
    /**
     * 
     * @type {UserPreferenceModelLinks}
     * @memberof UserPreferenceModel
     */
    '_links'?: UserPreferenceModelLinks;
}
/**
 * 
 * @export
 * @interface UserPreferenceModelLinks
 */
export interface UserPreferenceModelLinks {
    /**
     * 
     * @type {UserPreferenceModelLinksSelf}
     * @memberof UserPreferenceModelLinks
     */
    'self': UserPreferenceModelLinksSelf;
    /**
     * 
     * @type {UserPreferenceModelLinksUser}
     * @memberof UserPreferenceModelLinks
     */
    'user': UserPreferenceModelLinksUser;
}
/**
 * 
 * @export
 * @interface UserPreferenceModelLinksSelf
 */
export interface UserPreferenceModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof UserPreferenceModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof UserPreferenceModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof UserPreferenceModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof UserPreferenceModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof UserPreferenceModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof UserPreferenceModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface UserPreferenceModelLinksUser
 */
export interface UserPreferenceModelLinksUser {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof UserPreferenceModelLinksUser
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof UserPreferenceModelLinksUser
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof UserPreferenceModelLinksUser
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof UserPreferenceModelLinksUser
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof UserPreferenceModelLinksUser
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof UserPreferenceModelLinksUser
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ValuesPropertyModel
 */
export interface ValuesPropertyModel {
    /**
     * 
     * @type {string}
     * @memberof ValuesPropertyModel
     */
    '_type': ValuesPropertyModelTypeEnum;
    /**
     * The key of the key - value pair represented by the Values::Property
     * @type {string}
     * @memberof ValuesPropertyModel
     */
    'property': string;
    /**
     * The value of the key - value pair represented by the Values::Property
     * @type {string}
     * @memberof ValuesPropertyModel
     */
    'value': string;
    /**
     * 
     * @type {ValuesPropertyModelLinks}
     * @memberof ValuesPropertyModel
     */
    '_links': ValuesPropertyModelLinks;
}

export const ValuesPropertyModelTypeEnum = {
    ValuesProperty: 'Values::Property'
} as const;

export type ValuesPropertyModelTypeEnum = typeof ValuesPropertyModelTypeEnum[keyof typeof ValuesPropertyModelTypeEnum];

/**
 * 
 * @export
 * @interface ValuesPropertyModelLinks
 */
export interface ValuesPropertyModelLinks {
    /**
     * 
     * @type {ValuesPropertyModelLinksSelf}
     * @memberof ValuesPropertyModelLinks
     */
    'self': ValuesPropertyModelLinksSelf;
    /**
     * 
     * @type {ValuesPropertyModelLinksSchema}
     * @memberof ValuesPropertyModelLinks
     */
    'schema': ValuesPropertyModelLinksSchema;
}
/**
 * 
 * @export
 * @interface ValuesPropertyModelLinksSchema
 */
export interface ValuesPropertyModelLinksSchema {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ValuesPropertyModelLinksSchema
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ValuesPropertyModelLinksSchema
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ValuesPropertyModelLinksSchema
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ValuesPropertyModelLinksSchema
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ValuesPropertyModelLinksSchema
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ValuesPropertyModelLinksSchema
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface ValuesPropertyModelLinksSelf
 */
export interface ValuesPropertyModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof ValuesPropertyModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof ValuesPropertyModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof ValuesPropertyModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof ValuesPropertyModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof ValuesPropertyModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof ValuesPropertyModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface VersionModel
 */
export interface VersionModel {
    /**
     * Version id
     * @type {number}
     * @memberof VersionModel
     */
    'id'?: number;
    /**
     * Version name
     * @type {string}
     * @memberof VersionModel
     */
    'name': string;
    /**
     * 
     * @type {ActivityModelComment}
     * @memberof VersionModel
     */
    'description'?: ActivityModelComment;
    /**
     * 
     * @type {string}
     * @memberof VersionModel
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionModel
     */
    'endDate'?: string;
    /**
     * The current status of the version
     * @type {string}
     * @memberof VersionModel
     */
    'status': string;
    /**
     * The current status of the version
     * @type {string}
     * @memberof VersionModel
     */
    'sharing': string;
    /**
     * Time of creation
     * @type {string}
     * @memberof VersionModel
     */
    'createdAt': string;
    /**
     * Time of the most recent change to the version
     * @type {string}
     * @memberof VersionModel
     */
    'updatedAt': string;
    /**
     * 
     * @type {VersionModelLinks}
     * @memberof VersionModel
     */
    '_links'?: VersionModelLinks;
}
/**
 * 
 * @export
 * @interface VersionModelLinks
 */
export interface VersionModelLinks {
    /**
     * 
     * @type {VersionModelLinksUpdate}
     * @memberof VersionModelLinks
     */
    'update'?: VersionModelLinksUpdate;
    /**
     * 
     * @type {VersionModelLinksUpdateImmediately}
     * @memberof VersionModelLinks
     */
    'updateImmediately'?: VersionModelLinksUpdateImmediately;
    /**
     * 
     * @type {VersionModelLinksSelf}
     * @memberof VersionModelLinks
     */
    'self': VersionModelLinksSelf;
    /**
     * 
     * @type {VersionModelLinksDefiningProject}
     * @memberof VersionModelLinks
     */
    'definingProject'?: VersionModelLinksDefiningProject;
    /**
     * 
     * @type {VersionModelLinksAvailableInProjects}
     * @memberof VersionModelLinks
     */
    'availableInProjects': VersionModelLinksAvailableInProjects;
}
/**
 * 
 * @export
 * @interface VersionModelLinksAvailableInProjects
 */
export interface VersionModelLinksAvailableInProjects {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof VersionModelLinksAvailableInProjects
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof VersionModelLinksAvailableInProjects
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof VersionModelLinksAvailableInProjects
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof VersionModelLinksAvailableInProjects
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof VersionModelLinksAvailableInProjects
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof VersionModelLinksAvailableInProjects
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface VersionModelLinksDefiningProject
 */
export interface VersionModelLinksDefiningProject {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof VersionModelLinksDefiningProject
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof VersionModelLinksDefiningProject
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof VersionModelLinksDefiningProject
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof VersionModelLinksDefiningProject
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof VersionModelLinksDefiningProject
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof VersionModelLinksDefiningProject
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface VersionModelLinksSelf
 */
export interface VersionModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof VersionModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof VersionModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof VersionModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof VersionModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof VersionModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof VersionModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface VersionModelLinksUpdate
 */
export interface VersionModelLinksUpdate {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof VersionModelLinksUpdate
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof VersionModelLinksUpdate
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof VersionModelLinksUpdate
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof VersionModelLinksUpdate
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof VersionModelLinksUpdate
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof VersionModelLinksUpdate
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface VersionModelLinksUpdateImmediately
 */
export interface VersionModelLinksUpdateImmediately {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof VersionModelLinksUpdateImmediately
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof VersionModelLinksUpdateImmediately
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof VersionModelLinksUpdateImmediately
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof VersionModelLinksUpdateImmediately
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof VersionModelLinksUpdateImmediately
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof VersionModelLinksUpdateImmediately
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WatchersModel
 */
export interface WatchersModel {
    /**
     * The total amount of elements available in the collection
     * @type {number}
     * @memberof WatchersModel
     */
    'total'?: number;
    /**
     * Amount of elements that a response will hold
     * @type {number}
     * @memberof WatchersModel
     */
    'pageSize'?: number;
    /**
     * Actual amount of elements in this response
     * @type {number}
     * @memberof WatchersModel
     */
    'count'?: number;
    /**
     * The page number that is requested from paginated collection
     * @type {number}
     * @memberof WatchersModel
     */
    'offset'?: number;
    /**
     * Summarized information about aggregation groups
     * @type {object}
     * @memberof WatchersModel
     */
    'groups'?: object;
    /**
     * Aggregations of supported values for elements of the collection
     * @type {object}
     * @memberof WatchersModel
     */
    'totalSums'?: object;
    /**
     * 
     * @type {WatchersModelAllOfLinks}
     * @memberof WatchersModel
     */
    '_links': WatchersModelAllOfLinks;
    /**
     * 
     * @type {WatchersModelAllOfEmbedded}
     * @memberof WatchersModel
     */
    '_embedded': WatchersModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface WatchersModelAllOf
 */
export interface WatchersModelAllOf {
    /**
     * 
     * @type {WatchersModelAllOfLinks}
     * @memberof WatchersModelAllOf
     */
    '_links': WatchersModelAllOfLinks;
    /**
     * 
     * @type {WatchersModelAllOfEmbedded}
     * @memberof WatchersModelAllOf
     */
    '_embedded': WatchersModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface WatchersModelAllOfEmbedded
 */
export interface WatchersModelAllOfEmbedded {
    /**
     * 
     * @type {Array<UserModel>}
     * @memberof WatchersModelAllOfEmbedded
     */
    'elements'?: Array<UserModel>;
}
/**
 * 
 * @export
 * @interface WatchersModelAllOfLinks
 */
export interface WatchersModelAllOfLinks {
    /**
     * 
     * @type {Link}
     * @memberof WatchersModelAllOfLinks
     */
    'self': Link;
}
/**
 * 
 * @export
 * @interface WeekDayCollectionModel
 */
export interface WeekDayCollectionModel {
    /**
     * The total amount of elements available in the collection
     * @type {number}
     * @memberof WeekDayCollectionModel
     */
    'total'?: number;
    /**
     * Amount of elements that a response will hold
     * @type {number}
     * @memberof WeekDayCollectionModel
     */
    'pageSize'?: number;
    /**
     * Actual amount of elements in this response
     * @type {number}
     * @memberof WeekDayCollectionModel
     */
    'count'?: number;
    /**
     * The page number that is requested from paginated collection
     * @type {number}
     * @memberof WeekDayCollectionModel
     */
    'offset'?: number;
    /**
     * Summarized information about aggregation groups
     * @type {object}
     * @memberof WeekDayCollectionModel
     */
    'groups'?: object;
    /**
     * Aggregations of supported values for elements of the collection
     * @type {object}
     * @memberof WeekDayCollectionModel
     */
    'totalSums'?: object;
    /**
     * 
     * @type {WeekDayCollectionModelAllOfLinks}
     * @memberof WeekDayCollectionModel
     */
    '_links': WeekDayCollectionModelAllOfLinks;
    /**
     * 
     * @type {WeekDayCollectionModelAllOfEmbedded}
     * @memberof WeekDayCollectionModel
     */
    '_embedded': WeekDayCollectionModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface WeekDayCollectionModelAllOf
 */
export interface WeekDayCollectionModelAllOf {
    /**
     * 
     * @type {WeekDayCollectionModelAllOfLinks}
     * @memberof WeekDayCollectionModelAllOf
     */
    '_links': WeekDayCollectionModelAllOfLinks;
    /**
     * 
     * @type {WeekDayCollectionModelAllOfEmbedded}
     * @memberof WeekDayCollectionModelAllOf
     */
    '_embedded': WeekDayCollectionModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface WeekDayCollectionModelAllOfEmbedded
 */
export interface WeekDayCollectionModelAllOfEmbedded {
    /**
     * The array of week days.
     * @type {Array<WeekDayModel>}
     * @memberof WeekDayCollectionModelAllOfEmbedded
     */
    'elements': Array<WeekDayModel>;
}
/**
 * 
 * @export
 * @interface WeekDayCollectionModelAllOfLinks
 */
export interface WeekDayCollectionModelAllOfLinks {
    /**
     * 
     * @type {Link}
     * @memberof WeekDayCollectionModelAllOfLinks
     */
    'self': Link;
}
/**
 * 
 * @export
 * @interface WeekDayCollectionWriteModel
 */
export interface WeekDayCollectionWriteModel {
    /**
     * 
     * @type {string}
     * @memberof WeekDayCollectionWriteModel
     */
    '_type': WeekDayCollectionWriteModelTypeEnum;
    /**
     * 
     * @type {WeekDayCollectionWriteModelEmbedded}
     * @memberof WeekDayCollectionWriteModel
     */
    '_embedded': WeekDayCollectionWriteModelEmbedded;
}

export const WeekDayCollectionWriteModelTypeEnum = {
    Collection: 'Collection'
} as const;

export type WeekDayCollectionWriteModelTypeEnum = typeof WeekDayCollectionWriteModelTypeEnum[keyof typeof WeekDayCollectionWriteModelTypeEnum];

/**
 * 
 * @export
 * @interface WeekDayCollectionWriteModelEmbedded
 */
export interface WeekDayCollectionWriteModelEmbedded {
    /**
     * The array of week days.
     * @type {Array<WeekDayCollectionWriteModelEmbeddedElementsInner>}
     * @memberof WeekDayCollectionWriteModelEmbedded
     */
    'elements': Array<WeekDayCollectionWriteModelEmbeddedElementsInner>;
}
/**
 * 
 * @export
 * @interface WeekDayCollectionWriteModelEmbeddedElementsInner
 */
export interface WeekDayCollectionWriteModelEmbeddedElementsInner {
    /**
     * 
     * @type {string}
     * @memberof WeekDayCollectionWriteModelEmbeddedElementsInner
     */
    '_type': WeekDayCollectionWriteModelEmbeddedElementsInnerTypeEnum;
    /**
     * `true` for a working day. `false` for a weekend day.
     * @type {boolean}
     * @memberof WeekDayCollectionWriteModelEmbeddedElementsInner
     */
    'working': boolean;
    /**
     * 
     * @type {WeekDayCollectionWriteModelEmbeddedElementsInnerAllOfLinks}
     * @memberof WeekDayCollectionWriteModelEmbeddedElementsInner
     */
    '_links': WeekDayCollectionWriteModelEmbeddedElementsInnerAllOfLinks;
}

export const WeekDayCollectionWriteModelEmbeddedElementsInnerTypeEnum = {
    WeekDay: 'WeekDay'
} as const;

export type WeekDayCollectionWriteModelEmbeddedElementsInnerTypeEnum = typeof WeekDayCollectionWriteModelEmbeddedElementsInnerTypeEnum[keyof typeof WeekDayCollectionWriteModelEmbeddedElementsInnerTypeEnum];

/**
 * 
 * @export
 * @interface WeekDayCollectionWriteModelEmbeddedElementsInnerAllOf
 */
export interface WeekDayCollectionWriteModelEmbeddedElementsInnerAllOf {
    /**
     * 
     * @type {WeekDayCollectionWriteModelEmbeddedElementsInnerAllOfLinks}
     * @memberof WeekDayCollectionWriteModelEmbeddedElementsInnerAllOf
     */
    '_links': WeekDayCollectionWriteModelEmbeddedElementsInnerAllOfLinks;
}
/**
 * 
 * @export
 * @interface WeekDayCollectionWriteModelEmbeddedElementsInnerAllOfLinks
 */
export interface WeekDayCollectionWriteModelEmbeddedElementsInnerAllOfLinks {
    /**
     * 
     * @type {WeekDaySelfLinkModelSelf}
     * @memberof WeekDayCollectionWriteModelEmbeddedElementsInnerAllOfLinks
     */
    'self'?: WeekDaySelfLinkModelSelf;
}
/**
 * 
 * @export
 * @interface WeekDayModel
 */
export interface WeekDayModel {
    /**
     * 
     * @type {string}
     * @memberof WeekDayModel
     */
    '_type': WeekDayModelTypeEnum;
    /**
     * The week day from 1 to 7. 1 is Monday. 7 is Sunday.
     * @type {number}
     * @memberof WeekDayModel
     */
    'day': number;
    /**
     * The week day name.
     * @type {string}
     * @memberof WeekDayModel
     */
    'name': string;
    /**
     * `true` for a working week day, `false` otherwise.
     * @type {boolean}
     * @memberof WeekDayModel
     */
    'working': boolean;
    /**
     * 
     * @type {WeekDayCollectionWriteModelEmbeddedElementsInnerAllOfLinks}
     * @memberof WeekDayModel
     */
    '_links'?: WeekDayCollectionWriteModelEmbeddedElementsInnerAllOfLinks;
}

export const WeekDayModelTypeEnum = {
    WeekDay: 'WeekDay'
} as const;

export type WeekDayModelTypeEnum = typeof WeekDayModelTypeEnum[keyof typeof WeekDayModelTypeEnum];

/**
 * Identify a particular week day by its href.
 * @export
 * @interface WeekDaySelfLinkModel
 */
export interface WeekDaySelfLinkModel {
    /**
     * 
     * @type {WeekDaySelfLinkModelSelf}
     * @memberof WeekDaySelfLinkModel
     */
    'self'?: WeekDaySelfLinkModelSelf;
}
/**
 * 
 * @export
 * @interface WeekDaySelfLinkModelSelf
 */
export interface WeekDaySelfLinkModelSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WeekDaySelfLinkModelSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WeekDaySelfLinkModelSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WeekDaySelfLinkModelSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WeekDaySelfLinkModelSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WeekDaySelfLinkModelSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WeekDaySelfLinkModelSelf
     */
    'identifier'?: string;
}
/**
 * Describes a week day as a working day or a non-working day (weekend).
 * @export
 * @interface WeekDayWriteModel
 */
export interface WeekDayWriteModel {
    /**
     * 
     * @type {string}
     * @memberof WeekDayWriteModel
     */
    '_type': WeekDayWriteModelTypeEnum;
    /**
     * `true` for a working day. `false` for a weekend day.
     * @type {boolean}
     * @memberof WeekDayWriteModel
     */
    'working': boolean;
}

export const WeekDayWriteModelTypeEnum = {
    WeekDay: 'WeekDay'
} as const;

export type WeekDayWriteModelTypeEnum = typeof WeekDayWriteModelTypeEnum[keyof typeof WeekDayWriteModelTypeEnum];

/**
 * 
 * @export
 * @interface WikiPageModel
 */
export interface WikiPageModel {
    /**
     * Identifier of this wiki page
     * @type {number}
     * @memberof WikiPageModel
     */
    'id'?: number;
    /**
     * The wiki page\'s title
     * @type {string}
     * @memberof WikiPageModel
     */
    'title': string;
    /**
     * 
     * @type {WikiPageModelLinks}
     * @memberof WikiPageModel
     */
    '_links'?: WikiPageModelLinks;
}
/**
 * 
 * @export
 * @interface WikiPageModelLinks
 */
export interface WikiPageModelLinks {
    /**
     * 
     * @type {WikiPageModelLinksAddAttachment}
     * @memberof WikiPageModelLinks
     */
    'addAttachment'?: WikiPageModelLinksAddAttachment;
}
/**
 * 
 * @export
 * @interface WikiPageModelLinksAddAttachment
 */
export interface WikiPageModelLinksAddAttachment {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WikiPageModelLinksAddAttachment
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WikiPageModelLinksAddAttachment
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WikiPageModelLinksAddAttachment
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WikiPageModelLinksAddAttachment
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WikiPageModelLinksAddAttachment
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WikiPageModelLinksAddAttachment
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModel
 */
export interface WorkPackageModel {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackageModel
     */
    'id'?: number;
    /**
     * The version of the item as used for optimistic locking
     * @type {number}
     * @memberof WorkPackageModel
     */
    'lockVersion'?: number;
    /**
     * Work package subject
     * @type {string}
     * @memberof WorkPackageModel
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof WorkPackageModel
     */
    '_type'?: WorkPackageModelTypeEnum;
    /**
     * 
     * @type {WorkPackageModelDescription}
     * @memberof WorkPackageModel
     */
    'description'?: WorkPackageModelDescription;
    /**
     * If false (default) schedule automatically.
     * @type {boolean}
     * @memberof WorkPackageModel
     */
    'scheduleManually'?: boolean;
    /**
     * If true, the work package is in a readonly status so with the exception of the status, no other property can be altered.
     * @type {boolean}
     * @memberof WorkPackageModel
     */
    'readonly'?: boolean;
    /**
     * Scheduled beginning of a work package
     * @type {string}
     * @memberof WorkPackageModel
     */
    'startDate'?: string;
    /**
     * Scheduled end of a work package
     * @type {string}
     * @memberof WorkPackageModel
     */
    'dueDate'?: string;
    /**
     * Date on which a milestone is achieved
     * @type {string}
     * @memberof WorkPackageModel
     */
    'date'?: string;
    /**
     * Similar to start date but is not set by a client but rather deduced by the work packages\' descendants. If manual scheduleManually is active, the two dates can deviate.
     * @type {string}
     * @memberof WorkPackageModel
     */
    'derivedStartDate'?: string;
    /**
     * Similar to due date but is not set by a client but rather deduced by the work packages\' descendants. If manual scheduleManually is active, the two dates can deviate.
     * @type {string}
     * @memberof WorkPackageModel
     */
    'derivedDueDate'?: string;
    /**
     * **(NOT IMPLEMENTED)** The amount of time in hours the work package needs to be completed. Not available for milestone type of work packages.
     * @type {string}
     * @memberof WorkPackageModel
     */
    'duration'?: string;
    /**
     * Time a work package likely needs to be completed excluding its descendants
     * @type {string}
     * @memberof WorkPackageModel
     */
    'estimatedTime'?: string;
    /**
     * Time a work package likely needs to be completed including its descendants
     * @type {string}
     * @memberof WorkPackageModel
     */
    'derivedEstimatedTime'?: string;
    /**
     * **(NOT IMPLEMENTED)** When scheduling, whether or not to ignore the non working days being defined. A work package with the flag set to true will be allowed to be scheduled to a non working day.
     * @type {boolean}
     * @memberof WorkPackageModel
     */
    'ignoreNonWorkingDays'?: boolean;
    /**
     * The time booked for this work package by users working on it  # Conditions  **Permission** view time entries
     * @type {string}
     * @memberof WorkPackageModel
     */
    'spentTime'?: string;
    /**
     * Amount of total completion for a work package
     * @type {number}
     * @memberof WorkPackageModel
     */
    'percentageDone'?: number;
    /**
     * Time of creation
     * @type {string}
     * @memberof WorkPackageModel
     */
    'createdAt'?: string;
    /**
     * Time of the most recent change to the work package
     * @type {string}
     * @memberof WorkPackageModel
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {WorkPackageModelLinks}
     * @memberof WorkPackageModel
     */
    '_links': WorkPackageModelLinks;
}

export const WorkPackageModelTypeEnum = {
    WorkPackage: 'WorkPackage'
} as const;

export type WorkPackageModelTypeEnum = typeof WorkPackageModelTypeEnum[keyof typeof WorkPackageModelTypeEnum];

/**
 * 
 * @export
 * @interface WorkPackageModelDescription
 */
export interface WorkPackageModelDescription {
    /**
     * Indicates the formatting language of the raw text
     * @type {string}
     * @memberof WorkPackageModelDescription
     */
    'format': WorkPackageModelDescriptionFormatEnum;
    /**
     * The raw text, as entered by the user
     * @type {string}
     * @memberof WorkPackageModelDescription
     */
    'raw'?: string;
    /**
     * The text converted to HTML according to the format
     * @type {string}
     * @memberof WorkPackageModelDescription
     */
    'html'?: string;
}

export const WorkPackageModelDescriptionFormatEnum = {
    Plain: 'plain',
    Markdown: 'markdown',
    Custom: 'custom'
} as const;

export type WorkPackageModelDescriptionFormatEnum = typeof WorkPackageModelDescriptionFormatEnum[keyof typeof WorkPackageModelDescriptionFormatEnum];

/**
 * 
 * @export
 * @interface WorkPackageModelLinks
 */
export interface WorkPackageModelLinks {
    /**
     * 
     * @type {WorkPackageModelLinksAddAttachment}
     * @memberof WorkPackageModelLinks
     */
    'addAttachment'?: WorkPackageModelLinksAddAttachment;
    /**
     * 
     * @type {WorkPackageModelLinksAddComment}
     * @memberof WorkPackageModelLinks
     */
    'addComment'?: WorkPackageModelLinksAddComment;
    /**
     * 
     * @type {WorkPackageModelLinksAddRelation}
     * @memberof WorkPackageModelLinks
     */
    'addRelation'?: WorkPackageModelLinksAddRelation;
    /**
     * 
     * @type {WorkPackageModelLinksAddWatcher}
     * @memberof WorkPackageModelLinks
     */
    'addWatcher'?: WorkPackageModelLinksAddWatcher;
    /**
     * 
     * @type {Array<WorkPackageModelLinksCustomActionsInner>}
     * @memberof WorkPackageModelLinks
     */
    'customActions'?: Array<WorkPackageModelLinksCustomActionsInner>;
    /**
     * 
     * @type {WorkPackageModelLinksPreviewMarkup}
     * @memberof WorkPackageModelLinks
     */
    'previewMarkup'?: WorkPackageModelLinksPreviewMarkup;
    /**
     * 
     * @type {WorkPackageModelLinksRemoveWatcher}
     * @memberof WorkPackageModelLinks
     */
    'removeWatcher'?: WorkPackageModelLinksRemoveWatcher;
    /**
     * 
     * @type {WorkPackageModelLinksUnwatch}
     * @memberof WorkPackageModelLinks
     */
    'unwatch'?: WorkPackageModelLinksUnwatch;
    /**
     * 
     * @type {WorkPackageModelLinksUpdate}
     * @memberof WorkPackageModelLinks
     */
    'update'?: WorkPackageModelLinksUpdate;
    /**
     * 
     * @type {WorkPackageModelLinksUpdateImmediately}
     * @memberof WorkPackageModelLinks
     */
    'updateImmediately'?: WorkPackageModelLinksUpdateImmediately;
    /**
     * 
     * @type {WorkPackageModelLinksWatch}
     * @memberof WorkPackageModelLinks
     */
    'watch'?: WorkPackageModelLinksWatch;
    /**
     * 
     * @type {WorkPackageModelLinksSelf}
     * @memberof WorkPackageModelLinks
     */
    'self': WorkPackageModelLinksSelf;
    /**
     * 
     * @type {WorkPackageModelLinksSchema}
     * @memberof WorkPackageModelLinks
     */
    'schema': WorkPackageModelLinksSchema;
    /**
     * 
     * @type {Array<WorkPackageModelLinksAncestorsInner>}
     * @memberof WorkPackageModelLinks
     */
    'ancestors': Array<WorkPackageModelLinksAncestorsInner>;
    /**
     * 
     * @type {WorkPackageModelLinksAttachments}
     * @memberof WorkPackageModelLinks
     */
    'attachments': WorkPackageModelLinksAttachments;
    /**
     * 
     * @type {WorkPackageModelLinksAuthor}
     * @memberof WorkPackageModelLinks
     */
    'author': WorkPackageModelLinksAuthor;
    /**
     * 
     * @type {WorkPackageModelLinksAssignee}
     * @memberof WorkPackageModelLinks
     */
    'assignee'?: WorkPackageModelLinksAssignee;
    /**
     * 
     * @type {WorkPackageModelLinksAvailableWatchers}
     * @memberof WorkPackageModelLinks
     */
    'availableWatchers'?: WorkPackageModelLinksAvailableWatchers;
    /**
     * 
     * @type {WorkPackageModelLinksBudget}
     * @memberof WorkPackageModelLinks
     */
    'budget'?: WorkPackageModelLinksBudget;
    /**
     * 
     * @type {WorkPackageModelLinksCategory}
     * @memberof WorkPackageModelLinks
     */
    'category'?: WorkPackageModelLinksCategory;
    /**
     * 
     * @type {Array<WorkPackageModelLinksChildrenInner>}
     * @memberof WorkPackageModelLinks
     */
    'children': Array<WorkPackageModelLinksChildrenInner>;
    /**
     * 
     * @type {WorkPackageModelLinksAddFileLink}
     * @memberof WorkPackageModelLinks
     */
    'addFileLink'?: WorkPackageModelLinksAddFileLink;
    /**
     * 
     * @type {WorkPackageModelLinksFileLinks}
     * @memberof WorkPackageModelLinks
     */
    'fileLinks'?: WorkPackageModelLinksFileLinks;
    /**
     * 
     * @type {WorkPackageModelLinksParent}
     * @memberof WorkPackageModelLinks
     */
    'parent'?: WorkPackageModelLinksParent;
    /**
     * 
     * @type {WorkPackageModelLinksPriority}
     * @memberof WorkPackageModelLinks
     */
    'priority': WorkPackageModelLinksPriority;
    /**
     * 
     * @type {WorkPackageModelLinksProject}
     * @memberof WorkPackageModelLinks
     */
    'project': WorkPackageModelLinksProject;
    /**
     * 
     * @type {WorkPackageModelLinksResponsible}
     * @memberof WorkPackageModelLinks
     */
    'responsible'?: WorkPackageModelLinksResponsible;
    /**
     * 
     * @type {WorkPackageModelLinksRelations}
     * @memberof WorkPackageModelLinks
     */
    'relations'?: WorkPackageModelLinksRelations;
    /**
     * 
     * @type {WorkPackageModelLinksRevisions}
     * @memberof WorkPackageModelLinks
     */
    'revisions'?: WorkPackageModelLinksRevisions;
    /**
     * 
     * @type {WorkPackageModelLinksStatus}
     * @memberof WorkPackageModelLinks
     */
    'status': WorkPackageModelLinksStatus;
    /**
     * 
     * @type {WorkPackageModelLinksTimeEntries}
     * @memberof WorkPackageModelLinks
     */
    'timeEntries'?: WorkPackageModelLinksTimeEntries;
    /**
     * 
     * @type {WorkPackageModelLinksType}
     * @memberof WorkPackageModelLinks
     */
    'type': WorkPackageModelLinksType;
    /**
     * 
     * @type {WorkPackageModelLinksVersion}
     * @memberof WorkPackageModelLinks
     */
    'version'?: WorkPackageModelLinksVersion;
    /**
     * 
     * @type {WorkPackageModelLinksWatchers}
     * @memberof WorkPackageModelLinks
     */
    'watchers'?: WorkPackageModelLinksWatchers;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksAddAttachment
 */
export interface WorkPackageModelLinksAddAttachment {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksAddAttachment
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAddAttachment
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksAddAttachment
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAddAttachment
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksAddAttachment
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksAddAttachment
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksAddComment
 */
export interface WorkPackageModelLinksAddComment {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksAddComment
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAddComment
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksAddComment
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAddComment
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksAddComment
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksAddComment
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksAddFileLink
 */
export interface WorkPackageModelLinksAddFileLink {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksAddFileLink
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAddFileLink
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksAddFileLink
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAddFileLink
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksAddFileLink
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksAddFileLink
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksAddRelation
 */
export interface WorkPackageModelLinksAddRelation {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksAddRelation
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAddRelation
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksAddRelation
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAddRelation
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksAddRelation
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksAddRelation
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksAddWatcher
 */
export interface WorkPackageModelLinksAddWatcher {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksAddWatcher
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAddWatcher
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksAddWatcher
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAddWatcher
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksAddWatcher
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksAddWatcher
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksAncestorsInner
 */
export interface WorkPackageModelLinksAncestorsInner {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksAncestorsInner
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAncestorsInner
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksAncestorsInner
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAncestorsInner
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksAncestorsInner
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksAncestorsInner
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksAssignee
 */
export interface WorkPackageModelLinksAssignee {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksAssignee
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAssignee
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksAssignee
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAssignee
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksAssignee
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksAssignee
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksAttachments
 */
export interface WorkPackageModelLinksAttachments {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksAttachments
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAttachments
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksAttachments
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAttachments
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksAttachments
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksAttachments
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksAuthor
 */
export interface WorkPackageModelLinksAuthor {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksAuthor
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAuthor
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksAuthor
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAuthor
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksAuthor
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksAuthor
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksAvailableWatchers
 */
export interface WorkPackageModelLinksAvailableWatchers {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksAvailableWatchers
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAvailableWatchers
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksAvailableWatchers
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksAvailableWatchers
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksAvailableWatchers
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksAvailableWatchers
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksBudget
 */
export interface WorkPackageModelLinksBudget {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksBudget
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksBudget
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksBudget
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksBudget
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksBudget
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksBudget
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksCategory
 */
export interface WorkPackageModelLinksCategory {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksCategory
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksCategory
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksCategory
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksCategory
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksCategory
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksCategory
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksChildrenInner
 */
export interface WorkPackageModelLinksChildrenInner {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksChildrenInner
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksChildrenInner
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksChildrenInner
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksChildrenInner
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksChildrenInner
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksChildrenInner
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksCustomActionsInner
 */
export interface WorkPackageModelLinksCustomActionsInner {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksCustomActionsInner
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksCustomActionsInner
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksCustomActionsInner
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksCustomActionsInner
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksCustomActionsInner
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksCustomActionsInner
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksFileLinks
 */
export interface WorkPackageModelLinksFileLinks {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksFileLinks
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksFileLinks
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksFileLinks
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksFileLinks
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksFileLinks
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksFileLinks
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksParent
 */
export interface WorkPackageModelLinksParent {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksParent
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksParent
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksParent
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksParent
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksParent
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksParent
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksPreviewMarkup
 */
export interface WorkPackageModelLinksPreviewMarkup {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksPreviewMarkup
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksPreviewMarkup
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksPreviewMarkup
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksPreviewMarkup
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksPreviewMarkup
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksPreviewMarkup
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksPriority
 */
export interface WorkPackageModelLinksPriority {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksPriority
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksPriority
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksPriority
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksPriority
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksPriority
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksPriority
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksProject
 */
export interface WorkPackageModelLinksProject {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksProject
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksProject
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksProject
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksProject
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksProject
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksProject
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksRelations
 */
export interface WorkPackageModelLinksRelations {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksRelations
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksRelations
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksRelations
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksRelations
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksRelations
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksRelations
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksRemoveWatcher
 */
export interface WorkPackageModelLinksRemoveWatcher {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksRemoveWatcher
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksRemoveWatcher
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksRemoveWatcher
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksRemoveWatcher
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksRemoveWatcher
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksRemoveWatcher
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksResponsible
 */
export interface WorkPackageModelLinksResponsible {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksResponsible
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksResponsible
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksResponsible
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksResponsible
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksResponsible
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksResponsible
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksRevisions
 */
export interface WorkPackageModelLinksRevisions {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksRevisions
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksRevisions
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksRevisions
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksRevisions
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksRevisions
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksRevisions
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksSchema
 */
export interface WorkPackageModelLinksSchema {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksSchema
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksSchema
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksSchema
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksSchema
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksSchema
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksSchema
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksSelf
 */
export interface WorkPackageModelLinksSelf {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksSelf
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksSelf
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksSelf
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksSelf
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksSelf
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksSelf
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksStatus
 */
export interface WorkPackageModelLinksStatus {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksStatus
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksStatus
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksStatus
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksStatus
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksStatus
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksStatus
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksTimeEntries
 */
export interface WorkPackageModelLinksTimeEntries {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksTimeEntries
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksTimeEntries
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksTimeEntries
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksTimeEntries
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksTimeEntries
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksTimeEntries
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksType
 */
export interface WorkPackageModelLinksType {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksType
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksType
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksType
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksType
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksType
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksType
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksUnwatch
 */
export interface WorkPackageModelLinksUnwatch {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksUnwatch
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksUnwatch
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksUnwatch
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksUnwatch
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksUnwatch
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksUnwatch
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksUpdate
 */
export interface WorkPackageModelLinksUpdate {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksUpdate
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksUpdate
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksUpdate
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksUpdate
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksUpdate
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksUpdate
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksUpdateImmediately
 */
export interface WorkPackageModelLinksUpdateImmediately {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksUpdateImmediately
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksUpdateImmediately
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksUpdateImmediately
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksUpdateImmediately
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksUpdateImmediately
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksUpdateImmediately
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksVersion
 */
export interface WorkPackageModelLinksVersion {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksVersion
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksVersion
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksVersion
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksVersion
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksVersion
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksVersion
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksWatch
 */
export interface WorkPackageModelLinksWatch {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksWatch
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksWatch
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksWatch
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksWatch
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksWatch
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksWatch
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackageModelLinksWatchers
 */
export interface WorkPackageModelLinksWatchers {
    /**
     * URL to the referenced resource (might be relative)
     * @type {string}
     * @memberof WorkPackageModelLinksWatchers
     */
    'href': string | null;
    /**
     *  Representative label for the resource
     * @type {string}
     * @memberof WorkPackageModelLinksWatchers
     */
    'title'?: string;
    /**
     * If true the href contains parts that need to be replaced by the client
     * @type {boolean}
     * @memberof WorkPackageModelLinksWatchers
     */
    'templated'?: boolean;
    /**
     * The HTTP verb to use when requesting the resource
     * @type {string}
     * @memberof WorkPackageModelLinksWatchers
     */
    'method'?: string;
    /**
     * The payload to send in the request to achieve the desired result
     * @type {object}
     * @memberof WorkPackageModelLinksWatchers
     */
    'payload'?: object;
    /**
     *  An optional unique identifier to the link object
     * @type {string}
     * @memberof WorkPackageModelLinksWatchers
     */
    'identifier'?: string;
}
/**
 * 
 * @export
 * @interface WorkPackagesModel
 */
export interface WorkPackagesModel {
    /**
     * The total amount of elements available in the collection
     * @type {number}
     * @memberof WorkPackagesModel
     */
    'total'?: number;
    /**
     * Amount of elements that a response will hold
     * @type {number}
     * @memberof WorkPackagesModel
     */
    'pageSize'?: number;
    /**
     * Actual amount of elements in this response
     * @type {number}
     * @memberof WorkPackagesModel
     */
    'count'?: number;
    /**
     * The page number that is requested from paginated collection
     * @type {number}
     * @memberof WorkPackagesModel
     */
    'offset'?: number;
    /**
     * Summarized information about aggregation groups
     * @type {object}
     * @memberof WorkPackagesModel
     */
    'groups'?: object;
    /**
     * Aggregations of supported values for elements of the collection
     * @type {object}
     * @memberof WorkPackagesModel
     */
    'totalSums'?: object;
    /**
     * 
     * @type {WorkPackagesModelAllOfLinks}
     * @memberof WorkPackagesModel
     */
    '_links': WorkPackagesModelAllOfLinks;
    /**
     * 
     * @type {WorkPackagesModelAllOfEmbedded}
     * @memberof WorkPackagesModel
     */
    '_embedded': WorkPackagesModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface WorkPackagesModelAllOf
 */
export interface WorkPackagesModelAllOf {
    /**
     * 
     * @type {WorkPackagesModelAllOfLinks}
     * @memberof WorkPackagesModelAllOf
     */
    '_links': WorkPackagesModelAllOfLinks;
    /**
     * 
     * @type {WorkPackagesModelAllOfEmbedded}
     * @memberof WorkPackagesModelAllOf
     */
    '_embedded': WorkPackagesModelAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface WorkPackagesModelAllOfEmbedded
 */
export interface WorkPackagesModelAllOfEmbedded {
    /**
     * 
     * @type {Array<WorkPackageModel>}
     * @memberof WorkPackagesModelAllOfEmbedded
     */
    'elements': Array<WorkPackageModel>;
}
/**
 * 
 * @export
 * @interface WorkPackagesModelAllOfLinks
 */
export interface WorkPackagesModelAllOfLinks {
    /**
     * 
     * @type {Link}
     * @memberof WorkPackagesModelAllOfLinks
     */
    'self': Link;
}

/**
 * ActionsCapabilitiesApi - axios parameter creator
 * @export
 */
export const ActionsCapabilitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a collection of actions. The client can choose to filter the actions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain actions, for which the requesting client has sufficient permissions.
         * @summary List actions
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Returns only the action having the id or all actions except those having the id(s).
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + *No sort supported yet*
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActions: async (filters?: string, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a collection of actions assigned to a principal in a context. The client can choose to filter the actions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain actions, for which the requesting client has sufficient permissions
         * @summary List capabilities
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.  + action: Get all capabilities of a certain action  + principal: Get all capabilities of a principal  + context: Get all capabilities within a context. Note that for a project context the client needs to provide &#x60;p{id}&#x60;, e.g. &#x60;p5&#x60; and for the global context a &#x60;g&#x60;
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by the capabilities id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCapabilities: async (filters?: string, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/capabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an individual action.
         * @summary View action
         * @param {string} id action id which is the name of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewAction: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewAction', 'id', id)
            const localVarPath = `/api/v3/actions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View capabilities
         * @param {string} id capability id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewCapabilities: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewCapabilities', 'id', id)
            const localVarPath = `/api/v3/capabilities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the global capability context. This context is necessary to consistently link to a context even if the context is not a project.
         * @summary View global context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewGlobalContext: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/capabilities/context/global`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsCapabilitiesApi - functional programming interface
 * @export
 */
export const ActionsCapabilitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsCapabilitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a collection of actions. The client can choose to filter the actions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain actions, for which the requesting client has sufficient permissions.
         * @summary List actions
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Returns only the action having the id or all actions except those having the id(s).
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + *No sort supported yet*
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActions(filters?: string, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActions(filters, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a collection of actions assigned to a principal in a context. The client can choose to filter the actions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain actions, for which the requesting client has sufficient permissions
         * @summary List capabilities
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.  + action: Get all capabilities of a certain action  + principal: Get all capabilities of a principal  + context: Get all capabilities within a context. Note that for a project context the client needs to provide &#x60;p{id}&#x60;, e.g. &#x60;p5&#x60; and for the global context a &#x60;g&#x60;
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by the capabilities id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCapabilities(filters?: string, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCapabilities(filters, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an individual action.
         * @summary View action
         * @param {string} id action id which is the name of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewAction(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewAction(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View capabilities
         * @param {string} id capability id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewCapabilities(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewCapabilities(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the global capability context. This context is necessary to consistently link to a context even if the context is not a project.
         * @summary View global context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewGlobalContext(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewGlobalContext(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActionsCapabilitiesApi - factory interface
 * @export
 */
export const ActionsCapabilitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionsCapabilitiesApiFp(configuration)
    return {
        /**
         * Returns a collection of actions. The client can choose to filter the actions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain actions, for which the requesting client has sufficient permissions.
         * @summary List actions
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Returns only the action having the id or all actions except those having the id(s).
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + *No sort supported yet*
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActions(filters?: string, sortBy?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listActions(filters, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a collection of actions assigned to a principal in a context. The client can choose to filter the actions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain actions, for which the requesting client has sufficient permissions
         * @summary List capabilities
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.  + action: Get all capabilities of a certain action  + principal: Get all capabilities of a principal  + context: Get all capabilities within a context. Note that for a project context the client needs to provide &#x60;p{id}&#x60;, e.g. &#x60;p5&#x60; and for the global context a &#x60;g&#x60;
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by the capabilities id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCapabilities(filters?: string, sortBy?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listCapabilities(filters, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an individual action.
         * @summary View action
         * @param {string} id action id which is the name of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewAction(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.viewAction(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View capabilities
         * @param {string} id capability id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewCapabilities(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.viewCapabilities(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the global capability context. This context is necessary to consistently link to a context even if the context is not a project.
         * @summary View global context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewGlobalContext(options?: any): AxiosPromise<object> {
            return localVarFp.viewGlobalContext(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listActions operation in ActionsCapabilitiesApi.
 * @export
 * @interface ActionsCapabilitiesApiListActionsRequest
 */
export interface ActionsCapabilitiesApiListActionsRequest {
    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Returns only the action having the id or all actions except those having the id(s).
     * @type {string}
     * @memberof ActionsCapabilitiesApiListActions
     */
    readonly filters?: string

    /**
     * JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + *No sort supported yet*
     * @type {string}
     * @memberof ActionsCapabilitiesApiListActions
     */
    readonly sortBy?: string
}

/**
 * Request parameters for listCapabilities operation in ActionsCapabilitiesApi.
 * @export
 * @interface ActionsCapabilitiesApiListCapabilitiesRequest
 */
export interface ActionsCapabilitiesApiListCapabilitiesRequest {
    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.  + action: Get all capabilities of a certain action  + principal: Get all capabilities of a principal  + context: Get all capabilities within a context. Note that for a project context the client needs to provide &#x60;p{id}&#x60;, e.g. &#x60;p5&#x60; and for the global context a &#x60;g&#x60;
     * @type {string}
     * @memberof ActionsCapabilitiesApiListCapabilities
     */
    readonly filters?: string

    /**
     * JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by the capabilities id
     * @type {string}
     * @memberof ActionsCapabilitiesApiListCapabilities
     */
    readonly sortBy?: string
}

/**
 * Request parameters for viewAction operation in ActionsCapabilitiesApi.
 * @export
 * @interface ActionsCapabilitiesApiViewActionRequest
 */
export interface ActionsCapabilitiesApiViewActionRequest {
    /**
     * action id which is the name of the action
     * @type {string}
     * @memberof ActionsCapabilitiesApiViewAction
     */
    readonly id: string
}

/**
 * Request parameters for viewCapabilities operation in ActionsCapabilitiesApi.
 * @export
 * @interface ActionsCapabilitiesApiViewCapabilitiesRequest
 */
export interface ActionsCapabilitiesApiViewCapabilitiesRequest {
    /**
     * capability id
     * @type {string}
     * @memberof ActionsCapabilitiesApiViewCapabilities
     */
    readonly id: string
}

/**
 * ActionsCapabilitiesApi - object-oriented interface
 * @export
 * @class ActionsCapabilitiesApi
 * @extends {BaseAPI}
 */
export class ActionsCapabilitiesApi extends BaseAPI {
    /**
     * Returns a collection of actions. The client can choose to filter the actions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain actions, for which the requesting client has sufficient permissions.
     * @summary List actions
     * @param {ActionsCapabilitiesApiListActionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsCapabilitiesApi
     */
    public listActions(requestParameters: ActionsCapabilitiesApiListActionsRequest = {}, options?: AxiosRequestConfig) {
        return ActionsCapabilitiesApiFp(this.configuration).listActions(requestParameters.filters, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a collection of actions assigned to a principal in a context. The client can choose to filter the actions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain actions, for which the requesting client has sufficient permissions
     * @summary List capabilities
     * @param {ActionsCapabilitiesApiListCapabilitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsCapabilitiesApi
     */
    public listCapabilities(requestParameters: ActionsCapabilitiesApiListCapabilitiesRequest = {}, options?: AxiosRequestConfig) {
        return ActionsCapabilitiesApiFp(this.configuration).listCapabilities(requestParameters.filters, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an individual action.
     * @summary View action
     * @param {ActionsCapabilitiesApiViewActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsCapabilitiesApi
     */
    public viewAction(requestParameters: ActionsCapabilitiesApiViewActionRequest, options?: AxiosRequestConfig) {
        return ActionsCapabilitiesApiFp(this.configuration).viewAction(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View capabilities
     * @param {ActionsCapabilitiesApiViewCapabilitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsCapabilitiesApi
     */
    public viewCapabilities(requestParameters: ActionsCapabilitiesApiViewCapabilitiesRequest, options?: AxiosRequestConfig) {
        return ActionsCapabilitiesApiFp(this.configuration).viewCapabilities(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the global capability context. This context is necessary to consistently link to a context even if the context is not a project.
     * @summary View global context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsCapabilitiesApi
     */
    public viewGlobalContext(options?: AxiosRequestConfig) {
        return ActionsCapabilitiesApiFp(this.configuration).viewGlobalContext(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
export const ActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates an activity\'s comment and, on success, returns the updated activity.
         * @summary Update activity
         * @param {number} id Activity id
         * @param {UpdateActivityRequest} [updateActivityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivity: async (id: number, updateActivityRequest?: UpdateActivityRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateActivity', 'id', id)
            const localVarPath = `/api/v3/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateActivityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View activity
         * @param {number} id Activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewActivity: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewActivity', 'id', id)
            const localVarPath = `/api/v3/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates an activity\'s comment and, on success, returns the updated activity.
         * @summary Update activity
         * @param {number} id Activity id
         * @param {UpdateActivityRequest} [updateActivityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateActivity(id: number, updateActivityRequest?: UpdateActivityRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateActivity(id, updateActivityRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View activity
         * @param {number} id Activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewActivity(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewActivity(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivitiesApiFp(configuration)
    return {
        /**
         * Updates an activity\'s comment and, on success, returns the updated activity.
         * @summary Update activity
         * @param {number} id Activity id
         * @param {UpdateActivityRequest} [updateActivityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivity(id: number, updateActivityRequest?: UpdateActivityRequest, options?: any): AxiosPromise<ActivityModel> {
            return localVarFp.updateActivity(id, updateActivityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View activity
         * @param {number} id Activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewActivity(id: number, options?: any): AxiosPromise<ActivityModel> {
            return localVarFp.viewActivity(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updateActivity operation in ActivitiesApi.
 * @export
 * @interface ActivitiesApiUpdateActivityRequest
 */
export interface ActivitiesApiUpdateActivityRequest {
    /**
     * Activity id
     * @type {number}
     * @memberof ActivitiesApiUpdateActivity
     */
    readonly id: number

    /**
     * 
     * @type {UpdateActivityRequest}
     * @memberof ActivitiesApiUpdateActivity
     */
    readonly updateActivityRequest?: UpdateActivityRequest
}

/**
 * Request parameters for viewActivity operation in ActivitiesApi.
 * @export
 * @interface ActivitiesApiViewActivityRequest
 */
export interface ActivitiesApiViewActivityRequest {
    /**
     * Activity id
     * @type {number}
     * @memberof ActivitiesApiViewActivity
     */
    readonly id: number
}

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * Updates an activity\'s comment and, on success, returns the updated activity.
     * @summary Update activity
     * @param {ActivitiesApiUpdateActivityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public updateActivity(requestParameters: ActivitiesApiUpdateActivityRequest, options?: AxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).updateActivity(requestParameters.id, requestParameters.updateActivityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View activity
     * @param {ActivitiesApiViewActivityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public viewActivity(requestParameters: ActivitiesApiViewActivityRequest, options?: AxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).viewActivity(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AttachmentsApi - axios parameter creator
 * @export
 */
export const AttachmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an attachment with the post as it\'s container.
         * @summary Add attachment to post
         * @param {number} id ID of the post to receive the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachmentToPost: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addAttachmentToPost', 'id', id)
            const localVarPath = `/api/v3/posts/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an attachment with the wiki page as it\'s container.
         * @summary Add attachment to wiki page
         * @param {number} id ID of the wiki page to receive the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachmentToWikiPage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addAttachmentToWikiPage', 'id', id)
            const localVarPath = `/api/v3/wiki_pages/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To add an attachment to a work package, a client needs to issue a request of type `multipart/form-data` with exactly two parts.  The first part *must* be called `metadata`. Its content type is expected to be `application/json`, the body *must* be a single JSON object, containing at least the `fileName` and optionally the attachments `description`.  The second part *must* be called `file`, its content type *should* match the mime type of the file. The body *must* be the raw content of the file. Note that a `filename` must be indicated in the `Content-Disposition` of this part, however it will be ignored. Instead the `fileName` inside the JSON of the metadata part will be used.
         * @summary Add attachment to work package
         * @param {number} id ID of the work package to receive the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachmentToWorkPackage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addAttachmentToWorkPackage', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clients can create attachments without a container first and attach them later on. This is useful if the container does not exist at the time the attachment is uploaded. After the upload, the client can then claim such containerless attachments for any resource eligible (e.g. WorkPackage) on subsequent requests. The upload and the claiming *must* be done for the same user account. Attachments uploaded by another user cannot be claimed and once claimed for a resource, they cannot be claimed by another.  The upload request must be of type `multipart/form-data` with exactly two parts.  The first part *must* be called `metadata`. Its content type is expected to be `application/json`, the body *must* be a single JSON object, containing at least the `fileName` and optionally the attachments `description`.  The second part *must* be called `file`, its content type *should* match the mime type of the file. The body *must* be the raw content of the file. Note that a `filename` *must* be indicated in the `Content-Disposition` of this part, although it will be ignored. Instead the `fileName` inside the JSON of the metadata part will be used.
         * @summary Create Attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes the specified attachment.
         * @summary Delete attachment
         * @param {number} id Attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAttachment', 'id', id)
            const localVarPath = `/api/v3/attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List attachments by post
         * @param {number} id ID of the post whose attachments will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentsByPost: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentsByPost', 'id', id)
            const localVarPath = `/api/v3/posts/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List attachments by wiki page
         * @param {number} id ID of the wiki page whose attachments will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentsByWikiPage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentsByWikiPage', 'id', id)
            const localVarPath = `/api/v3/wiki_pages/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List attachments by work package
         * @param {number} id ID of the work package whose attachments will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentsByWorkPackage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentsByWorkPackage', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View attachment
         * @param {number} id Attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewAttachment: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewAttachment', 'id', id)
            const localVarPath = `/api/v3/attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttachmentsApi - functional programming interface
 * @export
 */
export const AttachmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttachmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds an attachment with the post as it\'s container.
         * @summary Add attachment to post
         * @param {number} id ID of the post to receive the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAttachmentToPost(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAttachmentToPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds an attachment with the wiki page as it\'s container.
         * @summary Add attachment to wiki page
         * @param {number} id ID of the wiki page to receive the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAttachmentToWikiPage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAttachmentToWikiPage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To add an attachment to a work package, a client needs to issue a request of type `multipart/form-data` with exactly two parts.  The first part *must* be called `metadata`. Its content type is expected to be `application/json`, the body *must* be a single JSON object, containing at least the `fileName` and optionally the attachments `description`.  The second part *must* be called `file`, its content type *should* match the mime type of the file. The body *must* be the raw content of the file. Note that a `filename` must be indicated in the `Content-Disposition` of this part, however it will be ignored. Instead the `fileName` inside the JSON of the metadata part will be used.
         * @summary Add attachment to work package
         * @param {number} id ID of the work package to receive the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAttachmentToWorkPackage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAttachmentToWorkPackage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Clients can create attachments without a container first and attach them later on. This is useful if the container does not exist at the time the attachment is uploaded. After the upload, the client can then claim such containerless attachments for any resource eligible (e.g. WorkPackage) on subsequent requests. The upload and the claiming *must* be done for the same user account. Attachments uploaded by another user cannot be claimed and once claimed for a resource, they cannot be claimed by another.  The upload request must be of type `multipart/form-data` with exactly two parts.  The first part *must* be called `metadata`. Its content type is expected to be `application/json`, the body *must* be a single JSON object, containing at least the `fileName` and optionally the attachments `description`.  The second part *must* be called `file`, its content type *should* match the mime type of the file. The body *must* be the raw content of the file. Note that a `filename` *must* be indicated in the `Content-Disposition` of this part, although it will be ignored. Instead the `fileName` inside the JSON of the metadata part will be used.
         * @summary Create Attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAttachment(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAttachment(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes the specified attachment.
         * @summary Delete attachment
         * @param {number} id Attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttachment(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttachment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List attachments by post
         * @param {number} id ID of the post whose attachments will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentsByPost(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentsByPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List attachments by wiki page
         * @param {number} id ID of the wiki page whose attachments will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentsByWikiPage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentsByWikiPage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List attachments by work package
         * @param {number} id ID of the work package whose attachments will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentsByWorkPackage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentsByWorkPackage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View attachment
         * @param {number} id Attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewAttachment(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewAttachment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AttachmentsApi - factory interface
 * @export
 */
export const AttachmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttachmentsApiFp(configuration)
    return {
        /**
         * Adds an attachment with the post as it\'s container.
         * @summary Add attachment to post
         * @param {number} id ID of the post to receive the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachmentToPost(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.addAttachmentToPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds an attachment with the wiki page as it\'s container.
         * @summary Add attachment to wiki page
         * @param {number} id ID of the wiki page to receive the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachmentToWikiPage(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.addAttachmentToWikiPage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * To add an attachment to a work package, a client needs to issue a request of type `multipart/form-data` with exactly two parts.  The first part *must* be called `metadata`. Its content type is expected to be `application/json`, the body *must* be a single JSON object, containing at least the `fileName` and optionally the attachments `description`.  The second part *must* be called `file`, its content type *should* match the mime type of the file. The body *must* be the raw content of the file. Note that a `filename` must be indicated in the `Content-Disposition` of this part, however it will be ignored. Instead the `fileName` inside the JSON of the metadata part will be used.
         * @summary Add attachment to work package
         * @param {number} id ID of the work package to receive the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachmentToWorkPackage(id: number, options?: any): AxiosPromise<AttachmentModel> {
            return localVarFp.addAttachmentToWorkPackage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Clients can create attachments without a container first and attach them later on. This is useful if the container does not exist at the time the attachment is uploaded. After the upload, the client can then claim such containerless attachments for any resource eligible (e.g. WorkPackage) on subsequent requests. The upload and the claiming *must* be done for the same user account. Attachments uploaded by another user cannot be claimed and once claimed for a resource, they cannot be claimed by another.  The upload request must be of type `multipart/form-data` with exactly two parts.  The first part *must* be called `metadata`. Its content type is expected to be `application/json`, the body *must* be a single JSON object, containing at least the `fileName` and optionally the attachments `description`.  The second part *must* be called `file`, its content type *should* match the mime type of the file. The body *must* be the raw content of the file. Note that a `filename` *must* be indicated in the `Content-Disposition` of this part, although it will be ignored. Instead the `fileName` inside the JSON of the metadata part will be used.
         * @summary Create Attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment(options?: any): AxiosPromise<AttachmentModel> {
            return localVarFp.createAttachment(options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes the specified attachment.
         * @summary Delete attachment
         * @param {number} id Attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAttachment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List attachments by post
         * @param {number} id ID of the post whose attachments will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentsByPost(id: number, options?: any): AxiosPromise<AttachmentsModel> {
            return localVarFp.listAttachmentsByPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List attachments by wiki page
         * @param {number} id ID of the wiki page whose attachments will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentsByWikiPage(id: number, options?: any): AxiosPromise<AttachmentsModel> {
            return localVarFp.listAttachmentsByWikiPage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List attachments by work package
         * @param {number} id ID of the work package whose attachments will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentsByWorkPackage(id: number, options?: any): AxiosPromise<AttachmentsModel> {
            return localVarFp.listAttachmentsByWorkPackage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View attachment
         * @param {number} id Attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewAttachment(id: number, options?: any): AxiosPromise<AttachmentModel> {
            return localVarFp.viewAttachment(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addAttachmentToPost operation in AttachmentsApi.
 * @export
 * @interface AttachmentsApiAddAttachmentToPostRequest
 */
export interface AttachmentsApiAddAttachmentToPostRequest {
    /**
     * ID of the post to receive the attachment
     * @type {number}
     * @memberof AttachmentsApiAddAttachmentToPost
     */
    readonly id: number
}

/**
 * Request parameters for addAttachmentToWikiPage operation in AttachmentsApi.
 * @export
 * @interface AttachmentsApiAddAttachmentToWikiPageRequest
 */
export interface AttachmentsApiAddAttachmentToWikiPageRequest {
    /**
     * ID of the wiki page to receive the attachment
     * @type {number}
     * @memberof AttachmentsApiAddAttachmentToWikiPage
     */
    readonly id: number
}

/**
 * Request parameters for addAttachmentToWorkPackage operation in AttachmentsApi.
 * @export
 * @interface AttachmentsApiAddAttachmentToWorkPackageRequest
 */
export interface AttachmentsApiAddAttachmentToWorkPackageRequest {
    /**
     * ID of the work package to receive the attachment
     * @type {number}
     * @memberof AttachmentsApiAddAttachmentToWorkPackage
     */
    readonly id: number
}

/**
 * Request parameters for deleteAttachment operation in AttachmentsApi.
 * @export
 * @interface AttachmentsApiDeleteAttachmentRequest
 */
export interface AttachmentsApiDeleteAttachmentRequest {
    /**
     * Attachment id
     * @type {number}
     * @memberof AttachmentsApiDeleteAttachment
     */
    readonly id: number
}

/**
 * Request parameters for listAttachmentsByPost operation in AttachmentsApi.
 * @export
 * @interface AttachmentsApiListAttachmentsByPostRequest
 */
export interface AttachmentsApiListAttachmentsByPostRequest {
    /**
     * ID of the post whose attachments will be listed
     * @type {number}
     * @memberof AttachmentsApiListAttachmentsByPost
     */
    readonly id: number
}

/**
 * Request parameters for listAttachmentsByWikiPage operation in AttachmentsApi.
 * @export
 * @interface AttachmentsApiListAttachmentsByWikiPageRequest
 */
export interface AttachmentsApiListAttachmentsByWikiPageRequest {
    /**
     * ID of the wiki page whose attachments will be listed
     * @type {number}
     * @memberof AttachmentsApiListAttachmentsByWikiPage
     */
    readonly id: number
}

/**
 * Request parameters for listAttachmentsByWorkPackage operation in AttachmentsApi.
 * @export
 * @interface AttachmentsApiListAttachmentsByWorkPackageRequest
 */
export interface AttachmentsApiListAttachmentsByWorkPackageRequest {
    /**
     * ID of the work package whose attachments will be listed
     * @type {number}
     * @memberof AttachmentsApiListAttachmentsByWorkPackage
     */
    readonly id: number
}

/**
 * Request parameters for viewAttachment operation in AttachmentsApi.
 * @export
 * @interface AttachmentsApiViewAttachmentRequest
 */
export interface AttachmentsApiViewAttachmentRequest {
    /**
     * Attachment id
     * @type {number}
     * @memberof AttachmentsApiViewAttachment
     */
    readonly id: number
}

/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
export class AttachmentsApi extends BaseAPI {
    /**
     * Adds an attachment with the post as it\'s container.
     * @summary Add attachment to post
     * @param {AttachmentsApiAddAttachmentToPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public addAttachmentToPost(requestParameters: AttachmentsApiAddAttachmentToPostRequest, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).addAttachmentToPost(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds an attachment with the wiki page as it\'s container.
     * @summary Add attachment to wiki page
     * @param {AttachmentsApiAddAttachmentToWikiPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public addAttachmentToWikiPage(requestParameters: AttachmentsApiAddAttachmentToWikiPageRequest, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).addAttachmentToWikiPage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To add an attachment to a work package, a client needs to issue a request of type `multipart/form-data` with exactly two parts.  The first part *must* be called `metadata`. Its content type is expected to be `application/json`, the body *must* be a single JSON object, containing at least the `fileName` and optionally the attachments `description`.  The second part *must* be called `file`, its content type *should* match the mime type of the file. The body *must* be the raw content of the file. Note that a `filename` must be indicated in the `Content-Disposition` of this part, however it will be ignored. Instead the `fileName` inside the JSON of the metadata part will be used.
     * @summary Add attachment to work package
     * @param {AttachmentsApiAddAttachmentToWorkPackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public addAttachmentToWorkPackage(requestParameters: AttachmentsApiAddAttachmentToWorkPackageRequest, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).addAttachmentToWorkPackage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clients can create attachments without a container first and attach them later on. This is useful if the container does not exist at the time the attachment is uploaded. After the upload, the client can then claim such containerless attachments for any resource eligible (e.g. WorkPackage) on subsequent requests. The upload and the claiming *must* be done for the same user account. Attachments uploaded by another user cannot be claimed and once claimed for a resource, they cannot be claimed by another.  The upload request must be of type `multipart/form-data` with exactly two parts.  The first part *must* be called `metadata`. Its content type is expected to be `application/json`, the body *must* be a single JSON object, containing at least the `fileName` and optionally the attachments `description`.  The second part *must* be called `file`, its content type *should* match the mime type of the file. The body *must* be the raw content of the file. Note that a `filename` *must* be indicated in the `Content-Disposition` of this part, although it will be ignored. Instead the `fileName` inside the JSON of the metadata part will be used.
     * @summary Create Attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public createAttachment(options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).createAttachment(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes the specified attachment.
     * @summary Delete attachment
     * @param {AttachmentsApiDeleteAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public deleteAttachment(requestParameters: AttachmentsApiDeleteAttachmentRequest, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).deleteAttachment(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List attachments by post
     * @param {AttachmentsApiListAttachmentsByPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public listAttachmentsByPost(requestParameters: AttachmentsApiListAttachmentsByPostRequest, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).listAttachmentsByPost(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List attachments by wiki page
     * @param {AttachmentsApiListAttachmentsByWikiPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public listAttachmentsByWikiPage(requestParameters: AttachmentsApiListAttachmentsByWikiPageRequest, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).listAttachmentsByWikiPage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List attachments by work package
     * @param {AttachmentsApiListAttachmentsByWorkPackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public listAttachmentsByWorkPackage(requestParameters: AttachmentsApiListAttachmentsByWorkPackageRequest, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).listAttachmentsByWorkPackage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View attachment
     * @param {AttachmentsApiViewAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public viewAttachment(requestParameters: AttachmentsApiViewAttachmentRequest, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).viewAttachment(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BudgetsApi - axios parameter creator
 * @export
 */
export const BudgetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary view Budget
         * @param {number} id Budget id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewBudget: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewBudget', 'id', id)
            const localVarPath = `/api/v3/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary view Budgets of a Project
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewBudgetsOfAProject: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewBudgetsOfAProject', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/budgets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetsApi - functional programming interface
 * @export
 */
export const BudgetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary view Budget
         * @param {number} id Budget id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewBudget(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewBudget(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary view Budgets of a Project
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewBudgetsOfAProject(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewBudgetsOfAProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BudgetsApi - factory interface
 * @export
 */
export const BudgetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetsApiFp(configuration)
    return {
        /**
         * 
         * @summary view Budget
         * @param {number} id Budget id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewBudget(id: number, options?: any): AxiosPromise<BudgetModel> {
            return localVarFp.viewBudget(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary view Budgets of a Project
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewBudgetsOfAProject(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.viewBudgetsOfAProject(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiViewBudgetRequest
 */
export interface BudgetsApiViewBudgetRequest {
    /**
     * Budget id
     * @type {number}
     * @memberof BudgetsApiViewBudget
     */
    readonly id: number
}

/**
 * Request parameters for viewBudgetsOfAProject operation in BudgetsApi.
 * @export
 * @interface BudgetsApiViewBudgetsOfAProjectRequest
 */
export interface BudgetsApiViewBudgetsOfAProjectRequest {
    /**
     * Project id
     * @type {number}
     * @memberof BudgetsApiViewBudgetsOfAProject
     */
    readonly id: number
}

/**
 * BudgetsApi - object-oriented interface
 * @export
 * @class BudgetsApi
 * @extends {BaseAPI}
 */
export class BudgetsApi extends BaseAPI {
    /**
     * 
     * @summary view Budget
     * @param {BudgetsApiViewBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public viewBudget(requestParameters: BudgetsApiViewBudgetRequest, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).viewBudget(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary view Budgets of a Project
     * @param {BudgetsApiViewBudgetsOfAProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public viewBudgetsOfAProject(requestParameters: BudgetsApiViewBudgetsOfAProjectRequest, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).viewBudgetsOfAProject(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List categories of a project
         * @param {number} id ID of the project whose categories will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategoriesOfAProject: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listCategoriesOfAProject', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/categories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View Category
         * @param {number} id Category id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewCategory: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewCategory', 'id', id)
            const localVarPath = `/api/v3/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List categories of a project
         * @param {number} id ID of the project whose categories will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCategoriesOfAProject(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCategoriesOfAProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View Category
         * @param {number} id Category id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewCategory(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary List categories of a project
         * @param {number} id ID of the project whose categories will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategoriesOfAProject(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.listCategoriesOfAProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View Category
         * @param {number} id Category id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewCategory(id: number, options?: any): AxiosPromise<CategoryModel> {
            return localVarFp.viewCategory(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listCategoriesOfAProject operation in CategoriesApi.
 * @export
 * @interface CategoriesApiListCategoriesOfAProjectRequest
 */
export interface CategoriesApiListCategoriesOfAProjectRequest {
    /**
     * ID of the project whose categories will be listed
     * @type {number}
     * @memberof CategoriesApiListCategoriesOfAProject
     */
    readonly id: number
}

/**
 * Request parameters for viewCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiViewCategoryRequest
 */
export interface CategoriesApiViewCategoryRequest {
    /**
     * Category id
     * @type {number}
     * @memberof CategoriesApiViewCategory
     */
    readonly id: number
}

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * 
     * @summary List categories of a project
     * @param {CategoriesApiListCategoriesOfAProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listCategoriesOfAProject(requestParameters: CategoriesApiListCategoriesOfAProjectRequest, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).listCategoriesOfAProject(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View Category
     * @param {CategoriesApiViewCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public viewCategory(requestParameters: CategoriesApiViewCategoryRequest, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).viewCategory(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary view aggregated result
         * @param {string} [groupBy] The column to group by. Note: Aggregation is as of now only supported by the work package collection. You can pass any column name as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {boolean} [showSums] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewAggregatedResult: async (groupBy?: string, showSums?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/examples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (showSums !== undefined) {
                localVarQueryParameter['showSums'] = showSums;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary view aggregated result
         * @param {string} [groupBy] The column to group by. Note: Aggregation is as of now only supported by the work package collection. You can pass any column name as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {boolean} [showSums] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewAggregatedResult(groupBy?: string, showSums?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewAggregatedResult(groupBy, showSums, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionsApiFp(configuration)
    return {
        /**
         * 
         * @summary view aggregated result
         * @param {string} [groupBy] The column to group by. Note: Aggregation is as of now only supported by the work package collection. You can pass any column name as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {boolean} [showSums] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewAggregatedResult(groupBy?: string, showSums?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.viewAggregatedResult(groupBy, showSums, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewAggregatedResult operation in CollectionsApi.
 * @export
 * @interface CollectionsApiViewAggregatedResultRequest
 */
export interface CollectionsApiViewAggregatedResultRequest {
    /**
     * The column to group by. Note: Aggregation is as of now only supported by the work package collection. You can pass any column name as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
     * @type {string}
     * @memberof CollectionsApiViewAggregatedResult
     */
    readonly groupBy?: string

    /**
     * 
     * @type {boolean}
     * @memberof CollectionsApiViewAggregatedResult
     */
    readonly showSums?: boolean
}

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * 
     * @summary view aggregated result
     * @param {CollectionsApiViewAggregatedResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public viewAggregatedResult(requestParameters: CollectionsApiViewAggregatedResultRequest = {}, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).viewAggregatedResult(requestParameters.groupBy, requestParameters.showSums, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigurationApi - axios parameter creator
 * @export
 */
export const ConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewConfiguration: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationApi - functional programming interface
 * @export
 */
export const ConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary View configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewConfiguration(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewConfiguration(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigurationApi - factory interface
 * @export
 */
export const ConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigurationApiFp(configuration)
    return {
        /**
         * 
         * @summary View configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewConfiguration(options?: any): AxiosPromise<ConfigurationModel> {
            return localVarFp.viewConfiguration(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
export class ConfigurationApi extends BaseAPI {
    /**
     * 
     * @summary View configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public viewConfiguration(options?: AxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).viewConfiguration(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomActionsApi - axios parameter creator
 * @export
 */
export const CustomActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A POST to this end point executes the custom action on the work package provided in the payload. The altered work package will be returned. In order to avoid executing  the custom action unbeknown to a change that has already taken place, the client has to provide the work package\'s current lockVersion.
         * @summary Execute custom action
         * @param {number} id The id of the custom action to execute
         * @param {ExecuteCustomActionRequest} [executeCustomActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeCustomAction: async (id: number, executeCustomActionRequest?: ExecuteCustomActionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('executeCustomAction', 'id', id)
            const localVarPath = `/api/v3/custom_actions/{id}/execute`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeCustomActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View custom action
         * @param {number} id The id of the custom action to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewCustomAction: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewCustomAction', 'id', id)
            const localVarPath = `/api/v3/custom_actions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomActionsApi - functional programming interface
 * @export
 */
export const CustomActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * A POST to this end point executes the custom action on the work package provided in the payload. The altered work package will be returned. In order to avoid executing  the custom action unbeknown to a change that has already taken place, the client has to provide the work package\'s current lockVersion.
         * @summary Execute custom action
         * @param {number} id The id of the custom action to execute
         * @param {ExecuteCustomActionRequest} [executeCustomActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeCustomAction(id: number, executeCustomActionRequest?: ExecuteCustomActionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeCustomAction(id, executeCustomActionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View custom action
         * @param {number} id The id of the custom action to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewCustomAction(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewCustomAction(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomActionsApi - factory interface
 * @export
 */
export const CustomActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomActionsApiFp(configuration)
    return {
        /**
         * A POST to this end point executes the custom action on the work package provided in the payload. The altered work package will be returned. In order to avoid executing  the custom action unbeknown to a change that has already taken place, the client has to provide the work package\'s current lockVersion.
         * @summary Execute custom action
         * @param {number} id The id of the custom action to execute
         * @param {ExecuteCustomActionRequest} [executeCustomActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeCustomAction(id: number, executeCustomActionRequest?: ExecuteCustomActionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.executeCustomAction(id, executeCustomActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View custom action
         * @param {number} id The id of the custom action to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewCustomAction(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.viewCustomAction(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for executeCustomAction operation in CustomActionsApi.
 * @export
 * @interface CustomActionsApiExecuteCustomActionRequest
 */
export interface CustomActionsApiExecuteCustomActionRequest {
    /**
     * The id of the custom action to execute
     * @type {number}
     * @memberof CustomActionsApiExecuteCustomAction
     */
    readonly id: number

    /**
     * 
     * @type {ExecuteCustomActionRequest}
     * @memberof CustomActionsApiExecuteCustomAction
     */
    readonly executeCustomActionRequest?: ExecuteCustomActionRequest
}

/**
 * Request parameters for viewCustomAction operation in CustomActionsApi.
 * @export
 * @interface CustomActionsApiViewCustomActionRequest
 */
export interface CustomActionsApiViewCustomActionRequest {
    /**
     * The id of the custom action to fetch
     * @type {number}
     * @memberof CustomActionsApiViewCustomAction
     */
    readonly id: number
}

/**
 * CustomActionsApi - object-oriented interface
 * @export
 * @class CustomActionsApi
 * @extends {BaseAPI}
 */
export class CustomActionsApi extends BaseAPI {
    /**
     * A POST to this end point executes the custom action on the work package provided in the payload. The altered work package will be returned. In order to avoid executing  the custom action unbeknown to a change that has already taken place, the client has to provide the work package\'s current lockVersion.
     * @summary Execute custom action
     * @param {CustomActionsApiExecuteCustomActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomActionsApi
     */
    public executeCustomAction(requestParameters: CustomActionsApiExecuteCustomActionRequest, options?: AxiosRequestConfig) {
        return CustomActionsApiFp(this.configuration).executeCustomAction(requestParameters.id, requestParameters.executeCustomActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View custom action
     * @param {CustomActionsApiViewCustomActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomActionsApi
     */
    public viewCustomAction(requestParameters: CustomActionsApiViewCustomActionRequest, options?: AxiosRequestConfig) {
        return CustomActionsApiFp(this.configuration).viewCustomAction(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomOptionsApi - axios parameter creator
 * @export
 */
export const CustomOptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View Custom Option
         * @param {number} id The custom option\&#39;s identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewCustomOption: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewCustomOption', 'id', id)
            const localVarPath = `/api/v3/custom_options/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomOptionsApi - functional programming interface
 * @export
 */
export const CustomOptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomOptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary View Custom Option
         * @param {number} id The custom option\&#39;s identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewCustomOption(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomOptionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewCustomOption(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomOptionsApi - factory interface
 * @export
 */
export const CustomOptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomOptionsApiFp(configuration)
    return {
        /**
         * 
         * @summary View Custom Option
         * @param {number} id The custom option\&#39;s identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewCustomOption(id: number, options?: any): AxiosPromise<CustomOptionModel> {
            return localVarFp.viewCustomOption(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewCustomOption operation in CustomOptionsApi.
 * @export
 * @interface CustomOptionsApiViewCustomOptionRequest
 */
export interface CustomOptionsApiViewCustomOptionRequest {
    /**
     * The custom option\&#39;s identifier
     * @type {number}
     * @memberof CustomOptionsApiViewCustomOption
     */
    readonly id: number
}

/**
 * CustomOptionsApi - object-oriented interface
 * @export
 * @class CustomOptionsApi
 * @extends {BaseAPI}
 */
export class CustomOptionsApi extends BaseAPI {
    /**
     * 
     * @summary View Custom Option
     * @param {CustomOptionsApiViewCustomOptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomOptionsApi
     */
    public viewCustomOption(requestParameters: CustomOptionsApiViewCustomOptionRequest, options?: AxiosRequestConfig) {
        return CustomOptionsApiFp(this.configuration).viewCustomOption(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The documents returned depend on the provided parameters and also on the requesting user\'s permissions.
         * @summary List Documents
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + created_at: Sort by document creation datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments: async (offset?: number, pageSize?: number, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View document
         * @param {number} id Document id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewDocument: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewDocument', 'id', id)
            const localVarPath = `/api/v3/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * The documents returned depend on the provided parameters and also on the requesting user\'s permissions.
         * @summary List Documents
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + created_at: Sort by document creation datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDocuments(offset?: number, pageSize?: number, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDocuments(offset, pageSize, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View document
         * @param {number} id Document id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewDocument(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewDocument(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * The documents returned depend on the provided parameters and also on the requesting user\'s permissions.
         * @summary List Documents
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + created_at: Sort by document creation datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(offset?: number, pageSize?: number, sortBy?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listDocuments(offset, pageSize, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View document
         * @param {number} id Document id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewDocument(id: number, options?: any): AxiosPromise<DocumentModel> {
            return localVarFp.viewDocument(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listDocuments operation in DocumentsApi.
 * @export
 * @interface DocumentsApiListDocumentsRequest
 */
export interface DocumentsApiListDocumentsRequest {
    /**
     * Page number inside the requested collection.
     * @type {number}
     * @memberof DocumentsApiListDocuments
     */
    readonly offset?: number

    /**
     * Number of elements to display per page.
     * @type {number}
     * @memberof DocumentsApiListDocuments
     */
    readonly pageSize?: number

    /**
     * JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + created_at: Sort by document creation datetime
     * @type {string}
     * @memberof DocumentsApiListDocuments
     */
    readonly sortBy?: string
}

/**
 * Request parameters for viewDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiViewDocumentRequest
 */
export interface DocumentsApiViewDocumentRequest {
    /**
     * Document id
     * @type {number}
     * @memberof DocumentsApiViewDocument
     */
    readonly id: number
}

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * The documents returned depend on the provided parameters and also on the requesting user\'s permissions.
     * @summary List Documents
     * @param {DocumentsApiListDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public listDocuments(requestParameters: DocumentsApiListDocumentsRequest = {}, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).listDocuments(requestParameters.offset, requestParameters.pageSize, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View document
     * @param {DocumentsApiViewDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public viewDocument(requestParameters: DocumentsApiViewDocumentRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).viewDocument(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FileLinksApi - axios parameter creator
 * @export
 */
export const FileLinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates file links on a work package.  The request is interpreted as a bulk insert, where every element of the collection is validated separately. Each element contains the origin meta data and a link to the storage, the file link is about to point to. The storage link can be provided as a resource link with id or as the host url.  The file\'s id and name are considered mandatory information. The rest of the origin meta data SHOULD be provided by the client. The _mimeType_ SHOULD be a standard mime type. An empty mime type will be handled as unknown. To link a folder, the custom mime type `application/x-op-directory` MUST be used.  Up to 20 file links can be submitted at once.  If any element data is invalid, no file links will be created.  If a file link with matching origin id, work package, and storage already exists, then it will not create an additional file link or update the meta data. Instead the information from the existing file link will be returned.
         * @summary Creates file links.
         * @param {number} id Work package id
         * @param {FileLinkCollectionWriteModel} [fileLinkCollectionWriteModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkPackageFileLink: async (id: number, fileLinkCollectionWriteModel?: FileLinkCollectionWriteModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createWorkPackageFileLink', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/file_links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileLinkCollectionWriteModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a file link on a work package.  The request contains only the file link identifier as a path parameter. No request body is needed.
         * @summary Removes a file link.
         * @param {number} id File link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileLink: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFileLink', 'id', id)
            const localVarPath = `/api/v3/file_links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a uri to download the origin file linked by the given file link. This uri depends on the storage type and is always located on the origin storage itself.
         * @summary Creates a download uri of the linked file.
         * @param {number} id File link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFileLink: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadFileLink', 'id', id)
            const localVarPath = `/api/v3/file_links/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a storage resource. As a side effect, a live connection to the storages origin is established to retrieve connection state data.
         * @summary Gets a storage.
         * @param {number} id Storage id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStorage', 'id', id)
            const localVarPath = `/api/v3/storages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a collection of files from a storage.  If no `parent` context is given, the result is the content of the document root. With `parent` context given, the result contains the collections of files/directories from within the given parent file id.  If given `parent` context is no directory, `400 Bad Request` is returned.
         * @summary Gets files of a storage.
         * @param {number} id Storage id
         * @param {string} [parent] Parent file identification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageFiles: async (id: number, parent?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStorageFiles', 'id', id)
            const localVarPath = `/api/v3/storages/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all file links of a work package.  As a side effect, for every file link a request is sent to the storage\'s origin to fetch live data and patch the file link\'s data before returning, as well as retrieving permissions of the user on this origin file. 
         * @summary Gets all file links of a work package
         * @param {number} id Work package id
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. The following filters are supported:  - storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkPackageFileLinks: async (id: number, filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listWorkPackageFileLinks', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/file_links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a uri to open the origin file linked by the given file link. This uri depends on the storage type and is always located on the origin storage itself.
         * @summary Creates an opening uri of the linked file.
         * @param {number} id File link id
         * @param {boolean} [location] Boolean flag indicating, if the file should be opened directly or rather the directory location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openFileLink: async (id: number, location?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('openFileLink', 'id', id)
            const localVarPath = `/api/v3/file_links/{id}/open`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the origin file data of a all file links within a work package.  The cached data is updated (overwritten) with the new data. If any data point is not available in the new data, but in the old cache, it is not overwritten.  After a successful update the client SHOULD retrieve the links of file links again to obtain the new data.
         * @summary Updated the origin data of the file links of a work package.
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkPackageFileLinks: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWorkPackageFileLinks', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/update_file_links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single file link resource of a work package.
         * @summary Gets a file link.
         * @param {number} id File link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewFileLink: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewFileLink', 'id', id)
            const localVarPath = `/api/v3/file_links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileLinksApi - functional programming interface
 * @export
 */
export const FileLinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileLinksApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates file links on a work package.  The request is interpreted as a bulk insert, where every element of the collection is validated separately. Each element contains the origin meta data and a link to the storage, the file link is about to point to. The storage link can be provided as a resource link with id or as the host url.  The file\'s id and name are considered mandatory information. The rest of the origin meta data SHOULD be provided by the client. The _mimeType_ SHOULD be a standard mime type. An empty mime type will be handled as unknown. To link a folder, the custom mime type `application/x-op-directory` MUST be used.  Up to 20 file links can be submitted at once.  If any element data is invalid, no file links will be created.  If a file link with matching origin id, work package, and storage already exists, then it will not create an additional file link or update the meta data. Instead the information from the existing file link will be returned.
         * @summary Creates file links.
         * @param {number} id Work package id
         * @param {FileLinkCollectionWriteModel} [fileLinkCollectionWriteModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkPackageFileLink(id: number, fileLinkCollectionWriteModel?: FileLinkCollectionWriteModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileLinkCollectionReadModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkPackageFileLink(id, fileLinkCollectionWriteModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a file link on a work package.  The request contains only the file link identifier as a path parameter. No request body is needed.
         * @summary Removes a file link.
         * @param {number} id File link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileLink(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a uri to download the origin file linked by the given file link. This uri depends on the storage type and is always located on the origin storage itself.
         * @summary Creates a download uri of the linked file.
         * @param {number} id File link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFileLink(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFileLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a storage resource. As a side effect, a live connection to the storages origin is established to retrieve connection state data.
         * @summary Gets a storage.
         * @param {number} id Storage id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a collection of files from a storage.  If no `parent` context is given, the result is the content of the document root. With `parent` context given, the result contains the collections of files/directories from within the given parent file id.  If given `parent` context is no directory, `400 Bad Request` is returned.
         * @summary Gets files of a storage.
         * @param {number} id Storage id
         * @param {string} [parent] Parent file identification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageFiles(id: number, parent?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileCollectionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageFiles(id, parent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all file links of a work package.  As a side effect, for every file link a request is sent to the storage\'s origin to fetch live data and patch the file link\'s data before returning, as well as retrieving permissions of the user on this origin file. 
         * @summary Gets all file links of a work package
         * @param {number} id Work package id
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. The following filters are supported:  - storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkPackageFileLinks(id: number, filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileLinkCollectionReadModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkPackageFileLinks(id, filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a uri to open the origin file linked by the given file link. This uri depends on the storage type and is always located on the origin storage itself.
         * @summary Creates an opening uri of the linked file.
         * @param {number} id File link id
         * @param {boolean} [location] Boolean flag indicating, if the file should be opened directly or rather the directory location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openFileLink(id: number, location?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openFileLink(id, location, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the origin file data of a all file links within a work package.  The cached data is updated (overwritten) with the new data. If any data point is not available in the new data, but in the old cache, it is not overwritten.  After a successful update the client SHOULD retrieve the links of file links again to obtain the new data.
         * @summary Updated the origin data of the file links of a work package.
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkPackageFileLinks(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkPackageFileLinks(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a single file link resource of a work package.
         * @summary Gets a file link.
         * @param {number} id File link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewFileLink(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileLinkReadModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewFileLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FileLinksApi - factory interface
 * @export
 */
export const FileLinksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileLinksApiFp(configuration)
    return {
        /**
         * Creates file links on a work package.  The request is interpreted as a bulk insert, where every element of the collection is validated separately. Each element contains the origin meta data and a link to the storage, the file link is about to point to. The storage link can be provided as a resource link with id or as the host url.  The file\'s id and name are considered mandatory information. The rest of the origin meta data SHOULD be provided by the client. The _mimeType_ SHOULD be a standard mime type. An empty mime type will be handled as unknown. To link a folder, the custom mime type `application/x-op-directory` MUST be used.  Up to 20 file links can be submitted at once.  If any element data is invalid, no file links will be created.  If a file link with matching origin id, work package, and storage already exists, then it will not create an additional file link or update the meta data. Instead the information from the existing file link will be returned.
         * @summary Creates file links.
         * @param {number} id Work package id
         * @param {FileLinkCollectionWriteModel} [fileLinkCollectionWriteModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkPackageFileLink(id: number, fileLinkCollectionWriteModel?: FileLinkCollectionWriteModel, options?: any): AxiosPromise<FileLinkCollectionReadModel> {
            return localVarFp.createWorkPackageFileLink(id, fileLinkCollectionWriteModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a file link on a work package.  The request contains only the file link identifier as a path parameter. No request body is needed.
         * @summary Removes a file link.
         * @param {number} id File link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileLink(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFileLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a uri to download the origin file linked by the given file link. This uri depends on the storage type and is always located on the origin storage itself.
         * @summary Creates a download uri of the linked file.
         * @param {number} id File link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFileLink(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.downloadFileLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a storage resource. As a side effect, a live connection to the storages origin is established to retrieve connection state data.
         * @summary Gets a storage.
         * @param {number} id Storage id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage(id: number, options?: any): AxiosPromise<StorageModel> {
            return localVarFp.getStorage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a collection of files from a storage.  If no `parent` context is given, the result is the content of the document root. With `parent` context given, the result contains the collections of files/directories from within the given parent file id.  If given `parent` context is no directory, `400 Bad Request` is returned.
         * @summary Gets files of a storage.
         * @param {number} id Storage id
         * @param {string} [parent] Parent file identification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageFiles(id: number, parent?: string, options?: any): AxiosPromise<FileCollectionModel> {
            return localVarFp.getStorageFiles(id, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all file links of a work package.  As a side effect, for every file link a request is sent to the storage\'s origin to fetch live data and patch the file link\'s data before returning, as well as retrieving permissions of the user on this origin file. 
         * @summary Gets all file links of a work package
         * @param {number} id Work package id
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. The following filters are supported:  - storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkPackageFileLinks(id: number, filters?: string, options?: any): AxiosPromise<FileLinkCollectionReadModel> {
            return localVarFp.listWorkPackageFileLinks(id, filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a uri to open the origin file linked by the given file link. This uri depends on the storage type and is always located on the origin storage itself.
         * @summary Creates an opening uri of the linked file.
         * @param {number} id File link id
         * @param {boolean} [location] Boolean flag indicating, if the file should be opened directly or rather the directory location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openFileLink(id: number, location?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.openFileLink(id, location, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the origin file data of a all file links within a work package.  The cached data is updated (overwritten) with the new data. If any data point is not available in the new data, but in the old cache, it is not overwritten.  After a successful update the client SHOULD retrieve the links of file links again to obtain the new data.
         * @summary Updated the origin data of the file links of a work package.
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkPackageFileLinks(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.updateWorkPackageFileLinks(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a single file link resource of a work package.
         * @summary Gets a file link.
         * @param {number} id File link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewFileLink(id: number, options?: any): AxiosPromise<FileLinkReadModel> {
            return localVarFp.viewFileLink(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createWorkPackageFileLink operation in FileLinksApi.
 * @export
 * @interface FileLinksApiCreateWorkPackageFileLinkRequest
 */
export interface FileLinksApiCreateWorkPackageFileLinkRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof FileLinksApiCreateWorkPackageFileLink
     */
    readonly id: number

    /**
     * 
     * @type {FileLinkCollectionWriteModel}
     * @memberof FileLinksApiCreateWorkPackageFileLink
     */
    readonly fileLinkCollectionWriteModel?: FileLinkCollectionWriteModel
}

/**
 * Request parameters for deleteFileLink operation in FileLinksApi.
 * @export
 * @interface FileLinksApiDeleteFileLinkRequest
 */
export interface FileLinksApiDeleteFileLinkRequest {
    /**
     * File link id
     * @type {number}
     * @memberof FileLinksApiDeleteFileLink
     */
    readonly id: number
}

/**
 * Request parameters for downloadFileLink operation in FileLinksApi.
 * @export
 * @interface FileLinksApiDownloadFileLinkRequest
 */
export interface FileLinksApiDownloadFileLinkRequest {
    /**
     * File link id
     * @type {number}
     * @memberof FileLinksApiDownloadFileLink
     */
    readonly id: number
}

/**
 * Request parameters for getStorage operation in FileLinksApi.
 * @export
 * @interface FileLinksApiGetStorageRequest
 */
export interface FileLinksApiGetStorageRequest {
    /**
     * Storage id
     * @type {number}
     * @memberof FileLinksApiGetStorage
     */
    readonly id: number
}

/**
 * Request parameters for getStorageFiles operation in FileLinksApi.
 * @export
 * @interface FileLinksApiGetStorageFilesRequest
 */
export interface FileLinksApiGetStorageFilesRequest {
    /**
     * Storage id
     * @type {number}
     * @memberof FileLinksApiGetStorageFiles
     */
    readonly id: number

    /**
     * Parent file identification
     * @type {string}
     * @memberof FileLinksApiGetStorageFiles
     */
    readonly parent?: string
}

/**
 * Request parameters for listWorkPackageFileLinks operation in FileLinksApi.
 * @export
 * @interface FileLinksApiListWorkPackageFileLinksRequest
 */
export interface FileLinksApiListWorkPackageFileLinksRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof FileLinksApiListWorkPackageFileLinks
     */
    readonly id: number

    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. The following filters are supported:  - storage
     * @type {string}
     * @memberof FileLinksApiListWorkPackageFileLinks
     */
    readonly filters?: string
}

/**
 * Request parameters for openFileLink operation in FileLinksApi.
 * @export
 * @interface FileLinksApiOpenFileLinkRequest
 */
export interface FileLinksApiOpenFileLinkRequest {
    /**
     * File link id
     * @type {number}
     * @memberof FileLinksApiOpenFileLink
     */
    readonly id: number

    /**
     * Boolean flag indicating, if the file should be opened directly or rather the directory location.
     * @type {boolean}
     * @memberof FileLinksApiOpenFileLink
     */
    readonly location?: boolean
}

/**
 * Request parameters for updateWorkPackageFileLinks operation in FileLinksApi.
 * @export
 * @interface FileLinksApiUpdateWorkPackageFileLinksRequest
 */
export interface FileLinksApiUpdateWorkPackageFileLinksRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof FileLinksApiUpdateWorkPackageFileLinks
     */
    readonly id: number
}

/**
 * Request parameters for viewFileLink operation in FileLinksApi.
 * @export
 * @interface FileLinksApiViewFileLinkRequest
 */
export interface FileLinksApiViewFileLinkRequest {
    /**
     * File link id
     * @type {number}
     * @memberof FileLinksApiViewFileLink
     */
    readonly id: number
}

/**
 * FileLinksApi - object-oriented interface
 * @export
 * @class FileLinksApi
 * @extends {BaseAPI}
 */
export class FileLinksApi extends BaseAPI {
    /**
     * Creates file links on a work package.  The request is interpreted as a bulk insert, where every element of the collection is validated separately. Each element contains the origin meta data and a link to the storage, the file link is about to point to. The storage link can be provided as a resource link with id or as the host url.  The file\'s id and name are considered mandatory information. The rest of the origin meta data SHOULD be provided by the client. The _mimeType_ SHOULD be a standard mime type. An empty mime type will be handled as unknown. To link a folder, the custom mime type `application/x-op-directory` MUST be used.  Up to 20 file links can be submitted at once.  If any element data is invalid, no file links will be created.  If a file link with matching origin id, work package, and storage already exists, then it will not create an additional file link or update the meta data. Instead the information from the existing file link will be returned.
     * @summary Creates file links.
     * @param {FileLinksApiCreateWorkPackageFileLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileLinksApi
     */
    public createWorkPackageFileLink(requestParameters: FileLinksApiCreateWorkPackageFileLinkRequest, options?: AxiosRequestConfig) {
        return FileLinksApiFp(this.configuration).createWorkPackageFileLink(requestParameters.id, requestParameters.fileLinkCollectionWriteModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a file link on a work package.  The request contains only the file link identifier as a path parameter. No request body is needed.
     * @summary Removes a file link.
     * @param {FileLinksApiDeleteFileLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileLinksApi
     */
    public deleteFileLink(requestParameters: FileLinksApiDeleteFileLinkRequest, options?: AxiosRequestConfig) {
        return FileLinksApiFp(this.configuration).deleteFileLink(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a uri to download the origin file linked by the given file link. This uri depends on the storage type and is always located on the origin storage itself.
     * @summary Creates a download uri of the linked file.
     * @param {FileLinksApiDownloadFileLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileLinksApi
     */
    public downloadFileLink(requestParameters: FileLinksApiDownloadFileLinkRequest, options?: AxiosRequestConfig) {
        return FileLinksApiFp(this.configuration).downloadFileLink(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a storage resource. As a side effect, a live connection to the storages origin is established to retrieve connection state data.
     * @summary Gets a storage.
     * @param {FileLinksApiGetStorageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileLinksApi
     */
    public getStorage(requestParameters: FileLinksApiGetStorageRequest, options?: AxiosRequestConfig) {
        return FileLinksApiFp(this.configuration).getStorage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a collection of files from a storage.  If no `parent` context is given, the result is the content of the document root. With `parent` context given, the result contains the collections of files/directories from within the given parent file id.  If given `parent` context is no directory, `400 Bad Request` is returned.
     * @summary Gets files of a storage.
     * @param {FileLinksApiGetStorageFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileLinksApi
     */
    public getStorageFiles(requestParameters: FileLinksApiGetStorageFilesRequest, options?: AxiosRequestConfig) {
        return FileLinksApiFp(this.configuration).getStorageFiles(requestParameters.id, requestParameters.parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all file links of a work package.  As a side effect, for every file link a request is sent to the storage\'s origin to fetch live data and patch the file link\'s data before returning, as well as retrieving permissions of the user on this origin file. 
     * @summary Gets all file links of a work package
     * @param {FileLinksApiListWorkPackageFileLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileLinksApi
     */
    public listWorkPackageFileLinks(requestParameters: FileLinksApiListWorkPackageFileLinksRequest, options?: AxiosRequestConfig) {
        return FileLinksApiFp(this.configuration).listWorkPackageFileLinks(requestParameters.id, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a uri to open the origin file linked by the given file link. This uri depends on the storage type and is always located on the origin storage itself.
     * @summary Creates an opening uri of the linked file.
     * @param {FileLinksApiOpenFileLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileLinksApi
     */
    public openFileLink(requestParameters: FileLinksApiOpenFileLinkRequest, options?: AxiosRequestConfig) {
        return FileLinksApiFp(this.configuration).openFileLink(requestParameters.id, requestParameters.location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the origin file data of a all file links within a work package.  The cached data is updated (overwritten) with the new data. If any data point is not available in the new data, but in the old cache, it is not overwritten.  After a successful update the client SHOULD retrieve the links of file links again to obtain the new data.
     * @summary Updated the origin data of the file links of a work package.
     * @param {FileLinksApiUpdateWorkPackageFileLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileLinksApi
     */
    public updateWorkPackageFileLinks(requestParameters: FileLinksApiUpdateWorkPackageFileLinksRequest, options?: AxiosRequestConfig) {
        return FileLinksApiFp(this.configuration).updateWorkPackageFileLinks(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a single file link resource of a work package.
     * @summary Gets a file link.
     * @param {FileLinksApiViewFileLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileLinksApi
     */
    public viewFileLink(requestParameters: FileLinksApiViewFileLinkRequest, options?: AxiosRequestConfig) {
        return FileLinksApiFp(this.configuration).viewFileLink(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FormsApi - axios parameter creator
 * @export
 */
export const FormsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This is an example of how a form might look like. Note that this endpoint does not exist in the actual implementation.
         * @summary show or validate form
         * @param {ShowOrValidateFormRequest} [showOrValidateFormRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrValidateForm: async (showOrValidateFormRequest?: ShowOrValidateFormRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/example/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(showOrValidateFormRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormsApi - functional programming interface
 * @export
 */
export const FormsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FormsApiAxiosParamCreator(configuration)
    return {
        /**
         * This is an example of how a form might look like. Note that this endpoint does not exist in the actual implementation.
         * @summary show or validate form
         * @param {ShowOrValidateFormRequest} [showOrValidateFormRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showOrValidateForm(showOrValidateFormRequest?: ShowOrValidateFormRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showOrValidateForm(showOrValidateFormRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FormsApi - factory interface
 * @export
 */
export const FormsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FormsApiFp(configuration)
    return {
        /**
         * This is an example of how a form might look like. Note that this endpoint does not exist in the actual implementation.
         * @summary show or validate form
         * @param {ShowOrValidateFormRequest} [showOrValidateFormRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrValidateForm(showOrValidateFormRequest?: ShowOrValidateFormRequest, options?: any): AxiosPromise<object> {
            return localVarFp.showOrValidateForm(showOrValidateFormRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for showOrValidateForm operation in FormsApi.
 * @export
 * @interface FormsApiShowOrValidateFormRequest
 */
export interface FormsApiShowOrValidateFormRequest {
    /**
     * 
     * @type {ShowOrValidateFormRequest}
     * @memberof FormsApiShowOrValidateForm
     */
    readonly showOrValidateFormRequest?: ShowOrValidateFormRequest
}

/**
 * FormsApi - object-oriented interface
 * @export
 * @class FormsApi
 * @extends {BaseAPI}
 */
export class FormsApi extends BaseAPI {
    /**
     * This is an example of how a form might look like. Note that this endpoint does not exist in the actual implementation.
     * @summary show or validate form
     * @param {FormsApiShowOrValidateFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public showOrValidateForm(requestParameters: FormsApiShowOrValidateFormRequest = {}, options?: AxiosRequestConfig) {
        return FormsApiFp(this.configuration).showOrValidateForm(requestParameters.showOrValidateFormRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GridsApi - axios parameter creator
 * @export
 */
export const GridsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new grid applying the attributes provided in the body. The constraints applied to the grid depend on the page the grid is placed in which is why the create form end point should be used to be guided when wanting to create a grid.
         * @summary Create Grid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGrid: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/grids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Grid Create Form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gridCreateForm: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/grids/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Grid Update Form
         * @param {number} id ID of the grid being modified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gridUpdateForm: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gridUpdateForm', 'id', id)
            const localVarPath = `/api/v3/grids/{id}/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all grids matching the provided filters and being part of the selected query page. The grids returned will also depend on the permissions of the requesting user.
         * @summary List Grids
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + page: Filter grid by work package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGrids: async (offset?: number, pageSize?: number, filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/grids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the given grid by applying the attributes provided in the body.  The constraints applied to the grid depend on the page the grid is placed in which is why the create form end point should be used to be guided when wanting to update a grid.
         * @summary Update Grid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGrid: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/grids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View grid
         * @param {number} id Grid id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewGrid: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewGrid', 'id', id)
            const localVarPath = `/api/v3/grids/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GridsApi - functional programming interface
 * @export
 */
export const GridsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GridsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new grid applying the attributes provided in the body. The constraints applied to the grid depend on the page the grid is placed in which is why the create form end point should be used to be guided when wanting to create a grid.
         * @summary Create Grid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGrid(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GridModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGrid(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Grid Create Form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gridCreateForm(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gridCreateForm(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Grid Update Form
         * @param {number} id ID of the grid being modified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gridUpdateForm(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gridUpdateForm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all grids matching the provided filters and being part of the selected query page. The grids returned will also depend on the permissions of the requesting user.
         * @summary List Grids
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + page: Filter grid by work package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGrids(offset?: number, pageSize?: number, filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GridModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGrids(offset, pageSize, filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the given grid by applying the attributes provided in the body.  The constraints applied to the grid depend on the page the grid is placed in which is why the create form end point should be used to be guided when wanting to update a grid.
         * @summary Update Grid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGrid(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GridModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGrid(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View grid
         * @param {number} id Grid id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewGrid(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GridModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewGrid(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GridsApi - factory interface
 * @export
 */
export const GridsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GridsApiFp(configuration)
    return {
        /**
         * Creates a new grid applying the attributes provided in the body. The constraints applied to the grid depend on the page the grid is placed in which is why the create form end point should be used to be guided when wanting to create a grid.
         * @summary Create Grid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGrid(options?: any): AxiosPromise<GridModel> {
            return localVarFp.createGrid(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Grid Create Form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gridCreateForm(options?: any): AxiosPromise<void> {
            return localVarFp.gridCreateForm(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Grid Update Form
         * @param {number} id ID of the grid being modified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gridUpdateForm(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.gridUpdateForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all grids matching the provided filters and being part of the selected query page. The grids returned will also depend on the permissions of the requesting user.
         * @summary List Grids
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + page: Filter grid by work package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGrids(offset?: number, pageSize?: number, filters?: string, options?: any): AxiosPromise<GridModel> {
            return localVarFp.listGrids(offset, pageSize, filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the given grid by applying the attributes provided in the body.  The constraints applied to the grid depend on the page the grid is placed in which is why the create form end point should be used to be guided when wanting to update a grid.
         * @summary Update Grid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGrid(options?: any): AxiosPromise<GridModel> {
            return localVarFp.updateGrid(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View grid
         * @param {number} id Grid id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewGrid(id: number, options?: any): AxiosPromise<GridModel> {
            return localVarFp.viewGrid(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for gridUpdateForm operation in GridsApi.
 * @export
 * @interface GridsApiGridUpdateFormRequest
 */
export interface GridsApiGridUpdateFormRequest {
    /**
     * ID of the grid being modified
     * @type {number}
     * @memberof GridsApiGridUpdateForm
     */
    readonly id: number
}

/**
 * Request parameters for listGrids operation in GridsApi.
 * @export
 * @interface GridsApiListGridsRequest
 */
export interface GridsApiListGridsRequest {
    /**
     * Page number inside the requested collection.
     * @type {number}
     * @memberof GridsApiListGrids
     */
    readonly offset?: number

    /**
     * Number of elements to display per page.
     * @type {number}
     * @memberof GridsApiListGrids
     */
    readonly pageSize?: number

    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + page: Filter grid by work package
     * @type {string}
     * @memberof GridsApiListGrids
     */
    readonly filters?: string
}

/**
 * Request parameters for viewGrid operation in GridsApi.
 * @export
 * @interface GridsApiViewGridRequest
 */
export interface GridsApiViewGridRequest {
    /**
     * Grid id
     * @type {number}
     * @memberof GridsApiViewGrid
     */
    readonly id: number
}

/**
 * GridsApi - object-oriented interface
 * @export
 * @class GridsApi
 * @extends {BaseAPI}
 */
export class GridsApi extends BaseAPI {
    /**
     * Creates a new grid applying the attributes provided in the body. The constraints applied to the grid depend on the page the grid is placed in which is why the create form end point should be used to be guided when wanting to create a grid.
     * @summary Create Grid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridsApi
     */
    public createGrid(options?: AxiosRequestConfig) {
        return GridsApiFp(this.configuration).createGrid(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Grid Create Form
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridsApi
     */
    public gridCreateForm(options?: AxiosRequestConfig) {
        return GridsApiFp(this.configuration).gridCreateForm(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Grid Update Form
     * @param {GridsApiGridUpdateFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridsApi
     */
    public gridUpdateForm(requestParameters: GridsApiGridUpdateFormRequest, options?: AxiosRequestConfig) {
        return GridsApiFp(this.configuration).gridUpdateForm(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all grids matching the provided filters and being part of the selected query page. The grids returned will also depend on the permissions of the requesting user.
     * @summary List Grids
     * @param {GridsApiListGridsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridsApi
     */
    public listGrids(requestParameters: GridsApiListGridsRequest = {}, options?: AxiosRequestConfig) {
        return GridsApiFp(this.configuration).listGrids(requestParameters.offset, requestParameters.pageSize, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the given grid by applying the attributes provided in the body.  The constraints applied to the grid depend on the page the grid is placed in which is why the create form end point should be used to be guided when wanting to update a grid.
     * @summary Update Grid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridsApi
     */
    public updateGrid(options?: AxiosRequestConfig) {
        return GridsApiFp(this.configuration).updateGrid(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View grid
     * @param {GridsApiViewGridRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridsApi
     */
    public viewGrid(requestParameters: GridsApiViewGridRequest, options?: AxiosRequestConfig) {
        return GridsApiFp(this.configuration).viewGrid(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new group applying the attributes provided in the body.
         * @summary Create group
         * @param {CreateGroupRequest} [createGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (createGroupRequest?: CreateGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the group.
         * @summary Delete group
         * @param {number} id Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroup', 'id', id)
            const localVarPath = `/api/v3/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a collection of groups. The client can choose to filter the groups similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain groups, for which the requesting client has sufficient permissions (*view_members*, *manage_members*).
         * @summary List groups
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + created_at: Sort by group creation datetime  + updated_at: Sort by the time the group was updated last
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async (sortBy?: string, select?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the given group by applying the attributes provided in the body.  Please note that the `members` array provided will override the existing set of members (similar to a PUT). A client thus has to provide the complete list of members the group is to have after the PATCH even if only one member is to be added.
         * @summary Update group
         * @param {number} id Group id
         * @param {CreateGroupRequest} [createGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (id: number, createGroupRequest?: CreateGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGroup', 'id', id)
            const localVarPath = `/api/v3/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View group
         * @param {number} id Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewGroup: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewGroup', 'id', id)
            const localVarPath = `/api/v3/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new group applying the attributes provided in the body.
         * @summary Create group
         * @param {CreateGroupRequest} [createGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(createGroupRequest?: CreateGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(createGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the group.
         * @summary Delete group
         * @param {number} id Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a collection of groups. The client can choose to filter the groups similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain groups, for which the requesting client has sufficient permissions (*view_members*, *manage_members*).
         * @summary List groups
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + created_at: Sort by group creation datetime  + updated_at: Sort by the time the group was updated last
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups(sortBy?: string, select?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(sortBy, select, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the given group by applying the attributes provided in the body.  Please note that the `members` array provided will override the existing set of members (similar to a PUT). A client thus has to provide the complete list of members the group is to have after the PATCH even if only one member is to be added.
         * @summary Update group
         * @param {number} id Group id
         * @param {CreateGroupRequest} [createGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(id: number, createGroupRequest?: CreateGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(id, createGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View group
         * @param {number} id Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewGroup(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * Creates a new group applying the attributes provided in the body.
         * @summary Create group
         * @param {CreateGroupRequest} [createGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(createGroupRequest?: CreateGroupRequest, options?: any): AxiosPromise<object> {
            return localVarFp.createGroup(createGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the group.
         * @summary Delete group
         * @param {number} id Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a collection of groups. The client can choose to filter the groups similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain groups, for which the requesting client has sufficient permissions (*view_members*, *manage_members*).
         * @summary List groups
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + created_at: Sort by group creation datetime  + updated_at: Sort by the time the group was updated last
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(sortBy?: string, select?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listGroups(sortBy, select, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the given group by applying the attributes provided in the body.  Please note that the `members` array provided will override the existing set of members (similar to a PUT). A client thus has to provide the complete list of members the group is to have after the PATCH even if only one member is to be added.
         * @summary Update group
         * @param {number} id Group id
         * @param {CreateGroupRequest} [createGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(id: number, createGroupRequest?: CreateGroupRequest, options?: any): AxiosPromise<object> {
            return localVarFp.updateGroup(id, createGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View group
         * @param {number} id Group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewGroup(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.viewGroup(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createGroup operation in GroupsApi.
 * @export
 * @interface GroupsApiCreateGroupRequest
 */
export interface GroupsApiCreateGroupRequest {
    /**
     * 
     * @type {CreateGroupRequest}
     * @memberof GroupsApiCreateGroup
     */
    readonly createGroupRequest?: CreateGroupRequest
}

/**
 * Request parameters for deleteGroup operation in GroupsApi.
 * @export
 * @interface GroupsApiDeleteGroupRequest
 */
export interface GroupsApiDeleteGroupRequest {
    /**
     * Group id
     * @type {number}
     * @memberof GroupsApiDeleteGroup
     */
    readonly id: number
}

/**
 * Request parameters for listGroups operation in GroupsApi.
 * @export
 * @interface GroupsApiListGroupsRequest
 */
export interface GroupsApiListGroupsRequest {
    /**
     * JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + created_at: Sort by group creation datetime  + updated_at: Sort by the time the group was updated last
     * @type {string}
     * @memberof GroupsApiListGroups
     */
    readonly sortBy?: string

    /**
     * Comma separated list of properties to include.
     * @type {string}
     * @memberof GroupsApiListGroups
     */
    readonly select?: string
}

/**
 * Request parameters for updateGroup operation in GroupsApi.
 * @export
 * @interface GroupsApiUpdateGroupRequest
 */
export interface GroupsApiUpdateGroupRequest {
    /**
     * Group id
     * @type {number}
     * @memberof GroupsApiUpdateGroup
     */
    readonly id: number

    /**
     * 
     * @type {CreateGroupRequest}
     * @memberof GroupsApiUpdateGroup
     */
    readonly createGroupRequest?: CreateGroupRequest
}

/**
 * Request parameters for viewGroup operation in GroupsApi.
 * @export
 * @interface GroupsApiViewGroupRequest
 */
export interface GroupsApiViewGroupRequest {
    /**
     * Group id
     * @type {number}
     * @memberof GroupsApiViewGroup
     */
    readonly id: number
}

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * Creates a new group applying the attributes provided in the body.
     * @summary Create group
     * @param {GroupsApiCreateGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(requestParameters: GroupsApiCreateGroupRequest = {}, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroup(requestParameters.createGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the group.
     * @summary Delete group
     * @param {GroupsApiDeleteGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroup(requestParameters: GroupsApiDeleteGroupRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroup(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a collection of groups. The client can choose to filter the groups similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain groups, for which the requesting client has sufficient permissions (*view_members*, *manage_members*).
     * @summary List groups
     * @param {GroupsApiListGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public listGroups(requestParameters: GroupsApiListGroupsRequest = {}, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).listGroups(requestParameters.sortBy, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the given group by applying the attributes provided in the body.  Please note that the `members` array provided will override the existing set of members (similar to a PUT). A client thus has to provide the complete list of members the group is to have after the PATCH even if only one member is to be added.
     * @summary Update group
     * @param {GroupsApiUpdateGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroup(requestParameters: GroupsApiUpdateGroupRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroup(requestParameters.id, requestParameters.createGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View group
     * @param {GroupsApiViewGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public viewGroup(requestParameters: GroupsApiViewGroupRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).viewGroup(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HelpTextsApi - axios parameter creator
 * @export
 */
export const HelpTextsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all help texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllHelpTexts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/help_texts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View help text
         * @param {number} id Help text id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewHelpText: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewHelpText', 'id', id)
            const localVarPath = `/api/v3/help_texts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelpTextsApi - functional programming interface
 * @export
 */
export const HelpTextsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelpTextsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all help texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllHelpTexts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllHelpTexts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View help text
         * @param {number} id Help text id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewHelpText(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewHelpText(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HelpTextsApi - factory interface
 * @export
 */
export const HelpTextsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelpTextsApiFp(configuration)
    return {
        /**
         * 
         * @summary List all help texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllHelpTexts(options?: any): AxiosPromise<object> {
            return localVarFp.listAllHelpTexts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View help text
         * @param {number} id Help text id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewHelpText(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.viewHelpText(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewHelpText operation in HelpTextsApi.
 * @export
 * @interface HelpTextsApiViewHelpTextRequest
 */
export interface HelpTextsApiViewHelpTextRequest {
    /**
     * Help text id
     * @type {number}
     * @memberof HelpTextsApiViewHelpText
     */
    readonly id: number
}

/**
 * HelpTextsApi - object-oriented interface
 * @export
 * @class HelpTextsApi
 * @extends {BaseAPI}
 */
export class HelpTextsApi extends BaseAPI {
    /**
     * 
     * @summary List all help texts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpTextsApi
     */
    public listAllHelpTexts(options?: AxiosRequestConfig) {
        return HelpTextsApiFp(this.configuration).listAllHelpTexts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View help text
     * @param {HelpTextsApiViewHelpTextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpTextsApi
     */
    public viewHelpText(requestParameters: HelpTextsApiViewHelpTextRequest, options?: AxiosRequestConfig) {
        return HelpTextsApiFp(this.configuration).viewHelpText(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MembershipsApi - axios parameter creator
 * @export
 */
export const MembershipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of projects in which a membership can be created in. The list contains all projects in which the user issuing the request has the manage members permissions.
         * @summary Available projects for memberships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableProjectsForMemberships: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/memberships/available_projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new membership applying the attributes provided in the body.  You can use the form and schema to retrieve the valid attribute values and by that be guided towards successful creation.  By providing a `notificationMessage` within the `_meta` block of the payload, the client can include a customized message to the user of the newly created membership. In case of a group, the message will be sent to every user belonging to the group.  By including `{ \"sendNotifications\": false }` within the `_meta` block of the payload, no notifications is send out at all.
         * @summary Create membership
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMembership: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the membership.
         * @summary Delete membership
         * @param {number} id Membership id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMembership: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteMembership', 'id', id)
            const localVarPath = `/api/v3/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a collection of memberships. The client can choose to filter the memberships similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain memberships, for which the requesting client has sufficient permissions (*view_members*, *manage_members*).
         * @summary List memberships
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + any_name_attribute: filters memberships based on the name of the principal. All possible name variants (and also email and login) are searched.  + blocked: reduces the result set to all memberships that are temporarily blocked or that are not blocked temporarily.  + group: filters memberships based on the name of a group. The group however is not the principal used for filtering. Rather, the memberships of the group are used as the filter values.  + name: filters memberships based on the name of the principal. Note that only the name is used which depends on a setting in the OpenProject instance.  + principal: filters memberships based on the id of the principal.  + project: filters memberships based on the id of the project.  + role: filters memberships based on the id of any role assigned to the membership.  + status: filters memberships based on the status of the principal.  + created_at: filters memberships based on the time the membership was created.  + updated_at: filters memberships based on the time the membership was updated last.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + name: Sort by the name of the principal. Note that this depends on the setting for how the name is to be displayed at least for users.  + email: Sort by the email address of the principal. Groups and principal users, which do not have an email, are sorted last.  + status: Sort by the status of the principal. Groups and principal users, which do not have a status, are sorted together with the active users.  + created_at: Sort by membership creation datetime  + updated_at: Sort by the time the membership was updated last
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemberships: async (filters?: string, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Membership create form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membershipCreateForm: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/memberships/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Membership update form
         * @param {number} id Membership id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membershipUpdateForm: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('membershipUpdateForm', 'id', id)
            const localVarPath = `/api/v3/memberships/{id}/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the given membership by applying the attributes provided in the body.  By providing a `notificationMessage` within the `_meta` block of the payload, the client can include a customized message to the user of the updated membership. In case of a group, the message will be sent to every user belonging to the group.  By including `{ \"sendNotifications\": false }` within the `_meta` block of the payload, no notifications is send out at all.
         * @summary Update membership
         * @param {number} id Membership id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMembership: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMembership', 'id', id)
            const localVarPath = `/api/v3/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View membership
         * @param {number} id Membership id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewMembership: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewMembership', 'id', id)
            const localVarPath = `/api/v3/memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View membership schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewMembershipSchema: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/memberships/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembershipsApi - functional programming interface
 * @export
 */
export const MembershipsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembershipsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a list of projects in which a membership can be created in. The list contains all projects in which the user issuing the request has the manage members permissions.
         * @summary Available projects for memberships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableProjectsForMemberships(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableProjectsForMemberships(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new membership applying the attributes provided in the body.  You can use the form and schema to retrieve the valid attribute values and by that be guided towards successful creation.  By providing a `notificationMessage` within the `_meta` block of the payload, the client can include a customized message to the user of the newly created membership. In case of a group, the message will be sent to every user belonging to the group.  By including `{ \"sendNotifications\": false }` within the `_meta` block of the payload, no notifications is send out at all.
         * @summary Create membership
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMembership(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMembership(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the membership.
         * @summary Delete membership
         * @param {number} id Membership id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMembership(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMembership(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a collection of memberships. The client can choose to filter the memberships similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain memberships, for which the requesting client has sufficient permissions (*view_members*, *manage_members*).
         * @summary List memberships
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + any_name_attribute: filters memberships based on the name of the principal. All possible name variants (and also email and login) are searched.  + blocked: reduces the result set to all memberships that are temporarily blocked or that are not blocked temporarily.  + group: filters memberships based on the name of a group. The group however is not the principal used for filtering. Rather, the memberships of the group are used as the filter values.  + name: filters memberships based on the name of the principal. Note that only the name is used which depends on a setting in the OpenProject instance.  + principal: filters memberships based on the id of the principal.  + project: filters memberships based on the id of the project.  + role: filters memberships based on the id of any role assigned to the membership.  + status: filters memberships based on the status of the principal.  + created_at: filters memberships based on the time the membership was created.  + updated_at: filters memberships based on the time the membership was updated last.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + name: Sort by the name of the principal. Note that this depends on the setting for how the name is to be displayed at least for users.  + email: Sort by the email address of the principal. Groups and principal users, which do not have an email, are sorted last.  + status: Sort by the status of the principal. Groups and principal users, which do not have a status, are sorted together with the active users.  + created_at: Sort by membership creation datetime  + updated_at: Sort by the time the membership was updated last
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMemberships(filters?: string, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMemberships(filters, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Membership create form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membershipCreateForm(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membershipCreateForm(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Membership update form
         * @param {number} id Membership id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membershipUpdateForm(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membershipUpdateForm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the given membership by applying the attributes provided in the body.  By providing a `notificationMessage` within the `_meta` block of the payload, the client can include a customized message to the user of the updated membership. In case of a group, the message will be sent to every user belonging to the group.  By including `{ \"sendNotifications\": false }` within the `_meta` block of the payload, no notifications is send out at all.
         * @summary Update membership
         * @param {number} id Membership id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMembership(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMembership(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View membership
         * @param {number} id Membership id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewMembership(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewMembership(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View membership schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewMembershipSchema(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewMembershipSchema(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MembershipsApi - factory interface
 * @export
 */
export const MembershipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembershipsApiFp(configuration)
    return {
        /**
         * Gets a list of projects in which a membership can be created in. The list contains all projects in which the user issuing the request has the manage members permissions.
         * @summary Available projects for memberships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableProjectsForMemberships(options?: any): AxiosPromise<object> {
            return localVarFp.availableProjectsForMemberships(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new membership applying the attributes provided in the body.  You can use the form and schema to retrieve the valid attribute values and by that be guided towards successful creation.  By providing a `notificationMessage` within the `_meta` block of the payload, the client can include a customized message to the user of the newly created membership. In case of a group, the message will be sent to every user belonging to the group.  By including `{ \"sendNotifications\": false }` within the `_meta` block of the payload, no notifications is send out at all.
         * @summary Create membership
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMembership(options?: any): AxiosPromise<object> {
            return localVarFp.createMembership(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the membership.
         * @summary Delete membership
         * @param {number} id Membership id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMembership(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMembership(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a collection of memberships. The client can choose to filter the memberships similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain memberships, for which the requesting client has sufficient permissions (*view_members*, *manage_members*).
         * @summary List memberships
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + any_name_attribute: filters memberships based on the name of the principal. All possible name variants (and also email and login) are searched.  + blocked: reduces the result set to all memberships that are temporarily blocked or that are not blocked temporarily.  + group: filters memberships based on the name of a group. The group however is not the principal used for filtering. Rather, the memberships of the group are used as the filter values.  + name: filters memberships based on the name of the principal. Note that only the name is used which depends on a setting in the OpenProject instance.  + principal: filters memberships based on the id of the principal.  + project: filters memberships based on the id of the project.  + role: filters memberships based on the id of any role assigned to the membership.  + status: filters memberships based on the status of the principal.  + created_at: filters memberships based on the time the membership was created.  + updated_at: filters memberships based on the time the membership was updated last.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + name: Sort by the name of the principal. Note that this depends on the setting for how the name is to be displayed at least for users.  + email: Sort by the email address of the principal. Groups and principal users, which do not have an email, are sorted last.  + status: Sort by the status of the principal. Groups and principal users, which do not have a status, are sorted together with the active users.  + created_at: Sort by membership creation datetime  + updated_at: Sort by the time the membership was updated last
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemberships(filters?: string, sortBy?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listMemberships(filters, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Membership create form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membershipCreateForm(options?: any): AxiosPromise<void> {
            return localVarFp.membershipCreateForm(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Membership update form
         * @param {number} id Membership id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membershipUpdateForm(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.membershipUpdateForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the given membership by applying the attributes provided in the body.  By providing a `notificationMessage` within the `_meta` block of the payload, the client can include a customized message to the user of the updated membership. In case of a group, the message will be sent to every user belonging to the group.  By including `{ \"sendNotifications\": false }` within the `_meta` block of the payload, no notifications is send out at all.
         * @summary Update membership
         * @param {number} id Membership id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMembership(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.updateMembership(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View membership
         * @param {number} id Membership id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewMembership(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.viewMembership(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View membership schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewMembershipSchema(options?: any): AxiosPromise<object> {
            return localVarFp.viewMembershipSchema(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteMembership operation in MembershipsApi.
 * @export
 * @interface MembershipsApiDeleteMembershipRequest
 */
export interface MembershipsApiDeleteMembershipRequest {
    /**
     * Membership id
     * @type {number}
     * @memberof MembershipsApiDeleteMembership
     */
    readonly id: number
}

/**
 * Request parameters for listMemberships operation in MembershipsApi.
 * @export
 * @interface MembershipsApiListMembershipsRequest
 */
export interface MembershipsApiListMembershipsRequest {
    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + any_name_attribute: filters memberships based on the name of the principal. All possible name variants (and also email and login) are searched.  + blocked: reduces the result set to all memberships that are temporarily blocked or that are not blocked temporarily.  + group: filters memberships based on the name of a group. The group however is not the principal used for filtering. Rather, the memberships of the group are used as the filter values.  + name: filters memberships based on the name of the principal. Note that only the name is used which depends on a setting in the OpenProject instance.  + principal: filters memberships based on the id of the principal.  + project: filters memberships based on the id of the project.  + role: filters memberships based on the id of any role assigned to the membership.  + status: filters memberships based on the status of the principal.  + created_at: filters memberships based on the time the membership was created.  + updated_at: filters memberships based on the time the membership was updated last.
     * @type {string}
     * @memberof MembershipsApiListMemberships
     */
    readonly filters?: string

    /**
     * JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + name: Sort by the name of the principal. Note that this depends on the setting for how the name is to be displayed at least for users.  + email: Sort by the email address of the principal. Groups and principal users, which do not have an email, are sorted last.  + status: Sort by the status of the principal. Groups and principal users, which do not have a status, are sorted together with the active users.  + created_at: Sort by membership creation datetime  + updated_at: Sort by the time the membership was updated last
     * @type {string}
     * @memberof MembershipsApiListMemberships
     */
    readonly sortBy?: string
}

/**
 * Request parameters for membershipUpdateForm operation in MembershipsApi.
 * @export
 * @interface MembershipsApiMembershipUpdateFormRequest
 */
export interface MembershipsApiMembershipUpdateFormRequest {
    /**
     * Membership id
     * @type {number}
     * @memberof MembershipsApiMembershipUpdateForm
     */
    readonly id: number
}

/**
 * Request parameters for updateMembership operation in MembershipsApi.
 * @export
 * @interface MembershipsApiUpdateMembershipRequest
 */
export interface MembershipsApiUpdateMembershipRequest {
    /**
     * Membership id
     * @type {number}
     * @memberof MembershipsApiUpdateMembership
     */
    readonly id: number
}

/**
 * Request parameters for viewMembership operation in MembershipsApi.
 * @export
 * @interface MembershipsApiViewMembershipRequest
 */
export interface MembershipsApiViewMembershipRequest {
    /**
     * Membership id
     * @type {number}
     * @memberof MembershipsApiViewMembership
     */
    readonly id: number
}

/**
 * MembershipsApi - object-oriented interface
 * @export
 * @class MembershipsApi
 * @extends {BaseAPI}
 */
export class MembershipsApi extends BaseAPI {
    /**
     * Gets a list of projects in which a membership can be created in. The list contains all projects in which the user issuing the request has the manage members permissions.
     * @summary Available projects for memberships
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipsApi
     */
    public availableProjectsForMemberships(options?: AxiosRequestConfig) {
        return MembershipsApiFp(this.configuration).availableProjectsForMemberships(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new membership applying the attributes provided in the body.  You can use the form and schema to retrieve the valid attribute values and by that be guided towards successful creation.  By providing a `notificationMessage` within the `_meta` block of the payload, the client can include a customized message to the user of the newly created membership. In case of a group, the message will be sent to every user belonging to the group.  By including `{ \"sendNotifications\": false }` within the `_meta` block of the payload, no notifications is send out at all.
     * @summary Create membership
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipsApi
     */
    public createMembership(options?: AxiosRequestConfig) {
        return MembershipsApiFp(this.configuration).createMembership(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the membership.
     * @summary Delete membership
     * @param {MembershipsApiDeleteMembershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipsApi
     */
    public deleteMembership(requestParameters: MembershipsApiDeleteMembershipRequest, options?: AxiosRequestConfig) {
        return MembershipsApiFp(this.configuration).deleteMembership(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a collection of memberships. The client can choose to filter the memberships similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain memberships, for which the requesting client has sufficient permissions (*view_members*, *manage_members*).
     * @summary List memberships
     * @param {MembershipsApiListMembershipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipsApi
     */
    public listMemberships(requestParameters: MembershipsApiListMembershipsRequest = {}, options?: AxiosRequestConfig) {
        return MembershipsApiFp(this.configuration).listMemberships(requestParameters.filters, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Membership create form
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipsApi
     */
    public membershipCreateForm(options?: AxiosRequestConfig) {
        return MembershipsApiFp(this.configuration).membershipCreateForm(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Membership update form
     * @param {MembershipsApiMembershipUpdateFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipsApi
     */
    public membershipUpdateForm(requestParameters: MembershipsApiMembershipUpdateFormRequest, options?: AxiosRequestConfig) {
        return MembershipsApiFp(this.configuration).membershipUpdateForm(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the given membership by applying the attributes provided in the body.  By providing a `notificationMessage` within the `_meta` block of the payload, the client can include a customized message to the user of the updated membership. In case of a group, the message will be sent to every user belonging to the group.  By including `{ \"sendNotifications\": false }` within the `_meta` block of the payload, no notifications is send out at all.
     * @summary Update membership
     * @param {MembershipsApiUpdateMembershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipsApi
     */
    public updateMembership(requestParameters: MembershipsApiUpdateMembershipRequest, options?: AxiosRequestConfig) {
        return MembershipsApiFp(this.configuration).updateMembership(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View membership
     * @param {MembershipsApiViewMembershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipsApi
     */
    public viewMembership(requestParameters: MembershipsApiViewMembershipRequest, options?: AxiosRequestConfig) {
        return MembershipsApiFp(this.configuration).viewMembership(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View membership schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembershipsApi
     */
    public viewMembershipSchema(options?: AxiosRequestConfig) {
        return MembershipsApiFp(this.configuration).viewMembershipSchema(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NewsApi - axios parameter creator
 * @export
 */
export const NewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists news. The news returned depend on the provided parameters and also on the requesting user\'s permissions.
         * @summary List News
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + created_at: Sort by news creation datetime
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + project_id: Filter news by project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNews: async (offset?: number, pageSize?: number, sortBy?: string, filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View news
         * @param {number} id news id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewNews: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewNews', 'id', id)
            const localVarPath = `/api/v3/news/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NewsApi - functional programming interface
 * @export
 */
export const NewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NewsApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists news. The news returned depend on the provided parameters and also on the requesting user\'s permissions.
         * @summary List News
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + created_at: Sort by news creation datetime
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + project_id: Filter news by project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNews(offset?: number, pageSize?: number, sortBy?: string, filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNews(offset, pageSize, sortBy, filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View news
         * @param {number} id news id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewNews(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewNews(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NewsApi - factory interface
 * @export
 */
export const NewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NewsApiFp(configuration)
    return {
        /**
         * Lists news. The news returned depend on the provided parameters and also on the requesting user\'s permissions.
         * @summary List News
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + created_at: Sort by news creation datetime
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + project_id: Filter news by project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNews(offset?: number, pageSize?: number, sortBy?: string, filters?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listNews(offset, pageSize, sortBy, filters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View news
         * @param {number} id news id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewNews(id: number, options?: any): AxiosPromise<NewsModel> {
            return localVarFp.viewNews(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listNews operation in NewsApi.
 * @export
 * @interface NewsApiListNewsRequest
 */
export interface NewsApiListNewsRequest {
    /**
     * Page number inside the requested collection.
     * @type {number}
     * @memberof NewsApiListNews
     */
    readonly offset?: number

    /**
     * Number of elements to display per page.
     * @type {number}
     * @memberof NewsApiListNews
     */
    readonly pageSize?: number

    /**
     * JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + created_at: Sort by news creation datetime
     * @type {string}
     * @memberof NewsApiListNews
     */
    readonly sortBy?: string

    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + project_id: Filter news by project
     * @type {string}
     * @memberof NewsApiListNews
     */
    readonly filters?: string
}

/**
 * Request parameters for viewNews operation in NewsApi.
 * @export
 * @interface NewsApiViewNewsRequest
 */
export interface NewsApiViewNewsRequest {
    /**
     * news id
     * @type {number}
     * @memberof NewsApiViewNews
     */
    readonly id: number
}

/**
 * NewsApi - object-oriented interface
 * @export
 * @class NewsApi
 * @extends {BaseAPI}
 */
export class NewsApi extends BaseAPI {
    /**
     * Lists news. The news returned depend on the provided parameters and also on the requesting user\'s permissions.
     * @summary List News
     * @param {NewsApiListNewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApi
     */
    public listNews(requestParameters: NewsApiListNewsRequest = {}, options?: AxiosRequestConfig) {
        return NewsApiFp(this.configuration).listNews(requestParameters.offset, requestParameters.pageSize, requestParameters.sortBy, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View news
     * @param {NewsApiViewNewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApi
     */
    public viewNews(requestParameters: NewsApiViewNewsRequest, options?: AxiosRequestConfig) {
        return NewsApiFp(this.configuration).viewNews(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the collection of available in-app notifications. The notifications returned depend on the provided parameters and also on the requesting user\'s permissions.  Contrary to most collections, this one also links to and embeds schemas for the `details` properties of the notifications returned. This is an optimization. Clients will receive the information necessary to display the various types of details that a notification can carry.
         * @summary Get notification collection
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + reason: Sort by notification reason  + readIAN: Sort by read status
         * @param {string} [groupBy] string specifying group_by criteria.  + reason: Group by notification reason  + project: Sort by associated project
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Filter by primary key  + project: Filter by the project the notification was created in  + readIAN: Filter by read status  + reason: Filter by the reason, e.g. \&#39;mentioned\&#39; or \&#39;assigned\&#39; the notification was created because of  + resourceId: Filter by the id of the resource the notification was created for. Ideally used together with the &#x60;resourceType&#x60; filter.  + resourceType: Filter by the type of the resource the notification was created for. Ideally used together with the &#x60;resourceId&#x60; filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotifications: async (offset?: number, pageSize?: number, sortBy?: string, groupBy?: string, filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks the given notification as read.
         * @summary Read notification
         * @param {number} id notification id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readNotification: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readNotification', 'id', id)
            const localVarPath = `/api/v3/notifications/{id}/read_ian`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks the whole notification collection as read. The collection contains only elements the authenticated user can see, and can be further reduced with filters.
         * @summary Read all notifications
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Filter by primary key  + project: Filter by the project the notification was created in  + reason: Filter by the reason, e.g. \&#39;mentioned\&#39; or \&#39;assigned\&#39; the notification was created because of  + resourceId: Filter by the id of the resource the notification was created for. Ideally used together with the   &#x60;resourceType&#x60; filter.  + resourceType: Filter by the type of the resource the notification was created for. Ideally used together with   the &#x60;resourceId&#x60; filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readNotifications: async (filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/notifications/read_ian`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks the given notification as unread.
         * @summary Unread notification
         * @param {number} id notification id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unreadNotification: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unreadNotification', 'id', id)
            const localVarPath = `/api/v3/notifications/{id}/unread_ian`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks the whole notification collection as unread. The collection contains only elements the authenticated user can see, and can be further reduced with filters.
         * @summary Unread all notifications
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Filter by primary key  + project: Filter by the project the notification was created in  + reason: Filter by the reason, e.g. \&#39;mentioned\&#39; or \&#39;assigned\&#39; the notification was created because of  + resourceId: Filter by the id of the resource the notification was created for. Ideally used together with the   &#x60;resourceType&#x60; filter.  + resourceType: Filter by the type of the resource the notification was created for. Ideally used together with   the &#x60;resourceId&#x60; filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unreadNotifications: async (filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/notifications/unread_ian`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the notification identified by the notification id.
         * @summary Get the notification
         * @param {number} id notification id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewNotification: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewNotification', 'id', id)
            const localVarPath = `/api/v3/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an individual detail of a notification identified by the notification id and the id of the detail.
         * @summary Get a notification detail
         * @param {number} notificationId notification id
         * @param {number} id detail id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewNotificationDetail: async (notificationId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('viewNotificationDetail', 'notificationId', notificationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewNotificationDetail', 'id', id)
            const localVarPath = `/api/v3/notifications/{notification_id}/details/{id}`
                .replace(`{${"notification_id"}}`, encodeURIComponent(String(notificationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the collection of available in-app notifications. The notifications returned depend on the provided parameters and also on the requesting user\'s permissions.  Contrary to most collections, this one also links to and embeds schemas for the `details` properties of the notifications returned. This is an optimization. Clients will receive the information necessary to display the various types of details that a notification can carry.
         * @summary Get notification collection
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + reason: Sort by notification reason  + readIAN: Sort by read status
         * @param {string} [groupBy] string specifying group_by criteria.  + reason: Group by notification reason  + project: Sort by associated project
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Filter by primary key  + project: Filter by the project the notification was created in  + readIAN: Filter by read status  + reason: Filter by the reason, e.g. \&#39;mentioned\&#39; or \&#39;assigned\&#39; the notification was created because of  + resourceId: Filter by the id of the resource the notification was created for. Ideally used together with the &#x60;resourceType&#x60; filter.  + resourceType: Filter by the type of the resource the notification was created for. Ideally used together with the &#x60;resourceId&#x60; filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNotifications(offset?: number, pageSize?: number, sortBy?: string, groupBy?: string, filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationCollectionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNotifications(offset, pageSize, sortBy, groupBy, filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks the given notification as read.
         * @summary Read notification
         * @param {number} id notification id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readNotification(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readNotification(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks the whole notification collection as read. The collection contains only elements the authenticated user can see, and can be further reduced with filters.
         * @summary Read all notifications
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Filter by primary key  + project: Filter by the project the notification was created in  + reason: Filter by the reason, e.g. \&#39;mentioned\&#39; or \&#39;assigned\&#39; the notification was created because of  + resourceId: Filter by the id of the resource the notification was created for. Ideally used together with the   &#x60;resourceType&#x60; filter.  + resourceType: Filter by the type of the resource the notification was created for. Ideally used together with   the &#x60;resourceId&#x60; filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readNotifications(filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readNotifications(filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks the given notification as unread.
         * @summary Unread notification
         * @param {number} id notification id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unreadNotification(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unreadNotification(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks the whole notification collection as unread. The collection contains only elements the authenticated user can see, and can be further reduced with filters.
         * @summary Unread all notifications
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Filter by primary key  + project: Filter by the project the notification was created in  + reason: Filter by the reason, e.g. \&#39;mentioned\&#39; or \&#39;assigned\&#39; the notification was created because of  + resourceId: Filter by the id of the resource the notification was created for. Ideally used together with the   &#x60;resourceType&#x60; filter.  + resourceType: Filter by the type of the resource the notification was created for. Ideally used together with   the &#x60;resourceId&#x60; filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unreadNotifications(filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unreadNotifications(filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the notification identified by the notification id.
         * @summary Get the notification
         * @param {number} id notification id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewNotification(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewNotification(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an individual detail of a notification identified by the notification id and the id of the detail.
         * @summary Get a notification detail
         * @param {number} notificationId notification id
         * @param {number} id detail id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewNotificationDetail(notificationId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValuesPropertyModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewNotificationDetail(notificationId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * Returns the collection of available in-app notifications. The notifications returned depend on the provided parameters and also on the requesting user\'s permissions.  Contrary to most collections, this one also links to and embeds schemas for the `details` properties of the notifications returned. This is an optimization. Clients will receive the information necessary to display the various types of details that a notification can carry.
         * @summary Get notification collection
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + reason: Sort by notification reason  + readIAN: Sort by read status
         * @param {string} [groupBy] string specifying group_by criteria.  + reason: Group by notification reason  + project: Sort by associated project
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Filter by primary key  + project: Filter by the project the notification was created in  + readIAN: Filter by read status  + reason: Filter by the reason, e.g. \&#39;mentioned\&#39; or \&#39;assigned\&#39; the notification was created because of  + resourceId: Filter by the id of the resource the notification was created for. Ideally used together with the &#x60;resourceType&#x60; filter.  + resourceType: Filter by the type of the resource the notification was created for. Ideally used together with the &#x60;resourceId&#x60; filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotifications(offset?: number, pageSize?: number, sortBy?: string, groupBy?: string, filters?: string, options?: any): AxiosPromise<NotificationCollectionModel> {
            return localVarFp.listNotifications(offset, pageSize, sortBy, groupBy, filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks the given notification as read.
         * @summary Read notification
         * @param {number} id notification id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readNotification(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.readNotification(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks the whole notification collection as read. The collection contains only elements the authenticated user can see, and can be further reduced with filters.
         * @summary Read all notifications
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Filter by primary key  + project: Filter by the project the notification was created in  + reason: Filter by the reason, e.g. \&#39;mentioned\&#39; or \&#39;assigned\&#39; the notification was created because of  + resourceId: Filter by the id of the resource the notification was created for. Ideally used together with the   &#x60;resourceType&#x60; filter.  + resourceType: Filter by the type of the resource the notification was created for. Ideally used together with   the &#x60;resourceId&#x60; filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readNotifications(filters?: string, options?: any): AxiosPromise<void> {
            return localVarFp.readNotifications(filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks the given notification as unread.
         * @summary Unread notification
         * @param {number} id notification id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unreadNotification(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.unreadNotification(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks the whole notification collection as unread. The collection contains only elements the authenticated user can see, and can be further reduced with filters.
         * @summary Unread all notifications
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Filter by primary key  + project: Filter by the project the notification was created in  + reason: Filter by the reason, e.g. \&#39;mentioned\&#39; or \&#39;assigned\&#39; the notification was created because of  + resourceId: Filter by the id of the resource the notification was created for. Ideally used together with the   &#x60;resourceType&#x60; filter.  + resourceType: Filter by the type of the resource the notification was created for. Ideally used together with   the &#x60;resourceId&#x60; filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unreadNotifications(filters?: string, options?: any): AxiosPromise<void> {
            return localVarFp.unreadNotifications(filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the notification identified by the notification id.
         * @summary Get the notification
         * @param {number} id notification id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewNotification(id: number, options?: any): AxiosPromise<NotificationModel> {
            return localVarFp.viewNotification(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an individual detail of a notification identified by the notification id and the id of the detail.
         * @summary Get a notification detail
         * @param {number} notificationId notification id
         * @param {number} id detail id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewNotificationDetail(notificationId: number, id: number, options?: any): AxiosPromise<ValuesPropertyModel> {
            return localVarFp.viewNotificationDetail(notificationId, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listNotifications operation in NotificationsApi.
 * @export
 * @interface NotificationsApiListNotificationsRequest
 */
export interface NotificationsApiListNotificationsRequest {
    /**
     * Page number inside the requested collection.
     * @type {number}
     * @memberof NotificationsApiListNotifications
     */
    readonly offset?: number

    /**
     * Number of elements to display per page.
     * @type {number}
     * @memberof NotificationsApiListNotifications
     */
    readonly pageSize?: number

    /**
     * JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + reason: Sort by notification reason  + readIAN: Sort by read status
     * @type {string}
     * @memberof NotificationsApiListNotifications
     */
    readonly sortBy?: string

    /**
     * string specifying group_by criteria.  + reason: Group by notification reason  + project: Sort by associated project
     * @type {string}
     * @memberof NotificationsApiListNotifications
     */
    readonly groupBy?: string

    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Filter by primary key  + project: Filter by the project the notification was created in  + readIAN: Filter by read status  + reason: Filter by the reason, e.g. \&#39;mentioned\&#39; or \&#39;assigned\&#39; the notification was created because of  + resourceId: Filter by the id of the resource the notification was created for. Ideally used together with the &#x60;resourceType&#x60; filter.  + resourceType: Filter by the type of the resource the notification was created for. Ideally used together with the &#x60;resourceId&#x60; filter.
     * @type {string}
     * @memberof NotificationsApiListNotifications
     */
    readonly filters?: string
}

/**
 * Request parameters for readNotification operation in NotificationsApi.
 * @export
 * @interface NotificationsApiReadNotificationRequest
 */
export interface NotificationsApiReadNotificationRequest {
    /**
     * notification id
     * @type {number}
     * @memberof NotificationsApiReadNotification
     */
    readonly id: number
}

/**
 * Request parameters for readNotifications operation in NotificationsApi.
 * @export
 * @interface NotificationsApiReadNotificationsRequest
 */
export interface NotificationsApiReadNotificationsRequest {
    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Filter by primary key  + project: Filter by the project the notification was created in  + reason: Filter by the reason, e.g. \&#39;mentioned\&#39; or \&#39;assigned\&#39; the notification was created because of  + resourceId: Filter by the id of the resource the notification was created for. Ideally used together with the   &#x60;resourceType&#x60; filter.  + resourceType: Filter by the type of the resource the notification was created for. Ideally used together with   the &#x60;resourceId&#x60; filter.
     * @type {string}
     * @memberof NotificationsApiReadNotifications
     */
    readonly filters?: string
}

/**
 * Request parameters for unreadNotification operation in NotificationsApi.
 * @export
 * @interface NotificationsApiUnreadNotificationRequest
 */
export interface NotificationsApiUnreadNotificationRequest {
    /**
     * notification id
     * @type {number}
     * @memberof NotificationsApiUnreadNotification
     */
    readonly id: number
}

/**
 * Request parameters for unreadNotifications operation in NotificationsApi.
 * @export
 * @interface NotificationsApiUnreadNotificationsRequest
 */
export interface NotificationsApiUnreadNotificationsRequest {
    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: Filter by primary key  + project: Filter by the project the notification was created in  + reason: Filter by the reason, e.g. \&#39;mentioned\&#39; or \&#39;assigned\&#39; the notification was created because of  + resourceId: Filter by the id of the resource the notification was created for. Ideally used together with the   &#x60;resourceType&#x60; filter.  + resourceType: Filter by the type of the resource the notification was created for. Ideally used together with   the &#x60;resourceId&#x60; filter.
     * @type {string}
     * @memberof NotificationsApiUnreadNotifications
     */
    readonly filters?: string
}

/**
 * Request parameters for viewNotification operation in NotificationsApi.
 * @export
 * @interface NotificationsApiViewNotificationRequest
 */
export interface NotificationsApiViewNotificationRequest {
    /**
     * notification id
     * @type {number}
     * @memberof NotificationsApiViewNotification
     */
    readonly id: number
}

/**
 * Request parameters for viewNotificationDetail operation in NotificationsApi.
 * @export
 * @interface NotificationsApiViewNotificationDetailRequest
 */
export interface NotificationsApiViewNotificationDetailRequest {
    /**
     * notification id
     * @type {number}
     * @memberof NotificationsApiViewNotificationDetail
     */
    readonly notificationId: number

    /**
     * detail id
     * @type {number}
     * @memberof NotificationsApiViewNotificationDetail
     */
    readonly id: number
}

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * Returns the collection of available in-app notifications. The notifications returned depend on the provided parameters and also on the requesting user\'s permissions.  Contrary to most collections, this one also links to and embeds schemas for the `details` properties of the notifications returned. This is an optimization. Clients will receive the information necessary to display the various types of details that a notification can carry.
     * @summary Get notification collection
     * @param {NotificationsApiListNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public listNotifications(requestParameters: NotificationsApiListNotificationsRequest = {}, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).listNotifications(requestParameters.offset, requestParameters.pageSize, requestParameters.sortBy, requestParameters.groupBy, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks the given notification as read.
     * @summary Read notification
     * @param {NotificationsApiReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public readNotification(requestParameters: NotificationsApiReadNotificationRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).readNotification(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks the whole notification collection as read. The collection contains only elements the authenticated user can see, and can be further reduced with filters.
     * @summary Read all notifications
     * @param {NotificationsApiReadNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public readNotifications(requestParameters: NotificationsApiReadNotificationsRequest = {}, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).readNotifications(requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks the given notification as unread.
     * @summary Unread notification
     * @param {NotificationsApiUnreadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public unreadNotification(requestParameters: NotificationsApiUnreadNotificationRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).unreadNotification(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks the whole notification collection as unread. The collection contains only elements the authenticated user can see, and can be further reduced with filters.
     * @summary Unread all notifications
     * @param {NotificationsApiUnreadNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public unreadNotifications(requestParameters: NotificationsApiUnreadNotificationsRequest = {}, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).unreadNotifications(requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the notification identified by the notification id.
     * @summary Get the notification
     * @param {NotificationsApiViewNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public viewNotification(requestParameters: NotificationsApiViewNotificationRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).viewNotification(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an individual detail of a notification identified by the notification id and the id of the detail.
     * @summary Get a notification detail
     * @param {NotificationsApiViewNotificationDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public viewNotificationDetail(requestParameters: NotificationsApiViewNotificationDetailRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).viewNotificationDetail(requestParameters.notificationId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PostsApi - axios parameter creator
 * @export
 */
export const PostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an individual post as identified by the id parameter
         * @summary View Post
         * @param {number} id Post\&#39;s identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewPost: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewPost', 'id', id)
            const localVarPath = `/api/v3/posts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostsApi - functional programming interface
 * @export
 */
export const PostsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an individual post as identified by the id parameter
         * @summary View Post
         * @param {number} id Post\&#39;s identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewPost(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PostsApi - factory interface
 * @export
 */
export const PostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostsApiFp(configuration)
    return {
        /**
         * Retrieve an individual post as identified by the id parameter
         * @summary View Post
         * @param {number} id Post\&#39;s identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewPost(id: number, options?: any): AxiosPromise<PostModel> {
            return localVarFp.viewPost(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewPost operation in PostsApi.
 * @export
 * @interface PostsApiViewPostRequest
 */
export interface PostsApiViewPostRequest {
    /**
     * Post\&#39;s identifier
     * @type {number}
     * @memberof PostsApiViewPost
     */
    readonly id: number
}

/**
 * PostsApi - object-oriented interface
 * @export
 * @class PostsApi
 * @extends {BaseAPI}
 */
export class PostsApi extends BaseAPI {
    /**
     * Retrieve an individual post as identified by the id parameter
     * @summary View Post
     * @param {PostsApiViewPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public viewPost(requestParameters: PostsApiViewPostRequest, options?: AxiosRequestConfig) {
        return PostsApiFp(this.configuration).viewPost(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PreviewingApi - axios parameter creator
 * @export
 */
export const PreviewingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Preview Markdown document
         * @param {string} [context] API-Link to the context in which the rendering occurs, for example a specific work package.  If left out only context-agnostic rendering takes place. Please note that OpenProject features markdown-extensions on top of the extensions GitHub Flavored Markdown (gfm) already provides that can only work given a context (e.g. display attached images).  **Supported contexts:**  * &#x60;/api/v3/work_packages/{id}&#x60; - an existing work package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewMarkdownDocument: async (context?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/render/markdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Preview plain document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewPlainDocument: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/render/plain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PreviewingApi - functional programming interface
 * @export
 */
export const PreviewingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PreviewingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Preview Markdown document
         * @param {string} [context] API-Link to the context in which the rendering occurs, for example a specific work package.  If left out only context-agnostic rendering takes place. Please note that OpenProject features markdown-extensions on top of the extensions GitHub Flavored Markdown (gfm) already provides that can only work given a context (e.g. display attached images).  **Supported contexts:**  * &#x60;/api/v3/work_packages/{id}&#x60; - an existing work package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewMarkdownDocument(context?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewMarkdownDocument(context, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Preview plain document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewPlainDocument(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewPlainDocument(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PreviewingApi - factory interface
 * @export
 */
export const PreviewingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PreviewingApiFp(configuration)
    return {
        /**
         * 
         * @summary Preview Markdown document
         * @param {string} [context] API-Link to the context in which the rendering occurs, for example a specific work package.  If left out only context-agnostic rendering takes place. Please note that OpenProject features markdown-extensions on top of the extensions GitHub Flavored Markdown (gfm) already provides that can only work given a context (e.g. display attached images).  **Supported contexts:**  * &#x60;/api/v3/work_packages/{id}&#x60; - an existing work package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewMarkdownDocument(context?: string, options?: any): AxiosPromise<string> {
            return localVarFp.previewMarkdownDocument(context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Preview plain document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewPlainDocument(options?: any): AxiosPromise<string> {
            return localVarFp.previewPlainDocument(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for previewMarkdownDocument operation in PreviewingApi.
 * @export
 * @interface PreviewingApiPreviewMarkdownDocumentRequest
 */
export interface PreviewingApiPreviewMarkdownDocumentRequest {
    /**
     * API-Link to the context in which the rendering occurs, for example a specific work package.  If left out only context-agnostic rendering takes place. Please note that OpenProject features markdown-extensions on top of the extensions GitHub Flavored Markdown (gfm) already provides that can only work given a context (e.g. display attached images).  **Supported contexts:**  * &#x60;/api/v3/work_packages/{id}&#x60; - an existing work package
     * @type {string}
     * @memberof PreviewingApiPreviewMarkdownDocument
     */
    readonly context?: string
}

/**
 * PreviewingApi - object-oriented interface
 * @export
 * @class PreviewingApi
 * @extends {BaseAPI}
 */
export class PreviewingApi extends BaseAPI {
    /**
     * 
     * @summary Preview Markdown document
     * @param {PreviewingApiPreviewMarkdownDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreviewingApi
     */
    public previewMarkdownDocument(requestParameters: PreviewingApiPreviewMarkdownDocumentRequest = {}, options?: AxiosRequestConfig) {
        return PreviewingApiFp(this.configuration).previewMarkdownDocument(requestParameters.context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Preview plain document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreviewingApi
     */
    public previewPlainDocument(options?: AxiosRequestConfig) {
        return PreviewingApiFp(this.configuration).previewPlainDocument(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PrincipalsApi - axios parameter creator
 * @export
 */
export const PrincipalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all principals. The client can choose to filter the principals similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain principals who are members in projects the client is allowed to see.
         * @summary List principals
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + type: filters principals by their type (*User*, *Group*, *PlaceholderUser*).  + member: filters principals by the projects they are members in.  + name: filters principals by the user or group name.  + any_name_attribute: filters principals by the user or group first- and last name, email or login.  + status: filters principals by their status number (active &#x3D; *1*, registered &#x3D; *2*, locked &#x3D; *3*, invited &#x3D; *4*)
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrincipals: async (filters?: string, select?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/principals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrincipalsApi - functional programming interface
 * @export
 */
export const PrincipalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PrincipalsApiAxiosParamCreator(configuration)
    return {
        /**
         * List all principals. The client can choose to filter the principals similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain principals who are members in projects the client is allowed to see.
         * @summary List principals
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + type: filters principals by their type (*User*, *Group*, *PlaceholderUser*).  + member: filters principals by the projects they are members in.  + name: filters principals by the user or group name.  + any_name_attribute: filters principals by the user or group first- and last name, email or login.  + status: filters principals by their status number (active &#x3D; *1*, registered &#x3D; *2*, locked &#x3D; *3*, invited &#x3D; *4*)
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPrincipals(filters?: string, select?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPrincipals(filters, select, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PrincipalsApi - factory interface
 * @export
 */
export const PrincipalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PrincipalsApiFp(configuration)
    return {
        /**
         * List all principals. The client can choose to filter the principals similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain principals who are members in projects the client is allowed to see.
         * @summary List principals
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + type: filters principals by their type (*User*, *Group*, *PlaceholderUser*).  + member: filters principals by the projects they are members in.  + name: filters principals by the user or group name.  + any_name_attribute: filters principals by the user or group first- and last name, email or login.  + status: filters principals by their status number (active &#x3D; *1*, registered &#x3D; *2*, locked &#x3D; *3*, invited &#x3D; *4*)
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrincipals(filters?: string, select?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listPrincipals(filters, select, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listPrincipals operation in PrincipalsApi.
 * @export
 * @interface PrincipalsApiListPrincipalsRequest
 */
export interface PrincipalsApiListPrincipalsRequest {
    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + type: filters principals by their type (*User*, *Group*, *PlaceholderUser*).  + member: filters principals by the projects they are members in.  + name: filters principals by the user or group name.  + any_name_attribute: filters principals by the user or group first- and last name, email or login.  + status: filters principals by their status number (active &#x3D; *1*, registered &#x3D; *2*, locked &#x3D; *3*, invited &#x3D; *4*)
     * @type {string}
     * @memberof PrincipalsApiListPrincipals
     */
    readonly filters?: string

    /**
     * Comma separated list of properties to include.
     * @type {string}
     * @memberof PrincipalsApiListPrincipals
     */
    readonly select?: string
}

/**
 * PrincipalsApi - object-oriented interface
 * @export
 * @class PrincipalsApi
 * @extends {BaseAPI}
 */
export class PrincipalsApi extends BaseAPI {
    /**
     * List all principals. The client can choose to filter the principals similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain principals who are members in projects the client is allowed to see.
     * @summary List principals
     * @param {PrincipalsApiListPrincipalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrincipalsApi
     */
    public listPrincipals(requestParameters: PrincipalsApiListPrincipalsRequest = {}, options?: AxiosRequestConfig) {
        return PrincipalsApiFp(this.configuration).listPrincipals(requestParameters.filters, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PrioritiesApi - axios parameter creator
 * @export
 */
export const PrioritiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Priorities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllPriorities: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/priorities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View Priority
         * @param {number} id Priority id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewPriority: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewPriority', 'id', id)
            const localVarPath = `/api/v3/priorities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrioritiesApi - functional programming interface
 * @export
 */
export const PrioritiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PrioritiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Priorities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllPriorities(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllPriorities(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View Priority
         * @param {number} id Priority id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewPriority(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriorityModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewPriority(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PrioritiesApi - factory interface
 * @export
 */
export const PrioritiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PrioritiesApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Priorities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllPriorities(options?: any): AxiosPromise<object> {
            return localVarFp.listAllPriorities(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View Priority
         * @param {number} id Priority id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewPriority(id: number, options?: any): AxiosPromise<PriorityModel> {
            return localVarFp.viewPriority(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewPriority operation in PrioritiesApi.
 * @export
 * @interface PrioritiesApiViewPriorityRequest
 */
export interface PrioritiesApiViewPriorityRequest {
    /**
     * Priority id
     * @type {number}
     * @memberof PrioritiesApiViewPriority
     */
    readonly id: number
}

/**
 * PrioritiesApi - object-oriented interface
 * @export
 * @class PrioritiesApi
 * @extends {BaseAPI}
 */
export class PrioritiesApi extends BaseAPI {
    /**
     * 
     * @summary List all Priorities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrioritiesApi
     */
    public listAllPriorities(options?: AxiosRequestConfig) {
        return PrioritiesApiFp(this.configuration).listAllPriorities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View Priority
     * @param {PrioritiesApiViewPriorityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrioritiesApi
     */
    public viewPriority(requestParameters: PrioritiesApiViewPriorityRequest, options?: AxiosRequestConfig) {
        return PrioritiesApiFp(this.configuration).viewPriority(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new project, applying the attributes provided in the body.  You can use the form and schema to be retrieve the valid attribute values and by that be guided towards successful creation.
         * @summary Create project
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create project copy
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectCopy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createProjectCopy', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/copy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the project permanently. As this is a lengthy process, the actual deletion is carried out asynchronously. So the project might exist well after the request has returned successfully. To prevent unwanted changes to the project scheduled for deletion, it is archived at once.
         * @summary Delete Project
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProject', 'id', id)
            const localVarPath = `/api/v3/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists projects which can become parent to another project. Only sound candidates are returned. For instance a project cannot become parent of itself or it\'s children.  To specify the project for which a parent is queried for, the `of` parameter can be provided. If no `of` parameter is provided, a new project is assumed. Then, the check for the hierarchy is omitted as a new project cannot be part of a hierarchy yet.  Candidates can be filtered. Most commonly one will want to filter by name or identifier. You can do this through the `filters` parameter which works just like the work package index.  For instance to find all parent candidates with \"rollout\" in their name:  ``` ?filters=[{\"name_and_identifier\":{\"operator\":\"~\",\"values\":[\"rollout\"]}}] ```
         * @summary List available parent project candidates
         * @param {string} [filters] JSON specifying filter conditions.
         * @param {string} [of] The id or identifier of the project the parent candidate is determined for
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint and allows all the filters and sortBy supported by the project list end point.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableParentProjectCandidates: async (filters?: string, of?: string, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/projects/available_parent_projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (of !== undefined) {
                localVarQueryParameter['of'] = of;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a collection of projects. The collection can be filtered via query parameters similar to how work packages are filtered. In addition to the provided filter, the result set is always limited to only contain projects the client is allowed to see.
         * @summary List projects
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + active: based on the active property of the project  + ancestor: filters projects by their ancestor. A project is not considered to be it\&#39;s own ancestor.  + created_at: based on the time the project was created  + latest_activity_at: based on the time the last activity was registered on a project.  + name_and_identifier: based on both the name and the identifier.  + parent_id: filters projects by their parent.  + principal: based on members of the project.  + type_id: based on the types active in a project.  + user_action: based on the actions the current user has in the project.  + id: based on projects\&#39; id.  + visible: based on the visibility for the user (id) provided as the filter value. This filter is useful for admins to identify the projects visible to a user. There might also be additional filters based on the custom fields that have been configured.
         * @param {string} [sortBy] JSON specifying sort criteria. Currently supported orders are:  + id  + name  + typeahead (sorting by hierarchy and name)  + created_at  + public  + latest_activity_at  + required_disk_space There might also be additional orders based on the custom fields that have been configured.
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (filters?: string, sortBy?: string, select?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists the projects where the given version is available.  The projects returned depend on the sharing settings of the given version, but are also limited to the projects that the current user is allowed to see.
         * @summary List projects having version
         * @param {number} id Version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectsWithVersion: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listProjectsWithVersion', 'id', id)
            const localVarPath = `/api/v3/versions/{id}/projects`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Project copy form
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectCopyForm: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectCopyForm', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/copy/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Project create form
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectCreateForm: async (body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/projects/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Project update form
         * @param {number} id Project id
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdateForm: async (id: number, body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectUpdateForm', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the given project by applying the attributes provided in the body.
         * @summary Update Project
         * @param {number} id Project id
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (id: number, body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProject', 'id', id)
            const localVarPath = `/api/v3/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View project
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewProject: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewProject', 'id', id)
            const localVarPath = `/api/v3/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View project schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewProjectSchema: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/projects/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View project status
         * @param {string} id Project status id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewProjectStatus: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewProjectStatus', 'id', id)
            const localVarPath = `/api/v3/project_statuses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new project, applying the attributes provided in the body.  You can use the form and schema to be retrieve the valid attribute values and by that be guided towards successful creation.
         * @summary Create project
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(body?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create project copy
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectCopy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectCopy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the project permanently. As this is a lengthy process, the actual deletion is carried out asynchronously. So the project might exist well after the request has returned successfully. To prevent unwanted changes to the project scheduled for deletion, it is archived at once.
         * @summary Delete Project
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists projects which can become parent to another project. Only sound candidates are returned. For instance a project cannot become parent of itself or it\'s children.  To specify the project for which a parent is queried for, the `of` parameter can be provided. If no `of` parameter is provided, a new project is assumed. Then, the check for the hierarchy is omitted as a new project cannot be part of a hierarchy yet.  Candidates can be filtered. Most commonly one will want to filter by name or identifier. You can do this through the `filters` parameter which works just like the work package index.  For instance to find all parent candidates with \"rollout\" in their name:  ``` ?filters=[{\"name_and_identifier\":{\"operator\":\"~\",\"values\":[\"rollout\"]}}] ```
         * @summary List available parent project candidates
         * @param {string} [filters] JSON specifying filter conditions.
         * @param {string} [of] The id or identifier of the project the parent candidate is determined for
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint and allows all the filters and sortBy supported by the project list end point.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailableParentProjectCandidates(filters?: string, of?: string, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailableParentProjectCandidates(filters, of, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a collection of projects. The collection can be filtered via query parameters similar to how work packages are filtered. In addition to the provided filter, the result set is always limited to only contain projects the client is allowed to see.
         * @summary List projects
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + active: based on the active property of the project  + ancestor: filters projects by their ancestor. A project is not considered to be it\&#39;s own ancestor.  + created_at: based on the time the project was created  + latest_activity_at: based on the time the last activity was registered on a project.  + name_and_identifier: based on both the name and the identifier.  + parent_id: filters projects by their parent.  + principal: based on members of the project.  + type_id: based on the types active in a project.  + user_action: based on the actions the current user has in the project.  + id: based on projects\&#39; id.  + visible: based on the visibility for the user (id) provided as the filter value. This filter is useful for admins to identify the projects visible to a user. There might also be additional filters based on the custom fields that have been configured.
         * @param {string} [sortBy] JSON specifying sort criteria. Currently supported orders are:  + id  + name  + typeahead (sorting by hierarchy and name)  + created_at  + public  + latest_activity_at  + required_disk_space There might also be additional orders based on the custom fields that have been configured.
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(filters?: string, sortBy?: string, select?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(filters, sortBy, select, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint lists the projects where the given version is available.  The projects returned depend on the sharing settings of the given version, but are also limited to the projects that the current user is allowed to see.
         * @summary List projects having version
         * @param {number} id Version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectsWithVersion(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectsWithVersion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Project copy form
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectCopyForm(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectCopyForm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Project create form
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectCreateForm(body?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectCreateForm(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Project update form
         * @param {number} id Project id
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectUpdateForm(id: number, body?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectUpdateForm(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the given project by applying the attributes provided in the body.
         * @summary Update Project
         * @param {number} id Project id
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(id: number, body?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View project
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewProject(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View project schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewProjectSchema(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewProjectSchema(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View project status
         * @param {string} id Project status id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewProjectStatus(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewProjectStatus(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Creates a new project, applying the attributes provided in the body.  You can use the form and schema to be retrieve the valid attribute values and by that be guided towards successful creation.
         * @summary Create project
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(body?: object, options?: any): AxiosPromise<ProjectModel> {
            return localVarFp.createProject(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create project copy
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectCopy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.createProjectCopy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the project permanently. As this is a lengthy process, the actual deletion is carried out asynchronously. So the project might exist well after the request has returned successfully. To prevent unwanted changes to the project scheduled for deletion, it is archived at once.
         * @summary Delete Project
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists projects which can become parent to another project. Only sound candidates are returned. For instance a project cannot become parent of itself or it\'s children.  To specify the project for which a parent is queried for, the `of` parameter can be provided. If no `of` parameter is provided, a new project is assumed. Then, the check for the hierarchy is omitted as a new project cannot be part of a hierarchy yet.  Candidates can be filtered. Most commonly one will want to filter by name or identifier. You can do this through the `filters` parameter which works just like the work package index.  For instance to find all parent candidates with \"rollout\" in their name:  ``` ?filters=[{\"name_and_identifier\":{\"operator\":\"~\",\"values\":[\"rollout\"]}}] ```
         * @summary List available parent project candidates
         * @param {string} [filters] JSON specifying filter conditions.
         * @param {string} [of] The id or identifier of the project the parent candidate is determined for
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint and allows all the filters and sortBy supported by the project list end point.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableParentProjectCandidates(filters?: string, of?: string, sortBy?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listAvailableParentProjectCandidates(filters, of, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a collection of projects. The collection can be filtered via query parameters similar to how work packages are filtered. In addition to the provided filter, the result set is always limited to only contain projects the client is allowed to see.
         * @summary List projects
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + active: based on the active property of the project  + ancestor: filters projects by their ancestor. A project is not considered to be it\&#39;s own ancestor.  + created_at: based on the time the project was created  + latest_activity_at: based on the time the last activity was registered on a project.  + name_and_identifier: based on both the name and the identifier.  + parent_id: filters projects by their parent.  + principal: based on members of the project.  + type_id: based on the types active in a project.  + user_action: based on the actions the current user has in the project.  + id: based on projects\&#39; id.  + visible: based on the visibility for the user (id) provided as the filter value. This filter is useful for admins to identify the projects visible to a user. There might also be additional filters based on the custom fields that have been configured.
         * @param {string} [sortBy] JSON specifying sort criteria. Currently supported orders are:  + id  + name  + typeahead (sorting by hierarchy and name)  + created_at  + public  + latest_activity_at  + required_disk_space There might also be additional orders based on the custom fields that have been configured.
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(filters?: string, sortBy?: string, select?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listProjects(filters, sortBy, select, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint lists the projects where the given version is available.  The projects returned depend on the sharing settings of the given version, but are also limited to the projects that the current user is allowed to see.
         * @summary List projects having version
         * @param {number} id Version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectsWithVersion(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.listProjectsWithVersion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Project copy form
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectCopyForm(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.projectCopyForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Project create form
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectCreateForm(body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.projectCreateForm(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Project update form
         * @param {number} id Project id
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdateForm(id: number, body?: object, options?: any): AxiosPromise<void> {
            return localVarFp.projectUpdateForm(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the given project by applying the attributes provided in the body.
         * @summary Update Project
         * @param {number} id Project id
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(id: number, body?: object, options?: any): AxiosPromise<ProjectModel> {
            return localVarFp.updateProject(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View project
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewProject(id: number, options?: any): AxiosPromise<ProjectModel> {
            return localVarFp.viewProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View project schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewProjectSchema(options?: any): AxiosPromise<object> {
            return localVarFp.viewProjectSchema(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View project status
         * @param {string} id Project status id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewProjectStatus(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.viewProjectStatus(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiCreateProjectRequest
 */
export interface ProjectsApiCreateProjectRequest {
    /**
     * 
     * @type {object}
     * @memberof ProjectsApiCreateProject
     */
    readonly body?: object
}

/**
 * Request parameters for createProjectCopy operation in ProjectsApi.
 * @export
 * @interface ProjectsApiCreateProjectCopyRequest
 */
export interface ProjectsApiCreateProjectCopyRequest {
    /**
     * Project id
     * @type {number}
     * @memberof ProjectsApiCreateProjectCopy
     */
    readonly id: number
}

/**
 * Request parameters for deleteProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiDeleteProjectRequest
 */
export interface ProjectsApiDeleteProjectRequest {
    /**
     * Project id
     * @type {number}
     * @memberof ProjectsApiDeleteProject
     */
    readonly id: number
}

/**
 * Request parameters for listAvailableParentProjectCandidates operation in ProjectsApi.
 * @export
 * @interface ProjectsApiListAvailableParentProjectCandidatesRequest
 */
export interface ProjectsApiListAvailableParentProjectCandidatesRequest {
    /**
     * JSON specifying filter conditions.
     * @type {string}
     * @memberof ProjectsApiListAvailableParentProjectCandidates
     */
    readonly filters?: string

    /**
     * The id or identifier of the project the parent candidate is determined for
     * @type {string}
     * @memberof ProjectsApiListAvailableParentProjectCandidates
     */
    readonly of?: string

    /**
     * JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint and allows all the filters and sortBy supported by the project list end point.
     * @type {string}
     * @memberof ProjectsApiListAvailableParentProjectCandidates
     */
    readonly sortBy?: string
}

/**
 * Request parameters for listProjects operation in ProjectsApi.
 * @export
 * @interface ProjectsApiListProjectsRequest
 */
export interface ProjectsApiListProjectsRequest {
    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + active: based on the active property of the project  + ancestor: filters projects by their ancestor. A project is not considered to be it\&#39;s own ancestor.  + created_at: based on the time the project was created  + latest_activity_at: based on the time the last activity was registered on a project.  + name_and_identifier: based on both the name and the identifier.  + parent_id: filters projects by their parent.  + principal: based on members of the project.  + type_id: based on the types active in a project.  + user_action: based on the actions the current user has in the project.  + id: based on projects\&#39; id.  + visible: based on the visibility for the user (id) provided as the filter value. This filter is useful for admins to identify the projects visible to a user. There might also be additional filters based on the custom fields that have been configured.
     * @type {string}
     * @memberof ProjectsApiListProjects
     */
    readonly filters?: string

    /**
     * JSON specifying sort criteria. Currently supported orders are:  + id  + name  + typeahead (sorting by hierarchy and name)  + created_at  + public  + latest_activity_at  + required_disk_space There might also be additional orders based on the custom fields that have been configured.
     * @type {string}
     * @memberof ProjectsApiListProjects
     */
    readonly sortBy?: string

    /**
     * Comma separated list of properties to include.
     * @type {string}
     * @memberof ProjectsApiListProjects
     */
    readonly select?: string
}

/**
 * Request parameters for listProjectsWithVersion operation in ProjectsApi.
 * @export
 * @interface ProjectsApiListProjectsWithVersionRequest
 */
export interface ProjectsApiListProjectsWithVersionRequest {
    /**
     * Version id
     * @type {number}
     * @memberof ProjectsApiListProjectsWithVersion
     */
    readonly id: number
}

/**
 * Request parameters for projectCopyForm operation in ProjectsApi.
 * @export
 * @interface ProjectsApiProjectCopyFormRequest
 */
export interface ProjectsApiProjectCopyFormRequest {
    /**
     * Project id
     * @type {number}
     * @memberof ProjectsApiProjectCopyForm
     */
    readonly id: number
}

/**
 * Request parameters for projectCreateForm operation in ProjectsApi.
 * @export
 * @interface ProjectsApiProjectCreateFormRequest
 */
export interface ProjectsApiProjectCreateFormRequest {
    /**
     * 
     * @type {object}
     * @memberof ProjectsApiProjectCreateForm
     */
    readonly body?: object
}

/**
 * Request parameters for projectUpdateForm operation in ProjectsApi.
 * @export
 * @interface ProjectsApiProjectUpdateFormRequest
 */
export interface ProjectsApiProjectUpdateFormRequest {
    /**
     * Project id
     * @type {number}
     * @memberof ProjectsApiProjectUpdateForm
     */
    readonly id: number

    /**
     * 
     * @type {object}
     * @memberof ProjectsApiProjectUpdateForm
     */
    readonly body?: object
}

/**
 * Request parameters for updateProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiUpdateProjectRequest
 */
export interface ProjectsApiUpdateProjectRequest {
    /**
     * Project id
     * @type {number}
     * @memberof ProjectsApiUpdateProject
     */
    readonly id: number

    /**
     * 
     * @type {object}
     * @memberof ProjectsApiUpdateProject
     */
    readonly body?: object
}

/**
 * Request parameters for viewProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiViewProjectRequest
 */
export interface ProjectsApiViewProjectRequest {
    /**
     * Project id
     * @type {number}
     * @memberof ProjectsApiViewProject
     */
    readonly id: number
}

/**
 * Request parameters for viewProjectStatus operation in ProjectsApi.
 * @export
 * @interface ProjectsApiViewProjectStatusRequest
 */
export interface ProjectsApiViewProjectStatusRequest {
    /**
     * Project status id
     * @type {string}
     * @memberof ProjectsApiViewProjectStatus
     */
    readonly id: string
}

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Creates a new project, applying the attributes provided in the body.  You can use the form and schema to be retrieve the valid attribute values and by that be guided towards successful creation.
     * @summary Create project
     * @param {ProjectsApiCreateProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(requestParameters: ProjectsApiCreateProjectRequest = {}, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProject(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create project copy
     * @param {ProjectsApiCreateProjectCopyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProjectCopy(requestParameters: ProjectsApiCreateProjectCopyRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProjectCopy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the project permanently. As this is a lengthy process, the actual deletion is carried out asynchronously. So the project might exist well after the request has returned successfully. To prevent unwanted changes to the project scheduled for deletion, it is archived at once.
     * @summary Delete Project
     * @param {ProjectsApiDeleteProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(requestParameters: ProjectsApiDeleteProjectRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProject(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists projects which can become parent to another project. Only sound candidates are returned. For instance a project cannot become parent of itself or it\'s children.  To specify the project for which a parent is queried for, the `of` parameter can be provided. If no `of` parameter is provided, a new project is assumed. Then, the check for the hierarchy is omitted as a new project cannot be part of a hierarchy yet.  Candidates can be filtered. Most commonly one will want to filter by name or identifier. You can do this through the `filters` parameter which works just like the work package index.  For instance to find all parent candidates with \"rollout\" in their name:  ``` ?filters=[{\"name_and_identifier\":{\"operator\":\"~\",\"values\":[\"rollout\"]}}] ```
     * @summary List available parent project candidates
     * @param {ProjectsApiListAvailableParentProjectCandidatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listAvailableParentProjectCandidates(requestParameters: ProjectsApiListAvailableParentProjectCandidatesRequest = {}, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listAvailableParentProjectCandidates(requestParameters.filters, requestParameters.of, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a collection of projects. The collection can be filtered via query parameters similar to how work packages are filtered. In addition to the provided filter, the result set is always limited to only contain projects the client is allowed to see.
     * @summary List projects
     * @param {ProjectsApiListProjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjects(requestParameters: ProjectsApiListProjectsRequest = {}, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProjects(requestParameters.filters, requestParameters.sortBy, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint lists the projects where the given version is available.  The projects returned depend on the sharing settings of the given version, but are also limited to the projects that the current user is allowed to see.
     * @summary List projects having version
     * @param {ProjectsApiListProjectsWithVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjectsWithVersion(requestParameters: ProjectsApiListProjectsWithVersionRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProjectsWithVersion(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Project copy form
     * @param {ProjectsApiProjectCopyFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectCopyForm(requestParameters: ProjectsApiProjectCopyFormRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectCopyForm(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Project create form
     * @param {ProjectsApiProjectCreateFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectCreateForm(requestParameters: ProjectsApiProjectCreateFormRequest = {}, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectCreateForm(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Project update form
     * @param {ProjectsApiProjectUpdateFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectUpdateForm(requestParameters: ProjectsApiProjectUpdateFormRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectUpdateForm(requestParameters.id, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the given project by applying the attributes provided in the body.
     * @summary Update Project
     * @param {ProjectsApiUpdateProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProject(requestParameters: ProjectsApiUpdateProjectRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).updateProject(requestParameters.id, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View project
     * @param {ProjectsApiViewProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public viewProject(requestParameters: ProjectsApiViewProjectRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).viewProject(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View project schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public viewProjectSchema(options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).viewProjectSchema(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View project status
     * @param {ProjectsApiViewProjectStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public viewProjectStatus(requestParameters: ProjectsApiViewProjectStatusRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).viewProjectStatus(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueriesApi - axios parameter creator
 * @export
 */
export const QueriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of projects that are available as projects a query can be assigned to.
         * @summary Available projects for query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableProjectsForQuery: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/queries/available_projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a Query can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.
         * @summary Create query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuery: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/queries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the query identified by the id parameter
         * @summary Delete query
         * @param {number} id Query id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuery: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteQuery', 'id', id)
            const localVarPath = `/api/v3/queries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. Note that it is only allowed to provide properties or links supporting the **write** operation.
         * @summary Edit Query
         * @param {number} id Query id
         * @param {EditQueryRequest} [editQueryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editQuery: async (id: number, editQueryRequest?: EditQueryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editQuery', 'id', id)
            const localVarPath = `/api/v3/queries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a collection of queries. The collection can be filtered via query parameters similar to how work packages are filtered. Please note however, that the filters are applied to the queries and not to the work packages the queries in turn might return.
         * @summary List queries
         * @param {string} [filters] JSON specifying filter conditions. Currently supported filters are:  + project: filters queries by the project they are assigned to. If the project filter is passed with the &#x60;!*&#x60; (not any) operator, global queries are returned.  + id: filters queries based on their id  + updated_at: filters queries based on the last time they where updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueries: async (filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/queries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query Create Form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryCreateForm: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/queries/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Star query
         * @param {number} id Query id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starQuery: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('starQuery', 'id', id)
            const localVarPath = `/api/v3/queries/{id}/star`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unstar query
         * @param {number} id Query id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstarQuery: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unstarQuery', 'id', id)
            const localVarPath = `/api/v3/queries/{id}/unstar`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Same as [viewing an existing, persisted Query](https://www.openproject.org/docs/api/endpoints/queries/#list-queries) in its response, this resource returns an unpersisted query and by that allows to get the default query configuration. The client may also provide additional parameters which will modify the default query.
         * @summary View default query
         * @param {string} [filters] JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query\&#39;s persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
         * @param {number} [offset] Page number inside the queries\&#39; result collection of work packages.
         * @param {number} [pageSize] Number of elements to display per page for the queries\&#39; result collection of work packages.
         * @param {string} [sortBy] JSON specifying sort criteria. The sort criteria is applied to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sort criteria.
         * @param {string} [groupBy] The column to group by. The grouping criteria is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted group criteria.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sums property.
         * @param {boolean} [timelineVisible] Indicates whether the timeline should be shown.
         * @param {string} [timelineZoomLevel] Indicates in what zoom level the timeline should be shown. Valid values are  &#x60;days&#x60;, &#x60;weeks&#x60;, &#x60;months&#x60;, &#x60;quarters&#x60;, and &#x60;years&#x60;.
         * @param {boolean} [showHierarchies] Indicates whether the hierarchy mode should be enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewDefaultQuery: async (filters?: string, offset?: number, pageSize?: number, sortBy?: string, groupBy?: string, showSums?: boolean, timelineVisible?: boolean, timelineZoomLevel?: string, showHierarchies?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/queries/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (showSums !== undefined) {
                localVarQueryParameter['showSums'] = showSums;
            }

            if (timelineVisible !== undefined) {
                localVarQueryParameter['timelineVisible'] = timelineVisible;
            }

            if (timelineZoomLevel !== undefined) {
                localVarQueryParameter['timelineZoomLevel'] = timelineZoomLevel;
            }

            if (showHierarchies !== undefined) {
                localVarQueryParameter['showHierarchies'] = showHierarchies;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Same as [viewing an existing, persisted Query](https://www.openproject.org/docs/api/endpoints/queries/#list-queries) in its response, this resource returns an unpersisted query and by that allows to get the default query configuration. The client may also provide additional parameters which will modify the default query. The query will already be scoped for the project.
         * @summary View default query for project
         * @param {number} id Id of the project the default query is requested for
         * @param {string} [filters] JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query\&#39;s persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
         * @param {number} [offset] Page number inside the queries\&#39; result collection of work packages.
         * @param {number} [pageSize] Number of elements to display per page for the queries\&#39; result collection of work packages.
         * @param {string} [sortBy] JSON specifying sort criteria. The sort criteria is applied to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sort criteria.
         * @param {string} [groupBy] The column to group by. The grouping criteria is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted group criteria.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sums property.
         * @param {boolean} [timelineVisible] Indicates whether the timeline should be shown.
         * @param {boolean} [showHierarchies] Indicates whether the hierarchy mode should be enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewDefaultQueryForProject: async (id: number, filters?: string, offset?: number, pageSize?: number, sortBy?: string, groupBy?: string, showSums?: boolean, timelineVisible?: boolean, showHierarchies?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewDefaultQueryForProject', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/queries/default`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (showSums !== undefined) {
                localVarQueryParameter['showSums'] = showSums;
            }

            if (timelineVisible !== undefined) {
                localVarQueryParameter['timelineVisible'] = timelineVisible;
            }

            if (showHierarchies !== undefined) {
                localVarQueryParameter['showHierarchies'] = showHierarchies;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an individual query as identified by the id parameter. Then end point accepts a number of parameters that can be used to override the resources\' persisted parameters.
         * @summary View query
         * @param {number} id Query id
         * @param {string} [filters] JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query\&#39;s persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
         * @param {number} [offset] Page number inside the queries\&#39; result collection of work packages.
         * @param {number} [pageSize] Number of elements to display per page for the queries\&#39; result collection of work packages.
         * @param {string} [columns] Selected columns for the table view.
         * @param {string} [sortBy] JSON specifying sort criteria. The sort criteria is applied to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sort criteria.
         * @param {string} [groupBy] The column to group by. The grouping criteria is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted group criteria.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sums property.
         * @param {boolean} [timelineVisible] Indicates whether the timeline should be shown.
         * @param {string} [timelineLabels] Overridden labels in the timeline view
         * @param {string} [highlightingMode] Highlighting mode for the table view.
         * @param {string} [highlightedAttributes] Highlighted attributes mode for the table view when &#x60;highlightingMode&#x60; is &#x60;inline&#x60;. When set to &#x60;[]&#x60; all highlightable attributes will be returned as &#x60;highlightedAttributes&#x60;.
         * @param {boolean} [showHierarchies] Indicates whether the hierarchy mode should be enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewQuery: async (id: number, filters?: string, offset?: number, pageSize?: number, columns?: string, sortBy?: string, groupBy?: string, showSums?: boolean, timelineVisible?: boolean, timelineLabels?: string, highlightingMode?: string, highlightedAttributes?: string, showHierarchies?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewQuery', 'id', id)
            const localVarPath = `/api/v3/queries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (columns !== undefined) {
                localVarQueryParameter['columns'] = columns;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (showSums !== undefined) {
                localVarQueryParameter['showSums'] = showSums;
            }

            if (timelineVisible !== undefined) {
                localVarQueryParameter['timelineVisible'] = timelineVisible;
            }

            if (timelineLabels !== undefined) {
                localVarQueryParameter['timelineLabels'] = timelineLabels;
            }

            if (highlightingMode !== undefined) {
                localVarQueryParameter['highlightingMode'] = highlightingMode;
            }

            if (highlightedAttributes !== undefined) {
                localVarQueryParameter['highlightedAttributes'] = highlightedAttributes;
            }

            if (showHierarchies !== undefined) {
                localVarQueryParameter['showHierarchies'] = showHierarchies;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the schema for global queries, those, that are not assigned to a project.
         * @summary View schema for global queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewSchemaForGlobalQueries: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/queries/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the schema for project queries.
         * @summary View schema for project queries
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewSchemaForProjectQueries: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewSchemaForProjectQueries', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/queries/schema`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueriesApi - functional programming interface
 * @export
 */
export const QueriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a list of projects that are available as projects a query can be assigned to.
         * @summary Available projects for query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableProjectsForQuery(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableProjectsForQuery(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a Query can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.
         * @summary Create query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuery(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuery(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the query identified by the id parameter
         * @summary Delete query
         * @param {number} id Query id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQuery(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQuery(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. Note that it is only allowed to provide properties or links supporting the **write** operation.
         * @summary Edit Query
         * @param {number} id Query id
         * @param {EditQueryRequest} [editQueryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editQuery(id: number, editQueryRequest?: EditQueryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editQuery(id, editQueryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a collection of queries. The collection can be filtered via query parameters similar to how work packages are filtered. Please note however, that the filters are applied to the queries and not to the work packages the queries in turn might return.
         * @summary List queries
         * @param {string} [filters] JSON specifying filter conditions. Currently supported filters are:  + project: filters queries by the project they are assigned to. If the project filter is passed with the &#x60;!*&#x60; (not any) operator, global queries are returned.  + id: filters queries based on their id  + updated_at: filters queries based on the last time they where updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQueries(filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listQueries(filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query Create Form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryCreateForm(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryCreateForm(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Star query
         * @param {number} id Query id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async starQuery(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.starQuery(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unstar query
         * @param {number} id Query id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unstarQuery(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unstarQuery(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Same as [viewing an existing, persisted Query](https://www.openproject.org/docs/api/endpoints/queries/#list-queries) in its response, this resource returns an unpersisted query and by that allows to get the default query configuration. The client may also provide additional parameters which will modify the default query.
         * @summary View default query
         * @param {string} [filters] JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query\&#39;s persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
         * @param {number} [offset] Page number inside the queries\&#39; result collection of work packages.
         * @param {number} [pageSize] Number of elements to display per page for the queries\&#39; result collection of work packages.
         * @param {string} [sortBy] JSON specifying sort criteria. The sort criteria is applied to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sort criteria.
         * @param {string} [groupBy] The column to group by. The grouping criteria is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted group criteria.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sums property.
         * @param {boolean} [timelineVisible] Indicates whether the timeline should be shown.
         * @param {string} [timelineZoomLevel] Indicates in what zoom level the timeline should be shown. Valid values are  &#x60;days&#x60;, &#x60;weeks&#x60;, &#x60;months&#x60;, &#x60;quarters&#x60;, and &#x60;years&#x60;.
         * @param {boolean} [showHierarchies] Indicates whether the hierarchy mode should be enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewDefaultQuery(filters?: string, offset?: number, pageSize?: number, sortBy?: string, groupBy?: string, showSums?: boolean, timelineVisible?: boolean, timelineZoomLevel?: string, showHierarchies?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewDefaultQuery(filters, offset, pageSize, sortBy, groupBy, showSums, timelineVisible, timelineZoomLevel, showHierarchies, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Same as [viewing an existing, persisted Query](https://www.openproject.org/docs/api/endpoints/queries/#list-queries) in its response, this resource returns an unpersisted query and by that allows to get the default query configuration. The client may also provide additional parameters which will modify the default query. The query will already be scoped for the project.
         * @summary View default query for project
         * @param {number} id Id of the project the default query is requested for
         * @param {string} [filters] JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query\&#39;s persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
         * @param {number} [offset] Page number inside the queries\&#39; result collection of work packages.
         * @param {number} [pageSize] Number of elements to display per page for the queries\&#39; result collection of work packages.
         * @param {string} [sortBy] JSON specifying sort criteria. The sort criteria is applied to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sort criteria.
         * @param {string} [groupBy] The column to group by. The grouping criteria is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted group criteria.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sums property.
         * @param {boolean} [timelineVisible] Indicates whether the timeline should be shown.
         * @param {boolean} [showHierarchies] Indicates whether the hierarchy mode should be enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewDefaultQueryForProject(id: number, filters?: string, offset?: number, pageSize?: number, sortBy?: string, groupBy?: string, showSums?: boolean, timelineVisible?: boolean, showHierarchies?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewDefaultQueryForProject(id, filters, offset, pageSize, sortBy, groupBy, showSums, timelineVisible, showHierarchies, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an individual query as identified by the id parameter. Then end point accepts a number of parameters that can be used to override the resources\' persisted parameters.
         * @summary View query
         * @param {number} id Query id
         * @param {string} [filters] JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query\&#39;s persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
         * @param {number} [offset] Page number inside the queries\&#39; result collection of work packages.
         * @param {number} [pageSize] Number of elements to display per page for the queries\&#39; result collection of work packages.
         * @param {string} [columns] Selected columns for the table view.
         * @param {string} [sortBy] JSON specifying sort criteria. The sort criteria is applied to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sort criteria.
         * @param {string} [groupBy] The column to group by. The grouping criteria is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted group criteria.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sums property.
         * @param {boolean} [timelineVisible] Indicates whether the timeline should be shown.
         * @param {string} [timelineLabels] Overridden labels in the timeline view
         * @param {string} [highlightingMode] Highlighting mode for the table view.
         * @param {string} [highlightedAttributes] Highlighted attributes mode for the table view when &#x60;highlightingMode&#x60; is &#x60;inline&#x60;. When set to &#x60;[]&#x60; all highlightable attributes will be returned as &#x60;highlightedAttributes&#x60;.
         * @param {boolean} [showHierarchies] Indicates whether the hierarchy mode should be enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewQuery(id: number, filters?: string, offset?: number, pageSize?: number, columns?: string, sortBy?: string, groupBy?: string, showSums?: boolean, timelineVisible?: boolean, timelineLabels?: string, highlightingMode?: string, highlightedAttributes?: string, showHierarchies?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewQuery(id, filters, offset, pageSize, columns, sortBy, groupBy, showSums, timelineVisible, timelineLabels, highlightingMode, highlightedAttributes, showHierarchies, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the schema for global queries, those, that are not assigned to a project.
         * @summary View schema for global queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewSchemaForGlobalQueries(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewSchemaForGlobalQueries(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the schema for project queries.
         * @summary View schema for project queries
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewSchemaForProjectQueries(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewSchemaForProjectQueries(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueriesApi - factory interface
 * @export
 */
export const QueriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueriesApiFp(configuration)
    return {
        /**
         * Gets a list of projects that are available as projects a query can be assigned to.
         * @summary Available projects for query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableProjectsForQuery(options?: any): AxiosPromise<object> {
            return localVarFp.availableProjectsForQuery(options).then((request) => request(axios, basePath));
        },
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a Query can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.
         * @summary Create query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuery(options?: any): AxiosPromise<QueryModel> {
            return localVarFp.createQuery(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the query identified by the id parameter
         * @summary Delete query
         * @param {number} id Query id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuery(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteQuery(id, options).then((request) => request(axios, basePath));
        },
        /**
         * When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. Note that it is only allowed to provide properties or links supporting the **write** operation.
         * @summary Edit Query
         * @param {number} id Query id
         * @param {EditQueryRequest} [editQueryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editQuery(id: number, editQueryRequest?: EditQueryRequest, options?: any): AxiosPromise<QueryModel> {
            return localVarFp.editQuery(id, editQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a collection of queries. The collection can be filtered via query parameters similar to how work packages are filtered. Please note however, that the filters are applied to the queries and not to the work packages the queries in turn might return.
         * @summary List queries
         * @param {string} [filters] JSON specifying filter conditions. Currently supported filters are:  + project: filters queries by the project they are assigned to. If the project filter is passed with the &#x60;!*&#x60; (not any) operator, global queries are returned.  + id: filters queries based on their id  + updated_at: filters queries based on the last time they where updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueries(filters?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listQueries(filters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query Create Form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryCreateForm(options?: any): AxiosPromise<void> {
            return localVarFp.queryCreateForm(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Star query
         * @param {number} id Query id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starQuery(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.starQuery(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unstar query
         * @param {number} id Query id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstarQuery(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.unstarQuery(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Same as [viewing an existing, persisted Query](https://www.openproject.org/docs/api/endpoints/queries/#list-queries) in its response, this resource returns an unpersisted query and by that allows to get the default query configuration. The client may also provide additional parameters which will modify the default query.
         * @summary View default query
         * @param {string} [filters] JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query\&#39;s persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
         * @param {number} [offset] Page number inside the queries\&#39; result collection of work packages.
         * @param {number} [pageSize] Number of elements to display per page for the queries\&#39; result collection of work packages.
         * @param {string} [sortBy] JSON specifying sort criteria. The sort criteria is applied to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sort criteria.
         * @param {string} [groupBy] The column to group by. The grouping criteria is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted group criteria.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sums property.
         * @param {boolean} [timelineVisible] Indicates whether the timeline should be shown.
         * @param {string} [timelineZoomLevel] Indicates in what zoom level the timeline should be shown. Valid values are  &#x60;days&#x60;, &#x60;weeks&#x60;, &#x60;months&#x60;, &#x60;quarters&#x60;, and &#x60;years&#x60;.
         * @param {boolean} [showHierarchies] Indicates whether the hierarchy mode should be enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewDefaultQuery(filters?: string, offset?: number, pageSize?: number, sortBy?: string, groupBy?: string, showSums?: boolean, timelineVisible?: boolean, timelineZoomLevel?: string, showHierarchies?: boolean, options?: any): AxiosPromise<object> {
            return localVarFp.viewDefaultQuery(filters, offset, pageSize, sortBy, groupBy, showSums, timelineVisible, timelineZoomLevel, showHierarchies, options).then((request) => request(axios, basePath));
        },
        /**
         * Same as [viewing an existing, persisted Query](https://www.openproject.org/docs/api/endpoints/queries/#list-queries) in its response, this resource returns an unpersisted query and by that allows to get the default query configuration. The client may also provide additional parameters which will modify the default query. The query will already be scoped for the project.
         * @summary View default query for project
         * @param {number} id Id of the project the default query is requested for
         * @param {string} [filters] JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query\&#39;s persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
         * @param {number} [offset] Page number inside the queries\&#39; result collection of work packages.
         * @param {number} [pageSize] Number of elements to display per page for the queries\&#39; result collection of work packages.
         * @param {string} [sortBy] JSON specifying sort criteria. The sort criteria is applied to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sort criteria.
         * @param {string} [groupBy] The column to group by. The grouping criteria is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted group criteria.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sums property.
         * @param {boolean} [timelineVisible] Indicates whether the timeline should be shown.
         * @param {boolean} [showHierarchies] Indicates whether the hierarchy mode should be enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewDefaultQueryForProject(id: number, filters?: string, offset?: number, pageSize?: number, sortBy?: string, groupBy?: string, showSums?: boolean, timelineVisible?: boolean, showHierarchies?: boolean, options?: any): AxiosPromise<object> {
            return localVarFp.viewDefaultQueryForProject(id, filters, offset, pageSize, sortBy, groupBy, showSums, timelineVisible, showHierarchies, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an individual query as identified by the id parameter. Then end point accepts a number of parameters that can be used to override the resources\' persisted parameters.
         * @summary View query
         * @param {number} id Query id
         * @param {string} [filters] JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query\&#39;s persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
         * @param {number} [offset] Page number inside the queries\&#39; result collection of work packages.
         * @param {number} [pageSize] Number of elements to display per page for the queries\&#39; result collection of work packages.
         * @param {string} [columns] Selected columns for the table view.
         * @param {string} [sortBy] JSON specifying sort criteria. The sort criteria is applied to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sort criteria.
         * @param {string} [groupBy] The column to group by. The grouping criteria is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted group criteria.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sums property.
         * @param {boolean} [timelineVisible] Indicates whether the timeline should be shown.
         * @param {string} [timelineLabels] Overridden labels in the timeline view
         * @param {string} [highlightingMode] Highlighting mode for the table view.
         * @param {string} [highlightedAttributes] Highlighted attributes mode for the table view when &#x60;highlightingMode&#x60; is &#x60;inline&#x60;. When set to &#x60;[]&#x60; all highlightable attributes will be returned as &#x60;highlightedAttributes&#x60;.
         * @param {boolean} [showHierarchies] Indicates whether the hierarchy mode should be enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewQuery(id: number, filters?: string, offset?: number, pageSize?: number, columns?: string, sortBy?: string, groupBy?: string, showSums?: boolean, timelineVisible?: boolean, timelineLabels?: string, highlightingMode?: string, highlightedAttributes?: string, showHierarchies?: boolean, options?: any): AxiosPromise<QueryModel> {
            return localVarFp.viewQuery(id, filters, offset, pageSize, columns, sortBy, groupBy, showSums, timelineVisible, timelineLabels, highlightingMode, highlightedAttributes, showHierarchies, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the schema for global queries, those, that are not assigned to a project.
         * @summary View schema for global queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewSchemaForGlobalQueries(options?: any): AxiosPromise<object> {
            return localVarFp.viewSchemaForGlobalQueries(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the schema for project queries.
         * @summary View schema for project queries
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewSchemaForProjectQueries(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.viewSchemaForProjectQueries(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteQuery operation in QueriesApi.
 * @export
 * @interface QueriesApiDeleteQueryRequest
 */
export interface QueriesApiDeleteQueryRequest {
    /**
     * Query id
     * @type {number}
     * @memberof QueriesApiDeleteQuery
     */
    readonly id: number
}

/**
 * Request parameters for editQuery operation in QueriesApi.
 * @export
 * @interface QueriesApiEditQueryRequest
 */
export interface QueriesApiEditQueryRequest {
    /**
     * Query id
     * @type {number}
     * @memberof QueriesApiEditQuery
     */
    readonly id: number

    /**
     * 
     * @type {EditQueryRequest}
     * @memberof QueriesApiEditQuery
     */
    readonly editQueryRequest?: EditQueryRequest
}

/**
 * Request parameters for listQueries operation in QueriesApi.
 * @export
 * @interface QueriesApiListQueriesRequest
 */
export interface QueriesApiListQueriesRequest {
    /**
     * JSON specifying filter conditions. Currently supported filters are:  + project: filters queries by the project they are assigned to. If the project filter is passed with the &#x60;!*&#x60; (not any) operator, global queries are returned.  + id: filters queries based on their id  + updated_at: filters queries based on the last time they where updated
     * @type {string}
     * @memberof QueriesApiListQueries
     */
    readonly filters?: string
}

/**
 * Request parameters for starQuery operation in QueriesApi.
 * @export
 * @interface QueriesApiStarQueryRequest
 */
export interface QueriesApiStarQueryRequest {
    /**
     * Query id
     * @type {number}
     * @memberof QueriesApiStarQuery
     */
    readonly id: number
}

/**
 * Request parameters for unstarQuery operation in QueriesApi.
 * @export
 * @interface QueriesApiUnstarQueryRequest
 */
export interface QueriesApiUnstarQueryRequest {
    /**
     * Query id
     * @type {number}
     * @memberof QueriesApiUnstarQuery
     */
    readonly id: number
}

/**
 * Request parameters for viewDefaultQuery operation in QueriesApi.
 * @export
 * @interface QueriesApiViewDefaultQueryRequest
 */
export interface QueriesApiViewDefaultQueryRequest {
    /**
     * JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query\&#39;s persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
     * @type {string}
     * @memberof QueriesApiViewDefaultQuery
     */
    readonly filters?: string

    /**
     * Page number inside the queries\&#39; result collection of work packages.
     * @type {number}
     * @memberof QueriesApiViewDefaultQuery
     */
    readonly offset?: number

    /**
     * Number of elements to display per page for the queries\&#39; result collection of work packages.
     * @type {number}
     * @memberof QueriesApiViewDefaultQuery
     */
    readonly pageSize?: number

    /**
     * JSON specifying sort criteria. The sort criteria is applied to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sort criteria.
     * @type {string}
     * @memberof QueriesApiViewDefaultQuery
     */
    readonly sortBy?: string

    /**
     * The column to group by. The grouping criteria is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted group criteria.
     * @type {string}
     * @memberof QueriesApiViewDefaultQuery
     */
    readonly groupBy?: string

    /**
     * Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sums property.
     * @type {boolean}
     * @memberof QueriesApiViewDefaultQuery
     */
    readonly showSums?: boolean

    /**
     * Indicates whether the timeline should be shown.
     * @type {boolean}
     * @memberof QueriesApiViewDefaultQuery
     */
    readonly timelineVisible?: boolean

    /**
     * Indicates in what zoom level the timeline should be shown. Valid values are  &#x60;days&#x60;, &#x60;weeks&#x60;, &#x60;months&#x60;, &#x60;quarters&#x60;, and &#x60;years&#x60;.
     * @type {string}
     * @memberof QueriesApiViewDefaultQuery
     */
    readonly timelineZoomLevel?: string

    /**
     * Indicates whether the hierarchy mode should be enabled.
     * @type {boolean}
     * @memberof QueriesApiViewDefaultQuery
     */
    readonly showHierarchies?: boolean
}

/**
 * Request parameters for viewDefaultQueryForProject operation in QueriesApi.
 * @export
 * @interface QueriesApiViewDefaultQueryForProjectRequest
 */
export interface QueriesApiViewDefaultQueryForProjectRequest {
    /**
     * Id of the project the default query is requested for
     * @type {number}
     * @memberof QueriesApiViewDefaultQueryForProject
     */
    readonly id: number

    /**
     * JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query\&#39;s persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
     * @type {string}
     * @memberof QueriesApiViewDefaultQueryForProject
     */
    readonly filters?: string

    /**
     * Page number inside the queries\&#39; result collection of work packages.
     * @type {number}
     * @memberof QueriesApiViewDefaultQueryForProject
     */
    readonly offset?: number

    /**
     * Number of elements to display per page for the queries\&#39; result collection of work packages.
     * @type {number}
     * @memberof QueriesApiViewDefaultQueryForProject
     */
    readonly pageSize?: number

    /**
     * JSON specifying sort criteria. The sort criteria is applied to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sort criteria.
     * @type {string}
     * @memberof QueriesApiViewDefaultQueryForProject
     */
    readonly sortBy?: string

    /**
     * The column to group by. The grouping criteria is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted group criteria.
     * @type {string}
     * @memberof QueriesApiViewDefaultQueryForProject
     */
    readonly groupBy?: string

    /**
     * Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sums property.
     * @type {boolean}
     * @memberof QueriesApiViewDefaultQueryForProject
     */
    readonly showSums?: boolean

    /**
     * Indicates whether the timeline should be shown.
     * @type {boolean}
     * @memberof QueriesApiViewDefaultQueryForProject
     */
    readonly timelineVisible?: boolean

    /**
     * Indicates whether the hierarchy mode should be enabled.
     * @type {boolean}
     * @memberof QueriesApiViewDefaultQueryForProject
     */
    readonly showHierarchies?: boolean
}

/**
 * Request parameters for viewQuery operation in QueriesApi.
 * @export
 * @interface QueriesApiViewQueryRequest
 */
export interface QueriesApiViewQueryRequest {
    /**
     * Query id
     * @type {number}
     * @memberof QueriesApiViewQuery
     */
    readonly id: number

    /**
     * JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query\&#39;s persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
     * @type {string}
     * @memberof QueriesApiViewQuery
     */
    readonly filters?: string

    /**
     * Page number inside the queries\&#39; result collection of work packages.
     * @type {number}
     * @memberof QueriesApiViewQuery
     */
    readonly offset?: number

    /**
     * Number of elements to display per page for the queries\&#39; result collection of work packages.
     * @type {number}
     * @memberof QueriesApiViewQuery
     */
    readonly pageSize?: number

    /**
     * Selected columns for the table view.
     * @type {string}
     * @memberof QueriesApiViewQuery
     */
    readonly columns?: string

    /**
     * JSON specifying sort criteria. The sort criteria is applied to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sort criteria.
     * @type {string}
     * @memberof QueriesApiViewQuery
     */
    readonly sortBy?: string

    /**
     * The column to group by. The grouping criteria is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted group criteria.
     * @type {string}
     * @memberof QueriesApiViewQuery
     */
    readonly groupBy?: string

    /**
     * Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query\&#39;s result collection of work packages overriding the query\&#39;s persisted sums property.
     * @type {boolean}
     * @memberof QueriesApiViewQuery
     */
    readonly showSums?: boolean

    /**
     * Indicates whether the timeline should be shown.
     * @type {boolean}
     * @memberof QueriesApiViewQuery
     */
    readonly timelineVisible?: boolean

    /**
     * Overridden labels in the timeline view
     * @type {string}
     * @memberof QueriesApiViewQuery
     */
    readonly timelineLabels?: string

    /**
     * Highlighting mode for the table view.
     * @type {string}
     * @memberof QueriesApiViewQuery
     */
    readonly highlightingMode?: string

    /**
     * Highlighted attributes mode for the table view when &#x60;highlightingMode&#x60; is &#x60;inline&#x60;. When set to &#x60;[]&#x60; all highlightable attributes will be returned as &#x60;highlightedAttributes&#x60;.
     * @type {string}
     * @memberof QueriesApiViewQuery
     */
    readonly highlightedAttributes?: string

    /**
     * Indicates whether the hierarchy mode should be enabled.
     * @type {boolean}
     * @memberof QueriesApiViewQuery
     */
    readonly showHierarchies?: boolean
}

/**
 * Request parameters for viewSchemaForProjectQueries operation in QueriesApi.
 * @export
 * @interface QueriesApiViewSchemaForProjectQueriesRequest
 */
export interface QueriesApiViewSchemaForProjectQueriesRequest {
    /**
     * Project id
     * @type {number}
     * @memberof QueriesApiViewSchemaForProjectQueries
     */
    readonly id: number
}

/**
 * QueriesApi - object-oriented interface
 * @export
 * @class QueriesApi
 * @extends {BaseAPI}
 */
export class QueriesApi extends BaseAPI {
    /**
     * Gets a list of projects that are available as projects a query can be assigned to.
     * @summary Available projects for query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public availableProjectsForQuery(options?: AxiosRequestConfig) {
        return QueriesApiFp(this.configuration).availableProjectsForQuery(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a Query can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.
     * @summary Create query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public createQuery(options?: AxiosRequestConfig) {
        return QueriesApiFp(this.configuration).createQuery(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the query identified by the id parameter
     * @summary Delete query
     * @param {QueriesApiDeleteQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public deleteQuery(requestParameters: QueriesApiDeleteQueryRequest, options?: AxiosRequestConfig) {
        return QueriesApiFp(this.configuration).deleteQuery(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. Note that it is only allowed to provide properties or links supporting the **write** operation.
     * @summary Edit Query
     * @param {QueriesApiEditQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public editQuery(requestParameters: QueriesApiEditQueryRequest, options?: AxiosRequestConfig) {
        return QueriesApiFp(this.configuration).editQuery(requestParameters.id, requestParameters.editQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a collection of queries. The collection can be filtered via query parameters similar to how work packages are filtered. Please note however, that the filters are applied to the queries and not to the work packages the queries in turn might return.
     * @summary List queries
     * @param {QueriesApiListQueriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public listQueries(requestParameters: QueriesApiListQueriesRequest = {}, options?: AxiosRequestConfig) {
        return QueriesApiFp(this.configuration).listQueries(requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query Create Form
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public queryCreateForm(options?: AxiosRequestConfig) {
        return QueriesApiFp(this.configuration).queryCreateForm(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Star query
     * @param {QueriesApiStarQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public starQuery(requestParameters: QueriesApiStarQueryRequest, options?: AxiosRequestConfig) {
        return QueriesApiFp(this.configuration).starQuery(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unstar query
     * @param {QueriesApiUnstarQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public unstarQuery(requestParameters: QueriesApiUnstarQueryRequest, options?: AxiosRequestConfig) {
        return QueriesApiFp(this.configuration).unstarQuery(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Same as [viewing an existing, persisted Query](https://www.openproject.org/docs/api/endpoints/queries/#list-queries) in its response, this resource returns an unpersisted query and by that allows to get the default query configuration. The client may also provide additional parameters which will modify the default query.
     * @summary View default query
     * @param {QueriesApiViewDefaultQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public viewDefaultQuery(requestParameters: QueriesApiViewDefaultQueryRequest = {}, options?: AxiosRequestConfig) {
        return QueriesApiFp(this.configuration).viewDefaultQuery(requestParameters.filters, requestParameters.offset, requestParameters.pageSize, requestParameters.sortBy, requestParameters.groupBy, requestParameters.showSums, requestParameters.timelineVisible, requestParameters.timelineZoomLevel, requestParameters.showHierarchies, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Same as [viewing an existing, persisted Query](https://www.openproject.org/docs/api/endpoints/queries/#list-queries) in its response, this resource returns an unpersisted query and by that allows to get the default query configuration. The client may also provide additional parameters which will modify the default query. The query will already be scoped for the project.
     * @summary View default query for project
     * @param {QueriesApiViewDefaultQueryForProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public viewDefaultQueryForProject(requestParameters: QueriesApiViewDefaultQueryForProjectRequest, options?: AxiosRequestConfig) {
        return QueriesApiFp(this.configuration).viewDefaultQueryForProject(requestParameters.id, requestParameters.filters, requestParameters.offset, requestParameters.pageSize, requestParameters.sortBy, requestParameters.groupBy, requestParameters.showSums, requestParameters.timelineVisible, requestParameters.showHierarchies, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an individual query as identified by the id parameter. Then end point accepts a number of parameters that can be used to override the resources\' persisted parameters.
     * @summary View query
     * @param {QueriesApiViewQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public viewQuery(requestParameters: QueriesApiViewQueryRequest, options?: AxiosRequestConfig) {
        return QueriesApiFp(this.configuration).viewQuery(requestParameters.id, requestParameters.filters, requestParameters.offset, requestParameters.pageSize, requestParameters.columns, requestParameters.sortBy, requestParameters.groupBy, requestParameters.showSums, requestParameters.timelineVisible, requestParameters.timelineLabels, requestParameters.highlightingMode, requestParameters.highlightedAttributes, requestParameters.showHierarchies, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the schema for global queries, those, that are not assigned to a project.
     * @summary View schema for global queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public viewSchemaForGlobalQueries(options?: AxiosRequestConfig) {
        return QueriesApiFp(this.configuration).viewSchemaForGlobalQueries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the schema for project queries.
     * @summary View schema for project queries
     * @param {QueriesApiViewSchemaForProjectQueriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public viewSchemaForProjectQueries(requestParameters: QueriesApiViewSchemaForProjectQueriesRequest, options?: AxiosRequestConfig) {
        return QueriesApiFp(this.configuration).viewSchemaForProjectQueries(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryColumnsApi - axios parameter creator
 * @export
 */
export const QueryColumnsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an individual QueryColumn as identified by the `id` parameter.
         * @summary View Query Column
         * @param {string} id QueryColumn id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewQueryColumn: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewQueryColumn', 'id', id)
            const localVarPath = `/api/v3/queries/columns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryColumnsApi - functional programming interface
 * @export
 */
export const QueryColumnsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryColumnsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an individual QueryColumn as identified by the `id` parameter.
         * @summary View Query Column
         * @param {string} id QueryColumn id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewQueryColumn(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryColumnModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewQueryColumn(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryColumnsApi - factory interface
 * @export
 */
export const QueryColumnsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryColumnsApiFp(configuration)
    return {
        /**
         * Retrieve an individual QueryColumn as identified by the `id` parameter.
         * @summary View Query Column
         * @param {string} id QueryColumn id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewQueryColumn(id: string, options?: any): AxiosPromise<QueryColumnModel> {
            return localVarFp.viewQueryColumn(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewQueryColumn operation in QueryColumnsApi.
 * @export
 * @interface QueryColumnsApiViewQueryColumnRequest
 */
export interface QueryColumnsApiViewQueryColumnRequest {
    /**
     * QueryColumn id
     * @type {string}
     * @memberof QueryColumnsApiViewQueryColumn
     */
    readonly id: string
}

/**
 * QueryColumnsApi - object-oriented interface
 * @export
 * @class QueryColumnsApi
 * @extends {BaseAPI}
 */
export class QueryColumnsApi extends BaseAPI {
    /**
     * Retrieve an individual QueryColumn as identified by the `id` parameter.
     * @summary View Query Column
     * @param {QueryColumnsApiViewQueryColumnRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryColumnsApi
     */
    public viewQueryColumn(requestParameters: QueryColumnsApiViewQueryColumnRequest, options?: AxiosRequestConfig) {
        return QueryColumnsApiFp(this.configuration).viewQueryColumn(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryFilterInstanceSchemaApi - axios parameter creator
 * @export
 */
export const QueryFilterInstanceSchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of QueryFilterInstanceSchemas defined for a global query. That is a query not assigned to a project.
         * @summary List Query Filter Instance Schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryFilterInstanceSchemas: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/queries/filter_instance_schemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of QueryFilterInstanceSchemas defined for a query of the specified project.
         * @summary List Query Filter Instance Schemas for Project
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryFilterInstanceSchemasForProject: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listQueryFilterInstanceSchemasForProject', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/queries/filter_instance_schemas`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an individual QueryFilterInstanceSchema as identified by the id parameter.
         * @summary View Query Filter Instance Schema
         * @param {string} id QueryFilterInstanceSchema identifier. The identifier is the filter identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewQueryFilterInstanceSchema: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewQueryFilterInstanceSchema', 'id', id)
            const localVarPath = `/api/v3/queries/filter_instance_schemas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryFilterInstanceSchemaApi - functional programming interface
 * @export
 */
export const QueryFilterInstanceSchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryFilterInstanceSchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the list of QueryFilterInstanceSchemas defined for a global query. That is a query not assigned to a project.
         * @summary List Query Filter Instance Schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQueryFilterInstanceSchemas(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listQueryFilterInstanceSchemas(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of QueryFilterInstanceSchemas defined for a query of the specified project.
         * @summary List Query Filter Instance Schemas for Project
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQueryFilterInstanceSchemasForProject(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listQueryFilterInstanceSchemasForProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an individual QueryFilterInstanceSchema as identified by the id parameter.
         * @summary View Query Filter Instance Schema
         * @param {string} id QueryFilterInstanceSchema identifier. The identifier is the filter identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewQueryFilterInstanceSchema(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryFilterInstanceSchemaModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewQueryFilterInstanceSchema(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryFilterInstanceSchemaApi - factory interface
 * @export
 */
export const QueryFilterInstanceSchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryFilterInstanceSchemaApiFp(configuration)
    return {
        /**
         * Returns the list of QueryFilterInstanceSchemas defined for a global query. That is a query not assigned to a project.
         * @summary List Query Filter Instance Schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryFilterInstanceSchemas(options?: any): AxiosPromise<object> {
            return localVarFp.listQueryFilterInstanceSchemas(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of QueryFilterInstanceSchemas defined for a query of the specified project.
         * @summary List Query Filter Instance Schemas for Project
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryFilterInstanceSchemasForProject(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.listQueryFilterInstanceSchemasForProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an individual QueryFilterInstanceSchema as identified by the id parameter.
         * @summary View Query Filter Instance Schema
         * @param {string} id QueryFilterInstanceSchema identifier. The identifier is the filter identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewQueryFilterInstanceSchema(id: string, options?: any): AxiosPromise<QueryFilterInstanceSchemaModel> {
            return localVarFp.viewQueryFilterInstanceSchema(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listQueryFilterInstanceSchemasForProject operation in QueryFilterInstanceSchemaApi.
 * @export
 * @interface QueryFilterInstanceSchemaApiListQueryFilterInstanceSchemasForProjectRequest
 */
export interface QueryFilterInstanceSchemaApiListQueryFilterInstanceSchemasForProjectRequest {
    /**
     * Project id
     * @type {number}
     * @memberof QueryFilterInstanceSchemaApiListQueryFilterInstanceSchemasForProject
     */
    readonly id: number
}

/**
 * Request parameters for viewQueryFilterInstanceSchema operation in QueryFilterInstanceSchemaApi.
 * @export
 * @interface QueryFilterInstanceSchemaApiViewQueryFilterInstanceSchemaRequest
 */
export interface QueryFilterInstanceSchemaApiViewQueryFilterInstanceSchemaRequest {
    /**
     * QueryFilterInstanceSchema identifier. The identifier is the filter identifier.
     * @type {string}
     * @memberof QueryFilterInstanceSchemaApiViewQueryFilterInstanceSchema
     */
    readonly id: string
}

/**
 * QueryFilterInstanceSchemaApi - object-oriented interface
 * @export
 * @class QueryFilterInstanceSchemaApi
 * @extends {BaseAPI}
 */
export class QueryFilterInstanceSchemaApi extends BaseAPI {
    /**
     * Returns the list of QueryFilterInstanceSchemas defined for a global query. That is a query not assigned to a project.
     * @summary List Query Filter Instance Schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryFilterInstanceSchemaApi
     */
    public listQueryFilterInstanceSchemas(options?: AxiosRequestConfig) {
        return QueryFilterInstanceSchemaApiFp(this.configuration).listQueryFilterInstanceSchemas(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of QueryFilterInstanceSchemas defined for a query of the specified project.
     * @summary List Query Filter Instance Schemas for Project
     * @param {QueryFilterInstanceSchemaApiListQueryFilterInstanceSchemasForProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryFilterInstanceSchemaApi
     */
    public listQueryFilterInstanceSchemasForProject(requestParameters: QueryFilterInstanceSchemaApiListQueryFilterInstanceSchemasForProjectRequest, options?: AxiosRequestConfig) {
        return QueryFilterInstanceSchemaApiFp(this.configuration).listQueryFilterInstanceSchemasForProject(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an individual QueryFilterInstanceSchema as identified by the id parameter.
     * @summary View Query Filter Instance Schema
     * @param {QueryFilterInstanceSchemaApiViewQueryFilterInstanceSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryFilterInstanceSchemaApi
     */
    public viewQueryFilterInstanceSchema(requestParameters: QueryFilterInstanceSchemaApiViewQueryFilterInstanceSchemaRequest, options?: AxiosRequestConfig) {
        return QueryFilterInstanceSchemaApiFp(this.configuration).viewQueryFilterInstanceSchema(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryFiltersApi - axios parameter creator
 * @export
 */
export const QueryFiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an individual QueryFilter as identified by the id parameter.
         * @summary View Query Filter
         * @param {string} id QueryFilter identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewQueryFilter: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewQueryFilter', 'id', id)
            const localVarPath = `/api/v3/queries/filters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryFiltersApi - functional programming interface
 * @export
 */
export const QueryFiltersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryFiltersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an individual QueryFilter as identified by the id parameter.
         * @summary View Query Filter
         * @param {string} id QueryFilter identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewQueryFilter(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryFilterModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewQueryFilter(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryFiltersApi - factory interface
 * @export
 */
export const QueryFiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryFiltersApiFp(configuration)
    return {
        /**
         * Retrieve an individual QueryFilter as identified by the id parameter.
         * @summary View Query Filter
         * @param {string} id QueryFilter identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewQueryFilter(id: string, options?: any): AxiosPromise<QueryFilterModel> {
            return localVarFp.viewQueryFilter(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewQueryFilter operation in QueryFiltersApi.
 * @export
 * @interface QueryFiltersApiViewQueryFilterRequest
 */
export interface QueryFiltersApiViewQueryFilterRequest {
    /**
     * QueryFilter identifier
     * @type {string}
     * @memberof QueryFiltersApiViewQueryFilter
     */
    readonly id: string
}

/**
 * QueryFiltersApi - object-oriented interface
 * @export
 * @class QueryFiltersApi
 * @extends {BaseAPI}
 */
export class QueryFiltersApi extends BaseAPI {
    /**
     * Retrieve an individual QueryFilter as identified by the id parameter.
     * @summary View Query Filter
     * @param {QueryFiltersApiViewQueryFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryFiltersApi
     */
    public viewQueryFilter(requestParameters: QueryFiltersApiViewQueryFilterRequest, options?: AxiosRequestConfig) {
        return QueryFiltersApiFp(this.configuration).viewQueryFilter(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryOperatorsApi - axios parameter creator
 * @export
 */
export const QueryOperatorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an individual QueryOperator as identified by the `id` parameter.
         * @summary View Query Operator
         * @param {string} id QueryOperator id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewQueryOperator: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewQueryOperator', 'id', id)
            const localVarPath = `/api/v3/queries/operators/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryOperatorsApi - functional programming interface
 * @export
 */
export const QueryOperatorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryOperatorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an individual QueryOperator as identified by the `id` parameter.
         * @summary View Query Operator
         * @param {string} id QueryOperator id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewQueryOperator(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryOperatorModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewQueryOperator(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryOperatorsApi - factory interface
 * @export
 */
export const QueryOperatorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryOperatorsApiFp(configuration)
    return {
        /**
         * Retrieve an individual QueryOperator as identified by the `id` parameter.
         * @summary View Query Operator
         * @param {string} id QueryOperator id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewQueryOperator(id: string, options?: any): AxiosPromise<QueryOperatorModel> {
            return localVarFp.viewQueryOperator(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewQueryOperator operation in QueryOperatorsApi.
 * @export
 * @interface QueryOperatorsApiViewQueryOperatorRequest
 */
export interface QueryOperatorsApiViewQueryOperatorRequest {
    /**
     * QueryOperator id
     * @type {string}
     * @memberof QueryOperatorsApiViewQueryOperator
     */
    readonly id: string
}

/**
 * QueryOperatorsApi - object-oriented interface
 * @export
 * @class QueryOperatorsApi
 * @extends {BaseAPI}
 */
export class QueryOperatorsApi extends BaseAPI {
    /**
     * Retrieve an individual QueryOperator as identified by the `id` parameter.
     * @summary View Query Operator
     * @param {QueryOperatorsApiViewQueryOperatorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryOperatorsApi
     */
    public viewQueryOperator(requestParameters: QueryOperatorsApiViewQueryOperatorRequest, options?: AxiosRequestConfig) {
        return QueryOperatorsApiFp(this.configuration).viewQueryOperator(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuerySortBysApi - axios parameter creator
 * @export
 */
export const QuerySortBysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an individual QuerySortBy as identified by the id parameter.
         * @summary View Query Sort By
         * @param {string} id QuerySortBy identifier. The identifier is a combination of the column identifier and the direction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewQuerySortBy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewQuerySortBy', 'id', id)
            const localVarPath = `/api/v3/queries/sort_bys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuerySortBysApi - functional programming interface
 * @export
 */
export const QuerySortBysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuerySortBysApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an individual QuerySortBy as identified by the id parameter.
         * @summary View Query Sort By
         * @param {string} id QuerySortBy identifier. The identifier is a combination of the column identifier and the direction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewQuerySortBy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySortByModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewQuerySortBy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QuerySortBysApi - factory interface
 * @export
 */
export const QuerySortBysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuerySortBysApiFp(configuration)
    return {
        /**
         * Retrieve an individual QuerySortBy as identified by the id parameter.
         * @summary View Query Sort By
         * @param {string} id QuerySortBy identifier. The identifier is a combination of the column identifier and the direction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewQuerySortBy(id: string, options?: any): AxiosPromise<QuerySortByModel> {
            return localVarFp.viewQuerySortBy(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewQuerySortBy operation in QuerySortBysApi.
 * @export
 * @interface QuerySortBysApiViewQuerySortByRequest
 */
export interface QuerySortBysApiViewQuerySortByRequest {
    /**
     * QuerySortBy identifier. The identifier is a combination of the column identifier and the direction.
     * @type {string}
     * @memberof QuerySortBysApiViewQuerySortBy
     */
    readonly id: string
}

/**
 * QuerySortBysApi - object-oriented interface
 * @export
 * @class QuerySortBysApi
 * @extends {BaseAPI}
 */
export class QuerySortBysApi extends BaseAPI {
    /**
     * Retrieve an individual QuerySortBy as identified by the id parameter.
     * @summary View Query Sort By
     * @param {QuerySortBysApiViewQuerySortByRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuerySortBysApi
     */
    public viewQuerySortBy(requestParameters: QuerySortBysApiViewQuerySortByRequest, options?: AxiosRequestConfig) {
        return QuerySortBysApiFp(this.configuration).viewQuerySortBy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RelationsApi - axios parameter creator
 * @export
 */
export const RelationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the relation.
         * @summary Delete Relation
         * @param {number} id Relation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelation: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRelation', 'id', id)
            const localVarPath = `/api/v3/relations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. It is only allowed to provide properties or links supporting the **write** operation.  Note that changing the `type` of a relation invariably also changes the respective `reverseType` as well as the \"name\" of it. The returned Relation object will reflect that change. For instance if you change a Relation\'s `type` to \"follows\" then the `reverseType` will be changed to `precedes`.
         * @summary Edit Relation
         * @param {number} id Relation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRelation: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editRelation', 'id', id)
            const localVarPath = `/api/v3/relations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all relations according to the given (optional, logically conjunctive) filters and ordered by ID. The response only includes relations between work packages which the user is allowed to see.
         * @summary List Relations
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Valid fields to filter by are:  + id - ID of relation  + from - ID of work package from which the filtered relations emanates.  + to - ID of work package to which this related points.  + involved - ID of either the &#x60;from&#x60; or the &#x60;to&#x60; work package.  + type - The type of relation to filter by, e.g. \&quot;follows\&quot;.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRelations: async (filters?: string, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Relation edit form
         * @param {number} id ID of the relation being modified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relationEditForm: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('relationEditForm', 'id', id)
            const localVarPath = `/api/v3/relations/{id}/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View Relation
         * @param {number} id Relation id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRelation: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewRelation', 'id', id)
            const localVarPath = `/api/v3/relations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View relation schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRelationSchema: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/relations/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View relation schema for type
         * @param {string} type Type of the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRelationSchemaForType: async (type: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('viewRelationSchemaForType', 'type', type)
            const localVarPath = `/api/v3/relations/schema/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelationsApi - functional programming interface
 * @export
 */
export const RelationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RelationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the relation.
         * @summary Delete Relation
         * @param {number} id Relation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRelation(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. It is only allowed to provide properties or links supporting the **write** operation.  Note that changing the `type` of a relation invariably also changes the respective `reverseType` as well as the \"name\" of it. The returned Relation object will reflect that change. For instance if you change a Relation\'s `type` to \"follows\" then the `reverseType` will be changed to `precedes`.
         * @summary Edit Relation
         * @param {number} id Relation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editRelation(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editRelation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all relations according to the given (optional, logically conjunctive) filters and ordered by ID. The response only includes relations between work packages which the user is allowed to see.
         * @summary List Relations
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Valid fields to filter by are:  + id - ID of relation  + from - ID of work package from which the filtered relations emanates.  + to - ID of work package to which this related points.  + involved - ID of either the &#x60;from&#x60; or the &#x60;to&#x60; work package.  + type - The type of relation to filter by, e.g. \&quot;follows\&quot;.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRelations(filters?: string, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRelations(filters, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Relation edit form
         * @param {number} id ID of the relation being modified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async relationEditForm(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.relationEditForm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View Relation
         * @param {number} id Relation id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewRelation(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewRelation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View relation schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewRelationSchema(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewRelationSchema(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View relation schema for type
         * @param {string} type Type of the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewRelationSchemaForType(type: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewRelationSchemaForType(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RelationsApi - factory interface
 * @export
 */
export const RelationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RelationsApiFp(configuration)
    return {
        /**
         * Deletes the relation.
         * @summary Delete Relation
         * @param {number} id Relation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelation(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRelation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. It is only allowed to provide properties or links supporting the **write** operation.  Note that changing the `type` of a relation invariably also changes the respective `reverseType` as well as the \"name\" of it. The returned Relation object will reflect that change. For instance if you change a Relation\'s `type` to \"follows\" then the `reverseType` will be changed to `precedes`.
         * @summary Edit Relation
         * @param {number} id Relation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRelation(id: number, options?: any): AxiosPromise<RelationModel> {
            return localVarFp.editRelation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all relations according to the given (optional, logically conjunctive) filters and ordered by ID. The response only includes relations between work packages which the user is allowed to see.
         * @summary List Relations
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Valid fields to filter by are:  + id - ID of relation  + from - ID of work package from which the filtered relations emanates.  + to - ID of work package to which this related points.  + involved - ID of either the &#x60;from&#x60; or the &#x60;to&#x60; work package.  + type - The type of relation to filter by, e.g. \&quot;follows\&quot;.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRelations(filters?: string, sortBy?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listRelations(filters, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Relation edit form
         * @param {number} id ID of the relation being modified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relationEditForm(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.relationEditForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View Relation
         * @param {number} id Relation id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRelation(id: number, options?: any): AxiosPromise<RelationModel> {
            return localVarFp.viewRelation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View relation schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRelationSchema(options?: any): AxiosPromise<object> {
            return localVarFp.viewRelationSchema(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View relation schema for type
         * @param {string} type Type of the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRelationSchemaForType(type: string, options?: any): AxiosPromise<object> {
            return localVarFp.viewRelationSchemaForType(type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteRelation operation in RelationsApi.
 * @export
 * @interface RelationsApiDeleteRelationRequest
 */
export interface RelationsApiDeleteRelationRequest {
    /**
     * Relation ID
     * @type {number}
     * @memberof RelationsApiDeleteRelation
     */
    readonly id: number
}

/**
 * Request parameters for editRelation operation in RelationsApi.
 * @export
 * @interface RelationsApiEditRelationRequest
 */
export interface RelationsApiEditRelationRequest {
    /**
     * Relation ID
     * @type {number}
     * @memberof RelationsApiEditRelation
     */
    readonly id: number
}

/**
 * Request parameters for listRelations operation in RelationsApi.
 * @export
 * @interface RelationsApiListRelationsRequest
 */
export interface RelationsApiListRelationsRequest {
    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Valid fields to filter by are:  + id - ID of relation  + from - ID of work package from which the filtered relations emanates.  + to - ID of work package to which this related points.  + involved - ID of either the &#x60;from&#x60; or the &#x60;to&#x60; work package.  + type - The type of relation to filter by, e.g. \&quot;follows\&quot;.
     * @type {string}
     * @memberof RelationsApiListRelations
     */
    readonly filters?: string

    /**
     * JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
     * @type {string}
     * @memberof RelationsApiListRelations
     */
    readonly sortBy?: string
}

/**
 * Request parameters for relationEditForm operation in RelationsApi.
 * @export
 * @interface RelationsApiRelationEditFormRequest
 */
export interface RelationsApiRelationEditFormRequest {
    /**
     * ID of the relation being modified
     * @type {number}
     * @memberof RelationsApiRelationEditForm
     */
    readonly id: number
}

/**
 * Request parameters for viewRelation operation in RelationsApi.
 * @export
 * @interface RelationsApiViewRelationRequest
 */
export interface RelationsApiViewRelationRequest {
    /**
     * Relation id
     * @type {number}
     * @memberof RelationsApiViewRelation
     */
    readonly id: number
}

/**
 * Request parameters for viewRelationSchemaForType operation in RelationsApi.
 * @export
 * @interface RelationsApiViewRelationSchemaForTypeRequest
 */
export interface RelationsApiViewRelationSchemaForTypeRequest {
    /**
     * Type of the schema
     * @type {string}
     * @memberof RelationsApiViewRelationSchemaForType
     */
    readonly type: string
}

/**
 * RelationsApi - object-oriented interface
 * @export
 * @class RelationsApi
 * @extends {BaseAPI}
 */
export class RelationsApi extends BaseAPI {
    /**
     * Deletes the relation.
     * @summary Delete Relation
     * @param {RelationsApiDeleteRelationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public deleteRelation(requestParameters: RelationsApiDeleteRelationRequest, options?: AxiosRequestConfig) {
        return RelationsApiFp(this.configuration).deleteRelation(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. It is only allowed to provide properties or links supporting the **write** operation.  Note that changing the `type` of a relation invariably also changes the respective `reverseType` as well as the \"name\" of it. The returned Relation object will reflect that change. For instance if you change a Relation\'s `type` to \"follows\" then the `reverseType` will be changed to `precedes`.
     * @summary Edit Relation
     * @param {RelationsApiEditRelationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public editRelation(requestParameters: RelationsApiEditRelationRequest, options?: AxiosRequestConfig) {
        return RelationsApiFp(this.configuration).editRelation(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all relations according to the given (optional, logically conjunctive) filters and ordered by ID. The response only includes relations between work packages which the user is allowed to see.
     * @summary List Relations
     * @param {RelationsApiListRelationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public listRelations(requestParameters: RelationsApiListRelationsRequest = {}, options?: AxiosRequestConfig) {
        return RelationsApiFp(this.configuration).listRelations(requestParameters.filters, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Relation edit form
     * @param {RelationsApiRelationEditFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public relationEditForm(requestParameters: RelationsApiRelationEditFormRequest, options?: AxiosRequestConfig) {
        return RelationsApiFp(this.configuration).relationEditForm(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View Relation
     * @param {RelationsApiViewRelationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public viewRelation(requestParameters: RelationsApiViewRelationRequest, options?: AxiosRequestConfig) {
        return RelationsApiFp(this.configuration).viewRelation(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View relation schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public viewRelationSchema(options?: AxiosRequestConfig) {
        return RelationsApiFp(this.configuration).viewRelationSchema(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View relation schema for type
     * @param {RelationsApiViewRelationSchemaForTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public viewRelationSchemaForType(requestParameters: RelationsApiViewRelationSchemaForTypeRequest, options?: AxiosRequestConfig) {
        return RelationsApiFp(this.configuration).viewRelationSchemaForType(requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RevisionsApi - axios parameter creator
 * @export
 */
export const RevisionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View revision
         * @param {number} id Revision id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRevision: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewRevision', 'id', id)
            const localVarPath = `/api/v3/revisions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RevisionsApi - functional programming interface
 * @export
 */
export const RevisionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RevisionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary View revision
         * @param {number} id Revision id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewRevision(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RevisionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewRevision(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RevisionsApi - factory interface
 * @export
 */
export const RevisionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RevisionsApiFp(configuration)
    return {
        /**
         * 
         * @summary View revision
         * @param {number} id Revision id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRevision(id: number, options?: any): AxiosPromise<RevisionModel> {
            return localVarFp.viewRevision(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewRevision operation in RevisionsApi.
 * @export
 * @interface RevisionsApiViewRevisionRequest
 */
export interface RevisionsApiViewRevisionRequest {
    /**
     * Revision id
     * @type {number}
     * @memberof RevisionsApiViewRevision
     */
    readonly id: number
}

/**
 * RevisionsApi - object-oriented interface
 * @export
 * @class RevisionsApi
 * @extends {BaseAPI}
 */
export class RevisionsApi extends BaseAPI {
    /**
     * 
     * @summary View revision
     * @param {RevisionsApiViewRevisionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RevisionsApi
     */
    public viewRevision(requestParameters: RevisionsApiViewRevisionRequest, options?: AxiosRequestConfig) {
        return RevisionsApiFp(this.configuration).viewRevision(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all defined roles. This includes built in roles like \'Anonymous\' and \'Non member\'.
         * @summary List roles
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + grantable: filters roles based on whether they are selectable for a membership  + unit: filters roles based on the unit (\&#39;project\&#39; or \&#39;system\&#39;) for which they are selectable for a membership
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch an individual role.
         * @summary View role
         * @param {number} id Role id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRole: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewRole', 'id', id)
            const localVarPath = `/api/v3/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * List all defined roles. This includes built in roles like \'Anonymous\' and \'Non member\'.
         * @summary List roles
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + grantable: filters roles based on whether they are selectable for a membership  + unit: filters roles based on the unit (\&#39;project\&#39; or \&#39;system\&#39;) for which they are selectable for a membership
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch an individual role.
         * @summary View role
         * @param {number} id Role id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewRole(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewRole(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * List all defined roles. This includes built in roles like \'Anonymous\' and \'Non member\'.
         * @summary List roles
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + grantable: filters roles based on whether they are selectable for a membership  + unit: filters roles based on the unit (\&#39;project\&#39; or \&#39;system\&#39;) for which they are selectable for a membership
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(filters?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listRoles(filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch an individual role.
         * @summary View role
         * @param {number} id Role id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRole(id: number, options?: any): AxiosPromise<RoleModel> {
            return localVarFp.viewRole(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listRoles operation in RolesApi.
 * @export
 * @interface RolesApiListRolesRequest
 */
export interface RolesApiListRolesRequest {
    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + grantable: filters roles based on whether they are selectable for a membership  + unit: filters roles based on the unit (\&#39;project\&#39; or \&#39;system\&#39;) for which they are selectable for a membership
     * @type {string}
     * @memberof RolesApiListRoles
     */
    readonly filters?: string
}

/**
 * Request parameters for viewRole operation in RolesApi.
 * @export
 * @interface RolesApiViewRoleRequest
 */
export interface RolesApiViewRoleRequest {
    /**
     * Role id
     * @type {number}
     * @memberof RolesApiViewRole
     */
    readonly id: number
}

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * List all defined roles. This includes built in roles like \'Anonymous\' and \'Non member\'.
     * @summary List roles
     * @param {RolesApiListRolesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public listRoles(requestParameters: RolesApiListRolesRequest = {}, options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).listRoles(requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch an individual role.
     * @summary View role
     * @param {RolesApiViewRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public viewRole(requestParameters: RolesApiViewRoleRequest, options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).viewRole(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RootApi - axios parameter creator
 * @export
 */
export const RootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the root resource, containing basic information about the server instance and a collection of useful links.
         * @summary View root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRoot: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RootApi - functional programming interface
 * @export
 */
export const RootApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RootApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the root resource, containing basic information about the server instance and a collection of useful links.
         * @summary View root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewRoot(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewRoot(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RootApi - factory interface
 * @export
 */
export const RootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RootApiFp(configuration)
    return {
        /**
         * Returns the root resource, containing basic information about the server instance and a collection of useful links.
         * @summary View root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRoot(options?: any): AxiosPromise<RootModel> {
            return localVarFp.viewRoot(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
export class RootApi extends BaseAPI {
    /**
     * Returns the root resource, containing basic information about the server instance and a collection of useful links.
     * @summary View root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    public viewRoot(options?: AxiosRequestConfig) {
        return RootApiFp(this.configuration).viewRoot(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemasApi - axios parameter creator
 * @export
 */
export const SchemasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This is an example of how a schema might look like. Note that this endpoint does not exist in the actual implementation.
         * @summary view the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewTheSchema: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/example/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemasApi - functional programming interface
 * @export
 */
export const SchemasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemasApiAxiosParamCreator(configuration)
    return {
        /**
         * This is an example of how a schema might look like. Note that this endpoint does not exist in the actual implementation.
         * @summary view the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewTheSchema(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewTheSchema(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemasApi - factory interface
 * @export
 */
export const SchemasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemasApiFp(configuration)
    return {
        /**
         * This is an example of how a schema might look like. Note that this endpoint does not exist in the actual implementation.
         * @summary view the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewTheSchema(options?: any): AxiosPromise<object> {
            return localVarFp.viewTheSchema(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemasApi - object-oriented interface
 * @export
 * @class SchemasApi
 * @extends {BaseAPI}
 */
export class SchemasApi extends BaseAPI {
    /**
     * This is an example of how a schema might look like. Note that this endpoint does not exist in the actual implementation.
     * @summary view the schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public viewTheSchema(options?: AxiosRequestConfig) {
        return SchemasApiFp(this.configuration).viewTheSchema(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatusesApi - axios parameter creator
 * @export
 */
export const StatusesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllStatuses: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View Status
         * @param {number} id Status id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewStatus: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewStatus', 'id', id)
            const localVarPath = `/api/v3/statuses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusesApi - functional programming interface
 * @export
 */
export const StatusesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllStatuses(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllStatuses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View Status
         * @param {number} id Status id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewStatus(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewStatus(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatusesApi - factory interface
 * @export
 */
export const StatusesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusesApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllStatuses(options?: any): AxiosPromise<object> {
            return localVarFp.listAllStatuses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View Status
         * @param {number} id Status id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewStatus(id: number, options?: any): AxiosPromise<StatusModel> {
            return localVarFp.viewStatus(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewStatus operation in StatusesApi.
 * @export
 * @interface StatusesApiViewStatusRequest
 */
export interface StatusesApiViewStatusRequest {
    /**
     * Status id
     * @type {number}
     * @memberof StatusesApiViewStatus
     */
    readonly id: number
}

/**
 * StatusesApi - object-oriented interface
 * @export
 * @class StatusesApi
 * @extends {BaseAPI}
 */
export class StatusesApi extends BaseAPI {
    /**
     * 
     * @summary List all Statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusesApi
     */
    public listAllStatuses(options?: AxiosRequestConfig) {
        return StatusesApiFp(this.configuration).listAllStatuses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View Status
     * @param {StatusesApiViewStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusesApi
     */
    public viewStatus(requestParameters: StatusesApiViewStatusRequest, options?: AxiosRequestConfig) {
        return StatusesApiFp(this.configuration).viewStatus(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TimeEntriesApi - axios parameter creator
 * @export
 */
export const TimeEntriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of projects in which a time entry can be created in or be assigned to on update. The list contains all projects in which the user issuing the request has the necessary permissions.
         * @summary Available projects for time entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableProjectsForTimeEntries: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/time_entries/available_projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new time entry applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a time entries\' attributes and are accepted by the endpoint.
         * @summary Create Time entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimeEntry: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/time_entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes the specified time entry.
         * @summary Delete time entry
         * @param {number} id Time entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTimeEntry: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTimeEntry', 'id', id)
            const localVarPath = `/api/v3/time_entries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists time entries. The time entries returned depend on the filters provided and also on the permission of the requesting user.
         * @summary List time entries
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + hours: Sort by logged hours  + spent_on: Sort by spent on date  + created_at: Sort by time entry creation datetime  + updated_at: Sort by the time the time entry was updated last
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + work_package: Filter time entries by work package  + project: Filter time entries by project  + user: Filter time entries by users  + spent_on: Filter time entries by spent on date  + created_at: Filter time entries by creation datetime  + updated_at: Filter time entries by the last time they where updated  + activity: Filter time entries by time entry activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimeEntries: async (offset?: number, pageSize?: number, sortBy?: string, filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/time_entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Time entry create form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeEntryCreateForm: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/time_entries/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Time entry update form
         * @param {number} id Time entries activity id
         * @param {number} body Time entries activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeEntryUpdateForm: async (id: number, body: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('timeEntryUpdateForm', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('timeEntryUpdateForm', 'body', body)
            const localVarPath = `/api/v3/time_entries/{id}/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the given time entry by applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a time entries\' attributes and are accepted by the endpoint.
         * @summary Update Time entry
         * @param {number} id Time entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimeEntry: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTimeEntry', 'id', id)
            const localVarPath = `/api/v3/time_entries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View time entry
         * @param {number} id time entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewTimeEntry: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewTimeEntry', 'id', id)
            const localVarPath = `/api/v3/time_entries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View time entry schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewTimeEntrySchema: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/time_entries/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeEntriesApi - functional programming interface
 * @export
 */
export const TimeEntriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeEntriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a list of projects in which a time entry can be created in or be assigned to on update. The list contains all projects in which the user issuing the request has the necessary permissions.
         * @summary Available projects for time entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableProjectsForTimeEntries(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableProjectsForTimeEntries(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new time entry applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a time entries\' attributes and are accepted by the endpoint.
         * @summary Create Time entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTimeEntry(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTimeEntry(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes the specified time entry.
         * @summary Delete time entry
         * @param {number} id Time entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTimeEntry(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTimeEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists time entries. The time entries returned depend on the filters provided and also on the permission of the requesting user.
         * @summary List time entries
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + hours: Sort by logged hours  + spent_on: Sort by spent on date  + created_at: Sort by time entry creation datetime  + updated_at: Sort by the time the time entry was updated last
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + work_package: Filter time entries by work package  + project: Filter time entries by project  + user: Filter time entries by users  + spent_on: Filter time entries by spent on date  + created_at: Filter time entries by creation datetime  + updated_at: Filter time entries by the last time they where updated  + activity: Filter time entries by time entry activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTimeEntries(offset?: number, pageSize?: number, sortBy?: string, filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTimeEntries(offset, pageSize, sortBy, filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Time entry create form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeEntryCreateForm(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeEntryCreateForm(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Time entry update form
         * @param {number} id Time entries activity id
         * @param {number} body Time entries activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeEntryUpdateForm(id: number, body: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeEntryUpdateForm(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the given time entry by applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a time entries\' attributes and are accepted by the endpoint.
         * @summary Update Time entry
         * @param {number} id Time entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTimeEntry(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTimeEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View time entry
         * @param {number} id time entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewTimeEntry(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewTimeEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View time entry schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewTimeEntrySchema(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewTimeEntrySchema(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TimeEntriesApi - factory interface
 * @export
 */
export const TimeEntriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeEntriesApiFp(configuration)
    return {
        /**
         * Gets a list of projects in which a time entry can be created in or be assigned to on update. The list contains all projects in which the user issuing the request has the necessary permissions.
         * @summary Available projects for time entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableProjectsForTimeEntries(options?: any): AxiosPromise<object> {
            return localVarFp.availableProjectsForTimeEntries(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new time entry applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a time entries\' attributes and are accepted by the endpoint.
         * @summary Create Time entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimeEntry(options?: any): AxiosPromise<object> {
            return localVarFp.createTimeEntry(options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes the specified time entry.
         * @summary Delete time entry
         * @param {number} id Time entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTimeEntry(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTimeEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists time entries. The time entries returned depend on the filters provided and also on the permission of the requesting user.
         * @summary List time entries
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + hours: Sort by logged hours  + spent_on: Sort by spent on date  + created_at: Sort by time entry creation datetime  + updated_at: Sort by the time the time entry was updated last
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + work_package: Filter time entries by work package  + project: Filter time entries by project  + user: Filter time entries by users  + spent_on: Filter time entries by spent on date  + created_at: Filter time entries by creation datetime  + updated_at: Filter time entries by the last time they where updated  + activity: Filter time entries by time entry activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimeEntries(offset?: number, pageSize?: number, sortBy?: string, filters?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listTimeEntries(offset, pageSize, sortBy, filters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Time entry create form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeEntryCreateForm(options?: any): AxiosPromise<void> {
            return localVarFp.timeEntryCreateForm(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Time entry update form
         * @param {number} id Time entries activity id
         * @param {number} body Time entries activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeEntryUpdateForm(id: number, body: number, options?: any): AxiosPromise<void> {
            return localVarFp.timeEntryUpdateForm(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the given time entry by applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a time entries\' attributes and are accepted by the endpoint.
         * @summary Update Time entry
         * @param {number} id Time entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimeEntry(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.updateTimeEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View time entry
         * @param {number} id time entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewTimeEntry(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.viewTimeEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View time entry schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewTimeEntrySchema(options?: any): AxiosPromise<object> {
            return localVarFp.viewTimeEntrySchema(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteTimeEntry operation in TimeEntriesApi.
 * @export
 * @interface TimeEntriesApiDeleteTimeEntryRequest
 */
export interface TimeEntriesApiDeleteTimeEntryRequest {
    /**
     * Time entry id
     * @type {number}
     * @memberof TimeEntriesApiDeleteTimeEntry
     */
    readonly id: number
}

/**
 * Request parameters for listTimeEntries operation in TimeEntriesApi.
 * @export
 * @interface TimeEntriesApiListTimeEntriesRequest
 */
export interface TimeEntriesApiListTimeEntriesRequest {
    /**
     * Page number inside the requested collection.
     * @type {number}
     * @memberof TimeEntriesApiListTimeEntries
     */
    readonly offset?: number

    /**
     * Number of elements to display per page.
     * @type {number}
     * @memberof TimeEntriesApiListTimeEntries
     */
    readonly pageSize?: number

    /**
     * JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:  + id: Sort by primary key  + hours: Sort by logged hours  + spent_on: Sort by spent on date  + created_at: Sort by time entry creation datetime  + updated_at: Sort by the time the time entry was updated last
     * @type {string}
     * @memberof TimeEntriesApiListTimeEntries
     */
    readonly sortBy?: string

    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + work_package: Filter time entries by work package  + project: Filter time entries by project  + user: Filter time entries by users  + spent_on: Filter time entries by spent on date  + created_at: Filter time entries by creation datetime  + updated_at: Filter time entries by the last time they where updated  + activity: Filter time entries by time entry activity
     * @type {string}
     * @memberof TimeEntriesApiListTimeEntries
     */
    readonly filters?: string
}

/**
 * Request parameters for timeEntryUpdateForm operation in TimeEntriesApi.
 * @export
 * @interface TimeEntriesApiTimeEntryUpdateFormRequest
 */
export interface TimeEntriesApiTimeEntryUpdateFormRequest {
    /**
     * Time entries activity id
     * @type {number}
     * @memberof TimeEntriesApiTimeEntryUpdateForm
     */
    readonly id: number

    /**
     * Time entries activity id
     * @type {number}
     * @memberof TimeEntriesApiTimeEntryUpdateForm
     */
    readonly body: number
}

/**
 * Request parameters for updateTimeEntry operation in TimeEntriesApi.
 * @export
 * @interface TimeEntriesApiUpdateTimeEntryRequest
 */
export interface TimeEntriesApiUpdateTimeEntryRequest {
    /**
     * Time entry id
     * @type {number}
     * @memberof TimeEntriesApiUpdateTimeEntry
     */
    readonly id: number
}

/**
 * Request parameters for viewTimeEntry operation in TimeEntriesApi.
 * @export
 * @interface TimeEntriesApiViewTimeEntryRequest
 */
export interface TimeEntriesApiViewTimeEntryRequest {
    /**
     * time entry id
     * @type {number}
     * @memberof TimeEntriesApiViewTimeEntry
     */
    readonly id: number
}

/**
 * TimeEntriesApi - object-oriented interface
 * @export
 * @class TimeEntriesApi
 * @extends {BaseAPI}
 */
export class TimeEntriesApi extends BaseAPI {
    /**
     * Gets a list of projects in which a time entry can be created in or be assigned to on update. The list contains all projects in which the user issuing the request has the necessary permissions.
     * @summary Available projects for time entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeEntriesApi
     */
    public availableProjectsForTimeEntries(options?: AxiosRequestConfig) {
        return TimeEntriesApiFp(this.configuration).availableProjectsForTimeEntries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new time entry applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a time entries\' attributes and are accepted by the endpoint.
     * @summary Create Time entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeEntriesApi
     */
    public createTimeEntry(options?: AxiosRequestConfig) {
        return TimeEntriesApiFp(this.configuration).createTimeEntry(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes the specified time entry.
     * @summary Delete time entry
     * @param {TimeEntriesApiDeleteTimeEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeEntriesApi
     */
    public deleteTimeEntry(requestParameters: TimeEntriesApiDeleteTimeEntryRequest, options?: AxiosRequestConfig) {
        return TimeEntriesApiFp(this.configuration).deleteTimeEntry(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists time entries. The time entries returned depend on the filters provided and also on the permission of the requesting user.
     * @summary List time entries
     * @param {TimeEntriesApiListTimeEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeEntriesApi
     */
    public listTimeEntries(requestParameters: TimeEntriesApiListTimeEntriesRequest = {}, options?: AxiosRequestConfig) {
        return TimeEntriesApiFp(this.configuration).listTimeEntries(requestParameters.offset, requestParameters.pageSize, requestParameters.sortBy, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Time entry create form
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeEntriesApi
     */
    public timeEntryCreateForm(options?: AxiosRequestConfig) {
        return TimeEntriesApiFp(this.configuration).timeEntryCreateForm(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Time entry update form
     * @param {TimeEntriesApiTimeEntryUpdateFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeEntriesApi
     */
    public timeEntryUpdateForm(requestParameters: TimeEntriesApiTimeEntryUpdateFormRequest, options?: AxiosRequestConfig) {
        return TimeEntriesApiFp(this.configuration).timeEntryUpdateForm(requestParameters.id, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the given time entry by applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a time entries\' attributes and are accepted by the endpoint.
     * @summary Update Time entry
     * @param {TimeEntriesApiUpdateTimeEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeEntriesApi
     */
    public updateTimeEntry(requestParameters: TimeEntriesApiUpdateTimeEntryRequest, options?: AxiosRequestConfig) {
        return TimeEntriesApiFp(this.configuration).updateTimeEntry(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View time entry
     * @param {TimeEntriesApiViewTimeEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeEntriesApi
     */
    public viewTimeEntry(requestParameters: TimeEntriesApiViewTimeEntryRequest, options?: AxiosRequestConfig) {
        return TimeEntriesApiFp(this.configuration).viewTimeEntry(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View time entry schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeEntriesApi
     */
    public viewTimeEntrySchema(options?: AxiosRequestConfig) {
        return TimeEntriesApiFp(this.configuration).viewTimeEntrySchema(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TimeEntryActivitiesApi - axios parameter creator
 * @export
 */
export const TimeEntryActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View time entries activity
         * @param {number} id Time entries activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewTimeEntriesActivity: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewTimeEntriesActivity', 'id', id)
            const localVarPath = `/api/v3/time_entries/activity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeEntryActivitiesApi - functional programming interface
 * @export
 */
export const TimeEntryActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeEntryActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary View time entries activity
         * @param {number} id Time entries activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewTimeEntriesActivity(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewTimeEntriesActivity(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TimeEntryActivitiesApi - factory interface
 * @export
 */
export const TimeEntryActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeEntryActivitiesApiFp(configuration)
    return {
        /**
         * 
         * @summary View time entries activity
         * @param {number} id Time entries activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewTimeEntriesActivity(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.viewTimeEntriesActivity(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewTimeEntriesActivity operation in TimeEntryActivitiesApi.
 * @export
 * @interface TimeEntryActivitiesApiViewTimeEntriesActivityRequest
 */
export interface TimeEntryActivitiesApiViewTimeEntriesActivityRequest {
    /**
     * Time entries activity id
     * @type {number}
     * @memberof TimeEntryActivitiesApiViewTimeEntriesActivity
     */
    readonly id: number
}

/**
 * TimeEntryActivitiesApi - object-oriented interface
 * @export
 * @class TimeEntryActivitiesApi
 * @extends {BaseAPI}
 */
export class TimeEntryActivitiesApi extends BaseAPI {
    /**
     * 
     * @summary View time entries activity
     * @param {TimeEntryActivitiesApiViewTimeEntriesActivityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeEntryActivitiesApi
     */
    public viewTimeEntriesActivity(requestParameters: TimeEntryActivitiesApiViewTimeEntriesActivityRequest, options?: AxiosRequestConfig) {
        return TimeEntryActivitiesApiFp(this.configuration).viewTimeEntriesActivity(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TypesApi - axios parameter creator
 * @export
 */
export const TypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists the types that are *available* in a given project.
         * @summary List types available in a project
         * @param {number} id ID of the project whose types will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTypesAvailableInAProject: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTypesAvailableInAProject', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/types`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View Type
         * @param {number} id Type id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewType: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewType', 'id', id)
            const localVarPath = `/api/v3/types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TypesApi - functional programming interface
 * @export
 */
export const TypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TypesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint lists the types that are *available* in a given project.
         * @summary List types available in a project
         * @param {number} id ID of the project whose types will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTypesAvailableInAProject(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTypesAvailableInAProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View Type
         * @param {number} id Type id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewType(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypeModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TypesApi - factory interface
 * @export
 */
export const TypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TypesApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTypes(options?: any): AxiosPromise<object> {
            return localVarFp.listAllTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint lists the types that are *available* in a given project.
         * @summary List types available in a project
         * @param {number} id ID of the project whose types will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTypesAvailableInAProject(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.listTypesAvailableInAProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View Type
         * @param {number} id Type id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewType(id: number, options?: any): AxiosPromise<TypeModel> {
            return localVarFp.viewType(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listTypesAvailableInAProject operation in TypesApi.
 * @export
 * @interface TypesApiListTypesAvailableInAProjectRequest
 */
export interface TypesApiListTypesAvailableInAProjectRequest {
    /**
     * ID of the project whose types will be listed
     * @type {number}
     * @memberof TypesApiListTypesAvailableInAProject
     */
    readonly id: number
}

/**
 * Request parameters for viewType operation in TypesApi.
 * @export
 * @interface TypesApiViewTypeRequest
 */
export interface TypesApiViewTypeRequest {
    /**
     * Type id
     * @type {number}
     * @memberof TypesApiViewType
     */
    readonly id: number
}

/**
 * TypesApi - object-oriented interface
 * @export
 * @class TypesApi
 * @extends {BaseAPI}
 */
export class TypesApi extends BaseAPI {
    /**
     * 
     * @summary List all Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TypesApi
     */
    public listAllTypes(options?: AxiosRequestConfig) {
        return TypesApiFp(this.configuration).listAllTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint lists the types that are *available* in a given project.
     * @summary List types available in a project
     * @param {TypesApiListTypesAvailableInAProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TypesApi
     */
    public listTypesAvailableInAProject(requestParameters: TypesApiListTypesAvailableInAProjectRequest, options?: AxiosRequestConfig) {
        return TypesApiFp(this.configuration).listTypesAvailableInAProject(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View Type
     * @param {TypesApiViewTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TypesApi
     */
    public viewType(requestParameters: TypesApiViewTypeRequest, options?: AxiosRequestConfig) {
        return TypesApiFp(this.configuration).viewType(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserPreferencesApi - axios parameter creator
 * @export
 */
export const UserPreferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Show my preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMyPreferences: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/my_preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When calling this endpoint the client provides a single object, containing the properties that it wants to change, in the body.
         * @summary Update my preferences
         * @param {UpdateUserPreferencesRequest} [updateUserPreferencesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreferences: async (updateUserPreferencesRequest?: UpdateUserPreferencesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/my_preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPreferencesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPreferencesApi - functional programming interface
 * @export
 */
export const UserPreferencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPreferencesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Show my preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showMyPreferences(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showMyPreferences(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When calling this endpoint the client provides a single object, containing the properties that it wants to change, in the body.
         * @summary Update my preferences
         * @param {UpdateUserPreferencesRequest} [updateUserPreferencesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPreferences(updateUserPreferencesRequest?: UpdateUserPreferencesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPreferences(updateUserPreferencesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserPreferencesApi - factory interface
 * @export
 */
export const UserPreferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPreferencesApiFp(configuration)
    return {
        /**
         * 
         * @summary Show my preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMyPreferences(options?: any): AxiosPromise<object> {
            return localVarFp.showMyPreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * When calling this endpoint the client provides a single object, containing the properties that it wants to change, in the body.
         * @summary Update my preferences
         * @param {UpdateUserPreferencesRequest} [updateUserPreferencesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreferences(updateUserPreferencesRequest?: UpdateUserPreferencesRequest, options?: any): AxiosPromise<object> {
            return localVarFp.updateUserPreferences(updateUserPreferencesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updateUserPreferences operation in UserPreferencesApi.
 * @export
 * @interface UserPreferencesApiUpdateUserPreferencesRequest
 */
export interface UserPreferencesApiUpdateUserPreferencesRequest {
    /**
     * 
     * @type {UpdateUserPreferencesRequest}
     * @memberof UserPreferencesApiUpdateUserPreferences
     */
    readonly updateUserPreferencesRequest?: UpdateUserPreferencesRequest
}

/**
 * UserPreferencesApi - object-oriented interface
 * @export
 * @class UserPreferencesApi
 * @extends {BaseAPI}
 */
export class UserPreferencesApi extends BaseAPI {
    /**
     * 
     * @summary Show my preferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferencesApi
     */
    public showMyPreferences(options?: AxiosRequestConfig) {
        return UserPreferencesApiFp(this.configuration).showMyPreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When calling this endpoint the client provides a single object, containing the properties that it wants to change, in the body.
     * @summary Update my preferences
     * @param {UserPreferencesApiUpdateUserPreferencesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferencesApi
     */
    public updateUserPreferences(requestParameters: UserPreferencesApiUpdateUserPreferencesRequest = {}, options?: AxiosRequestConfig) {
        return UserPreferencesApiFp(this.configuration).updateUserPreferences(requestParameters.updateUserPreferencesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new user. Only administrators and users with manage_user global permission are allowed to do so. When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.  Valid values for `status`:  1) \"active\" - In this case a password has to be provided in addition to the other attributes.  2) \"invited\" - In this case nothing but the email address is required. The rest is optional. An invitation will be sent to the user.
         * @summary Create User
         * @param {UserCreateModel} [userCreateModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userCreateModel?: UserCreateModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes the specified user account.
         * @summary Delete user
         * @param {number} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/api/v3/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists users. Only administrators or users with manage_user global permission have permission to do this.
         * @summary List Users
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + status: Status the user has  + group: Name of the group in which to-be-listed users are members.  + name: Filter users in whose first or last names, or email addresses the given string occurs.  + login: User\&#39;s login
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (offset?: number, pageSize?: number, filters?: string, sortBy?: string, select?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lock user
         * @param {number} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockUser: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lockUser', 'id', id)
            const localVarPath = `/api/v3/users/{id}/lock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlock user
         * @param {number} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockUser: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlockUser', 'id', id)
            const localVarPath = `/api/v3/users/{id}/lock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the user\'s writable attributes. When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.
         * @summary Update user
         * @param {number} id User id
         * @param {UserCreateModel} [userCreateModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: number, userCreateModel?: UserCreateModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            const localVarPath = `/api/v3/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User update form
         * @param {number} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateForm: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userUpdateForm', 'id', id)
            const localVarPath = `/api/v3/users/{id}/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View user
         * @param {string} id User id. Use &#x60;me&#x60; to reference current user, if any.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewUser', 'id', id)
            const localVarPath = `/api/v3/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The schema response use two exemplary custom fields that extend the schema response. Depending on your instance and custom field configuration, the response will look somewhat different.
         * @summary View user schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewUserSchema: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/users/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new user. Only administrators and users with manage_user global permission are allowed to do so. When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.  Valid values for `status`:  1) \"active\" - In this case a password has to be provided in addition to the other attributes.  2) \"invited\" - In this case nothing but the email address is required. The rest is optional. An invitation will be sent to the user.
         * @summary Create User
         * @param {UserCreateModel} [userCreateModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userCreateModel?: UserCreateModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userCreateModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes the specified user account.
         * @summary Delete user
         * @param {number} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists users. Only administrators or users with manage_user global permission have permission to do this.
         * @summary List Users
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + status: Status the user has  + group: Name of the group in which to-be-listed users are members.  + name: Filter users in whose first or last names, or email addresses the given string occurs.  + login: User\&#39;s login
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(offset?: number, pageSize?: number, filters?: string, sortBy?: string, select?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCollectionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(offset, pageSize, filters, sortBy, select, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lock user
         * @param {number} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockUser(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlock user
         * @param {number} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockUser(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the user\'s writable attributes. When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.
         * @summary Update user
         * @param {number} id User id
         * @param {UserCreateModel} [userCreateModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: number, userCreateModel?: UserCreateModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, userCreateModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary User update form
         * @param {number} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUpdateForm(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUpdateForm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View user
         * @param {string} id User id. Use &#x60;me&#x60; to reference current user, if any.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The schema response use two exemplary custom fields that extend the schema response. Depending on your instance and custom field configuration, the response will look somewhat different.
         * @summary View user schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewUserSchema(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewUserSchema(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Creates a new user. Only administrators and users with manage_user global permission are allowed to do so. When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.  Valid values for `status`:  1) \"active\" - In this case a password has to be provided in addition to the other attributes.  2) \"invited\" - In this case nothing but the email address is required. The rest is optional. An invitation will be sent to the user.
         * @summary Create User
         * @param {UserCreateModel} [userCreateModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userCreateModel?: UserCreateModel, options?: any): AxiosPromise<UserModel> {
            return localVarFp.createUser(userCreateModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes the specified user account.
         * @summary Delete user
         * @param {number} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists users. Only administrators or users with manage_user global permission have permission to do this.
         * @summary List Users
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + status: Status the user has  + group: Name of the group in which to-be-listed users are members.  + name: Filter users in whose first or last names, or email addresses the given string occurs.  + login: User\&#39;s login
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(offset?: number, pageSize?: number, filters?: string, sortBy?: string, select?: string, options?: any): AxiosPromise<UserCollectionModel> {
            return localVarFp.listUsers(offset, pageSize, filters, sortBy, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lock user
         * @param {number} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockUser(id: number, options?: any): AxiosPromise<UserModel> {
            return localVarFp.lockUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlock user
         * @param {number} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockUser(id: number, options?: any): AxiosPromise<UserModel> {
            return localVarFp.unlockUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the user\'s writable attributes. When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.
         * @summary Update user
         * @param {number} id User id
         * @param {UserCreateModel} [userCreateModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, userCreateModel?: UserCreateModel, options?: any): AxiosPromise<UserModel> {
            return localVarFp.updateUser(id, userCreateModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User update form
         * @param {number} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateForm(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userUpdateForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View user
         * @param {string} id User id. Use &#x60;me&#x60; to reference current user, if any.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewUser(id: string, options?: any): AxiosPromise<UserModel> {
            return localVarFp.viewUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * The schema response use two exemplary custom fields that extend the schema response. Depending on your instance and custom field configuration, the response will look somewhat different.
         * @summary View user schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewUserSchema(options?: any): AxiosPromise<object> {
            return localVarFp.viewUserSchema(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createUser operation in UsersApi.
 * @export
 * @interface UsersApiCreateUserRequest
 */
export interface UsersApiCreateUserRequest {
    /**
     * 
     * @type {UserCreateModel}
     * @memberof UsersApiCreateUser
     */
    readonly userCreateModel?: UserCreateModel
}

/**
 * Request parameters for deleteUser operation in UsersApi.
 * @export
 * @interface UsersApiDeleteUserRequest
 */
export interface UsersApiDeleteUserRequest {
    /**
     * User id
     * @type {number}
     * @memberof UsersApiDeleteUser
     */
    readonly id: number
}

/**
 * Request parameters for listUsers operation in UsersApi.
 * @export
 * @interface UsersApiListUsersRequest
 */
export interface UsersApiListUsersRequest {
    /**
     * Page number inside the requested collection.
     * @type {number}
     * @memberof UsersApiListUsers
     */
    readonly offset?: number

    /**
     * Number of elements to display per page.
     * @type {number}
     * @memberof UsersApiListUsers
     */
    readonly pageSize?: number

    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + status: Status the user has  + group: Name of the group in which to-be-listed users are members.  + name: Filter users in whose first or last names, or email addresses the given string occurs.  + login: User\&#39;s login
     * @type {string}
     * @memberof UsersApiListUsers
     */
    readonly filters?: string

    /**
     * JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
     * @type {string}
     * @memberof UsersApiListUsers
     */
    readonly sortBy?: string

    /**
     * Comma separated list of properties to include.
     * @type {string}
     * @memberof UsersApiListUsers
     */
    readonly select?: string
}

/**
 * Request parameters for lockUser operation in UsersApi.
 * @export
 * @interface UsersApiLockUserRequest
 */
export interface UsersApiLockUserRequest {
    /**
     * User id
     * @type {number}
     * @memberof UsersApiLockUser
     */
    readonly id: number
}

/**
 * Request parameters for unlockUser operation in UsersApi.
 * @export
 * @interface UsersApiUnlockUserRequest
 */
export interface UsersApiUnlockUserRequest {
    /**
     * User id
     * @type {number}
     * @memberof UsersApiUnlockUser
     */
    readonly id: number
}

/**
 * Request parameters for updateUser operation in UsersApi.
 * @export
 * @interface UsersApiUpdateUserRequest
 */
export interface UsersApiUpdateUserRequest {
    /**
     * User id
     * @type {number}
     * @memberof UsersApiUpdateUser
     */
    readonly id: number

    /**
     * 
     * @type {UserCreateModel}
     * @memberof UsersApiUpdateUser
     */
    readonly userCreateModel?: UserCreateModel
}

/**
 * Request parameters for userUpdateForm operation in UsersApi.
 * @export
 * @interface UsersApiUserUpdateFormRequest
 */
export interface UsersApiUserUpdateFormRequest {
    /**
     * User id
     * @type {number}
     * @memberof UsersApiUserUpdateForm
     */
    readonly id: number
}

/**
 * Request parameters for viewUser operation in UsersApi.
 * @export
 * @interface UsersApiViewUserRequest
 */
export interface UsersApiViewUserRequest {
    /**
     * User id. Use &#x60;me&#x60; to reference current user, if any.
     * @type {string}
     * @memberof UsersApiViewUser
     */
    readonly id: string
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Creates a new user. Only administrators and users with manage_user global permission are allowed to do so. When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.  Valid values for `status`:  1) \"active\" - In this case a password has to be provided in addition to the other attributes.  2) \"invited\" - In this case nothing but the email address is required. The rest is optional. An invitation will be sent to the user.
     * @summary Create User
     * @param {UsersApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(requestParameters: UsersApiCreateUserRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(requestParameters.userCreateModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes the specified user account.
     * @summary Delete user
     * @param {UsersApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(requestParameters: UsersApiDeleteUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists users. Only administrators or users with manage_user global permission have permission to do this.
     * @summary List Users
     * @param {UsersApiListUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(requestParameters: UsersApiListUsersRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers(requestParameters.offset, requestParameters.pageSize, requestParameters.filters, requestParameters.sortBy, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lock user
     * @param {UsersApiLockUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public lockUser(requestParameters: UsersApiLockUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).lockUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlock user
     * @param {UsersApiUnlockUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public unlockUser(requestParameters: UsersApiUnlockUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).unlockUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the user\'s writable attributes. When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.
     * @summary Update user
     * @param {UsersApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(requestParameters: UsersApiUpdateUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(requestParameters.id, requestParameters.userCreateModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User update form
     * @param {UsersApiUserUpdateFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userUpdateForm(requestParameters: UsersApiUserUpdateFormRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userUpdateForm(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View user
     * @param {UsersApiViewUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewUser(requestParameters: UsersApiViewUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).viewUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The schema response use two exemplary custom fields that extend the schema response. Depending on your instance and custom field configuration, the response will look somewhat different.
     * @summary View user schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewUserSchema(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).viewUserSchema(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValuesPropertyApi - axios parameter creator
 * @export
 */
export const ValuesPropertyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an individual detail of a notification identified by the notification id and the id of the detail.
         * @summary Get a notification detail
         * @param {number} notificationId notification id
         * @param {number} id detail id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewNotificationDetail: async (notificationId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('viewNotificationDetail', 'notificationId', notificationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewNotificationDetail', 'id', id)
            const localVarPath = `/api/v3/notifications/{notification_id}/details/{id}`
                .replace(`{${"notification_id"}}`, encodeURIComponent(String(notificationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The schema of a `Values` resource.
         * @summary View Values schema
         * @param {string} id The identifier of the value. This is typically the value of the &#x60;property&#x60; property of the &#x60;Values&#x60; resource. It should be in lower camelcase format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewValuesSchema: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewValuesSchema', 'id', id)
            const localVarPath = `/api/v3/values/schema/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValuesPropertyApi - functional programming interface
 * @export
 */
export const ValuesPropertyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValuesPropertyApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns an individual detail of a notification identified by the notification id and the id of the detail.
         * @summary Get a notification detail
         * @param {number} notificationId notification id
         * @param {number} id detail id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewNotificationDetail(notificationId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValuesPropertyModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewNotificationDetail(notificationId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The schema of a `Values` resource.
         * @summary View Values schema
         * @param {string} id The identifier of the value. This is typically the value of the &#x60;property&#x60; property of the &#x60;Values&#x60; resource. It should be in lower camelcase format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewValuesSchema(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewValuesSchema(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValuesPropertyApi - factory interface
 * @export
 */
export const ValuesPropertyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValuesPropertyApiFp(configuration)
    return {
        /**
         * Returns an individual detail of a notification identified by the notification id and the id of the detail.
         * @summary Get a notification detail
         * @param {number} notificationId notification id
         * @param {number} id detail id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewNotificationDetail(notificationId: number, id: number, options?: any): AxiosPromise<ValuesPropertyModel> {
            return localVarFp.viewNotificationDetail(notificationId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * The schema of a `Values` resource.
         * @summary View Values schema
         * @param {string} id The identifier of the value. This is typically the value of the &#x60;property&#x60; property of the &#x60;Values&#x60; resource. It should be in lower camelcase format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewValuesSchema(id: string, options?: any): AxiosPromise<SchemaModel> {
            return localVarFp.viewValuesSchema(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewNotificationDetail operation in ValuesPropertyApi.
 * @export
 * @interface ValuesPropertyApiViewNotificationDetailRequest
 */
export interface ValuesPropertyApiViewNotificationDetailRequest {
    /**
     * notification id
     * @type {number}
     * @memberof ValuesPropertyApiViewNotificationDetail
     */
    readonly notificationId: number

    /**
     * detail id
     * @type {number}
     * @memberof ValuesPropertyApiViewNotificationDetail
     */
    readonly id: number
}

/**
 * Request parameters for viewValuesSchema operation in ValuesPropertyApi.
 * @export
 * @interface ValuesPropertyApiViewValuesSchemaRequest
 */
export interface ValuesPropertyApiViewValuesSchemaRequest {
    /**
     * The identifier of the value. This is typically the value of the &#x60;property&#x60; property of the &#x60;Values&#x60; resource. It should be in lower camelcase format.
     * @type {string}
     * @memberof ValuesPropertyApiViewValuesSchema
     */
    readonly id: string
}

/**
 * ValuesPropertyApi - object-oriented interface
 * @export
 * @class ValuesPropertyApi
 * @extends {BaseAPI}
 */
export class ValuesPropertyApi extends BaseAPI {
    /**
     * Returns an individual detail of a notification identified by the notification id and the id of the detail.
     * @summary Get a notification detail
     * @param {ValuesPropertyApiViewNotificationDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValuesPropertyApi
     */
    public viewNotificationDetail(requestParameters: ValuesPropertyApiViewNotificationDetailRequest, options?: AxiosRequestConfig) {
        return ValuesPropertyApiFp(this.configuration).viewNotificationDetail(requestParameters.notificationId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The schema of a `Values` resource.
     * @summary View Values schema
     * @param {ValuesPropertyApiViewValuesSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValuesPropertyApi
     */
    public viewValuesSchema(requestParameters: ValuesPropertyApiViewValuesSchemaRequest, options?: AxiosRequestConfig) {
        return ValuesPropertyApiFp(this.configuration).viewValuesSchema(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionsApi - axios parameter creator
 * @export
 */
export const VersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of projects in which a version can be created in. The list contains all projects in which the user issuing the request has the manage versions permissions.
         * @summary Available projects for versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableProjectsForVersions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/versions/available_projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new version applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a version\'s attributes and are accepted by the endpoint.  You can use the form and schema to be retrieve the valid attribute values and by that be guided towards successful creation.
         * @summary Create version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the version. Work packages associated to the version will no longer be assigned to it.
         * @summary Delete version
         * @param {number} id Version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVersion: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteVersion', 'id', id)
            const localVarPath = `/api/v3/versions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a collection of versions. The client can choose to filter the versions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain versions, for which the requesting client has sufficient permissions (*view_work_packages*).
         * @summary List versions
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + sharing: filters versions by how they are shared within the server (*none*, *descendants*, *hierarchy*, *tree*, *system*).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersions: async (filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists the versions that are *available* in a given project. Note that due to sharing this might be more than the versions *defined* by that project.
         * @summary List versions available in a project
         * @param {number} id ID of the project whose versions will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersionsAvailableInAProject: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listVersionsAvailableInAProject', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/versions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the given version by applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a version\'s attributes and are accepted by the endpoint.
         * @summary Update Version
         * @param {number} id Version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVersion: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVersion', 'id', id)
            const localVarPath = `/api/v3/versions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Version create form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionCreateForm: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/versions/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Version update form
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionUpdateForm: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('versionUpdateForm', 'id', id)
            const localVarPath = `/api/v3/versions/{id}/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View version
         * @param {number} id Version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewVersion: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewVersion', 'id', id)
            const localVarPath = `/api/v3/versions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View version schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewVersionSchema: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/versions/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsApi - functional programming interface
 * @export
 */
export const VersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a list of projects in which a version can be created in. The list contains all projects in which the user issuing the request has the manage versions permissions.
         * @summary Available projects for versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableProjectsForVersions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableProjectsForVersions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new version applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a version\'s attributes and are accepted by the endpoint.  You can use the form and schema to be retrieve the valid attribute values and by that be guided towards successful creation.
         * @summary Create version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the version. Work packages associated to the version will no longer be assigned to it.
         * @summary Delete version
         * @param {number} id Version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVersion(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVersion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a collection of versions. The client can choose to filter the versions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain versions, for which the requesting client has sufficient permissions (*view_work_packages*).
         * @summary List versions
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + sharing: filters versions by how they are shared within the server (*none*, *descendants*, *hierarchy*, *tree*, *system*).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVersions(filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVersions(filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint lists the versions that are *available* in a given project. Note that due to sharing this might be more than the versions *defined* by that project.
         * @summary List versions available in a project
         * @param {number} id ID of the project whose versions will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVersionsAvailableInAProject(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVersionsAvailableInAProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the given version by applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a version\'s attributes and are accepted by the endpoint.
         * @summary Update Version
         * @param {number} id Version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVersion(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVersion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Version create form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionCreateForm(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionCreateForm(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Version update form
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionUpdateForm(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionUpdateForm(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View version
         * @param {number} id Version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewVersion(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewVersion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View version schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewVersionSchema(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewVersionSchema(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionsApi - factory interface
 * @export
 */
export const VersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionsApiFp(configuration)
    return {
        /**
         * Gets a list of projects in which a version can be created in. The list contains all projects in which the user issuing the request has the manage versions permissions.
         * @summary Available projects for versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableProjectsForVersions(options?: any): AxiosPromise<object> {
            return localVarFp.availableProjectsForVersions(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new version applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a version\'s attributes and are accepted by the endpoint.  You can use the form and schema to be retrieve the valid attribute values and by that be guided towards successful creation.
         * @summary Create version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVersion(options?: any): AxiosPromise<VersionModel> {
            return localVarFp.createVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the version. Work packages associated to the version will no longer be assigned to it.
         * @summary Delete version
         * @param {number} id Version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVersion(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteVersion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a collection of versions. The client can choose to filter the versions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain versions, for which the requesting client has sufficient permissions (*view_work_packages*).
         * @summary List versions
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + sharing: filters versions by how they are shared within the server (*none*, *descendants*, *hierarchy*, *tree*, *system*).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersions(filters?: string, options?: any): AxiosPromise<object> {
            return localVarFp.listVersions(filters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint lists the versions that are *available* in a given project. Note that due to sharing this might be more than the versions *defined* by that project.
         * @summary List versions available in a project
         * @param {number} id ID of the project whose versions will be listed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersionsAvailableInAProject(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.listVersionsAvailableInAProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the given version by applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a version\'s attributes and are accepted by the endpoint.
         * @summary Update Version
         * @param {number} id Version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVersion(id: number, options?: any): AxiosPromise<VersionModel> {
            return localVarFp.updateVersion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Version create form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionCreateForm(options?: any): AxiosPromise<void> {
            return localVarFp.versionCreateForm(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Version update form
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionUpdateForm(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.versionUpdateForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View version
         * @param {number} id Version id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewVersion(id: number, options?: any): AxiosPromise<VersionModel> {
            return localVarFp.viewVersion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View version schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewVersionSchema(options?: any): AxiosPromise<object> {
            return localVarFp.viewVersionSchema(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteVersion operation in VersionsApi.
 * @export
 * @interface VersionsApiDeleteVersionRequest
 */
export interface VersionsApiDeleteVersionRequest {
    /**
     * Version id
     * @type {number}
     * @memberof VersionsApiDeleteVersion
     */
    readonly id: number
}

/**
 * Request parameters for listVersions operation in VersionsApi.
 * @export
 * @interface VersionsApiListVersionsRequest
 */
export interface VersionsApiListVersionsRequest {
    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + sharing: filters versions by how they are shared within the server (*none*, *descendants*, *hierarchy*, *tree*, *system*).
     * @type {string}
     * @memberof VersionsApiListVersions
     */
    readonly filters?: string
}

/**
 * Request parameters for listVersionsAvailableInAProject operation in VersionsApi.
 * @export
 * @interface VersionsApiListVersionsAvailableInAProjectRequest
 */
export interface VersionsApiListVersionsAvailableInAProjectRequest {
    /**
     * ID of the project whose versions will be listed
     * @type {number}
     * @memberof VersionsApiListVersionsAvailableInAProject
     */
    readonly id: number
}

/**
 * Request parameters for updateVersion operation in VersionsApi.
 * @export
 * @interface VersionsApiUpdateVersionRequest
 */
export interface VersionsApiUpdateVersionRequest {
    /**
     * Version id
     * @type {number}
     * @memberof VersionsApiUpdateVersion
     */
    readonly id: number
}

/**
 * Request parameters for versionUpdateForm operation in VersionsApi.
 * @export
 * @interface VersionsApiVersionUpdateFormRequest
 */
export interface VersionsApiVersionUpdateFormRequest {
    /**
     * Project id
     * @type {number}
     * @memberof VersionsApiVersionUpdateForm
     */
    readonly id: number
}

/**
 * Request parameters for viewVersion operation in VersionsApi.
 * @export
 * @interface VersionsApiViewVersionRequest
 */
export interface VersionsApiViewVersionRequest {
    /**
     * Version id
     * @type {number}
     * @memberof VersionsApiViewVersion
     */
    readonly id: number
}

/**
 * VersionsApi - object-oriented interface
 * @export
 * @class VersionsApi
 * @extends {BaseAPI}
 */
export class VersionsApi extends BaseAPI {
    /**
     * Gets a list of projects in which a version can be created in. The list contains all projects in which the user issuing the request has the manage versions permissions.
     * @summary Available projects for versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public availableProjectsForVersions(options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).availableProjectsForVersions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new version applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a version\'s attributes and are accepted by the endpoint.  You can use the form and schema to be retrieve the valid attribute values and by that be guided towards successful creation.
     * @summary Create version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public createVersion(options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).createVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the version. Work packages associated to the version will no longer be assigned to it.
     * @summary Delete version
     * @param {VersionsApiDeleteVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public deleteVersion(requestParameters: VersionsApiDeleteVersionRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).deleteVersion(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a collection of versions. The client can choose to filter the versions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain versions, for which the requesting client has sufficient permissions (*view_work_packages*).
     * @summary List versions
     * @param {VersionsApiListVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public listVersions(requestParameters: VersionsApiListVersionsRequest = {}, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).listVersions(requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint lists the versions that are *available* in a given project. Note that due to sharing this might be more than the versions *defined* by that project.
     * @summary List versions available in a project
     * @param {VersionsApiListVersionsAvailableInAProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public listVersionsAvailableInAProject(requestParameters: VersionsApiListVersionsAvailableInAProjectRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).listVersionsAvailableInAProject(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the given version by applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a version\'s attributes and are accepted by the endpoint.
     * @summary Update Version
     * @param {VersionsApiUpdateVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public updateVersion(requestParameters: VersionsApiUpdateVersionRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).updateVersion(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Version create form
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public versionCreateForm(options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).versionCreateForm(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Version update form
     * @param {VersionsApiVersionUpdateFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public versionUpdateForm(requestParameters: VersionsApiVersionUpdateFormRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).versionUpdateForm(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View version
     * @param {VersionsApiViewVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public viewVersion(requestParameters: VersionsApiViewVersionRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).viewVersion(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View version schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public viewVersionSchema(options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).viewVersionSchema(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ViewsApi - axios parameter creator
 * @export
 */
export const ViewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a View can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.  There are different subtypes of `Views` (e.g. `Views::WorkPackagesTable`) with each having its own endpoint for creating that subtype e.g.  * `/api/v3/views/work_packages_table` for `Views::WorkPackagesTable` * `/api/v3/views/team_planner` for `Views::TeamPlanner` * `/api/v3/views/work_packages_calendar` for `Views::WorkPackagesCalendar`  **Not yet implemented** To get the list of available subtypes and by that the endpoints for creating a subtype, use the ```   /api/v3/views/schemas ``` endpoint.
         * @summary Create view
         * @param {string} id The view identifier
         * @param {CreateViewsRequest} [createViewsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViews: async (id: string, createViewsRequest?: CreateViewsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createViews', 'id', id)
            const localVarPath = `/api/v3/views/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createViewsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a collection of Views. The collection can be filtered via query parameters similar to how work packages are filtered.
         * @summary List views
         * @param {string} [filters] JSON specifying filter conditions. Currently supported filters are:  + project: filters views by the project their associated query is assigned to. If the project filter is passed with the &#x60;!*&#x60; (not any) operator, global views are returned.  + id: filters views based on their id  + type: filters views based on their type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViews: async (filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/views`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View view
         * @param {number} id View id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewView: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewView', 'id', id)
            const localVarPath = `/api/v3/views/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewsApi - functional programming interface
 * @export
 */
export const ViewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewsApiAxiosParamCreator(configuration)
    return {
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a View can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.  There are different subtypes of `Views` (e.g. `Views::WorkPackagesTable`) with each having its own endpoint for creating that subtype e.g.  * `/api/v3/views/work_packages_table` for `Views::WorkPackagesTable` * `/api/v3/views/team_planner` for `Views::TeamPlanner` * `/api/v3/views/work_packages_calendar` for `Views::WorkPackagesCalendar`  **Not yet implemented** To get the list of available subtypes and by that the endpoints for creating a subtype, use the ```   /api/v3/views/schemas ``` endpoint.
         * @summary Create view
         * @param {string} id The view identifier
         * @param {CreateViewsRequest} [createViewsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createViews(id: string, createViewsRequest?: CreateViewsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createViews(id, createViewsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a collection of Views. The collection can be filtered via query parameters similar to how work packages are filtered.
         * @summary List views
         * @param {string} [filters] JSON specifying filter conditions. Currently supported filters are:  + project: filters views by the project their associated query is assigned to. If the project filter is passed with the &#x60;!*&#x60; (not any) operator, global views are returned.  + id: filters views based on their id  + type: filters views based on their type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listViews(filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listViews(filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View view
         * @param {number} id View id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewView(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewView(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewsApi - factory interface
 * @export
 */
export const ViewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewsApiFp(configuration)
    return {
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a View can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.  There are different subtypes of `Views` (e.g. `Views::WorkPackagesTable`) with each having its own endpoint for creating that subtype e.g.  * `/api/v3/views/work_packages_table` for `Views::WorkPackagesTable` * `/api/v3/views/team_planner` for `Views::TeamPlanner` * `/api/v3/views/work_packages_calendar` for `Views::WorkPackagesCalendar`  **Not yet implemented** To get the list of available subtypes and by that the endpoints for creating a subtype, use the ```   /api/v3/views/schemas ``` endpoint.
         * @summary Create view
         * @param {string} id The view identifier
         * @param {CreateViewsRequest} [createViewsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViews(id: string, createViewsRequest?: CreateViewsRequest, options?: any): AxiosPromise<object> {
            return localVarFp.createViews(id, createViewsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a collection of Views. The collection can be filtered via query parameters similar to how work packages are filtered.
         * @summary List views
         * @param {string} [filters] JSON specifying filter conditions. Currently supported filters are:  + project: filters views by the project their associated query is assigned to. If the project filter is passed with the &#x60;!*&#x60; (not any) operator, global views are returned.  + id: filters views based on their id  + type: filters views based on their type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViews(filters?: string, options?: any): AxiosPromise<void> {
            return localVarFp.listViews(filters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View view
         * @param {number} id View id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewView(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.viewView(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createViews operation in ViewsApi.
 * @export
 * @interface ViewsApiCreateViewsRequest
 */
export interface ViewsApiCreateViewsRequest {
    /**
     * The view identifier
     * @type {string}
     * @memberof ViewsApiCreateViews
     */
    readonly id: string

    /**
     * 
     * @type {CreateViewsRequest}
     * @memberof ViewsApiCreateViews
     */
    readonly createViewsRequest?: CreateViewsRequest
}

/**
 * Request parameters for listViews operation in ViewsApi.
 * @export
 * @interface ViewsApiListViewsRequest
 */
export interface ViewsApiListViewsRequest {
    /**
     * JSON specifying filter conditions. Currently supported filters are:  + project: filters views by the project their associated query is assigned to. If the project filter is passed with the &#x60;!*&#x60; (not any) operator, global views are returned.  + id: filters views based on their id  + type: filters views based on their type
     * @type {string}
     * @memberof ViewsApiListViews
     */
    readonly filters?: string
}

/**
 * Request parameters for viewView operation in ViewsApi.
 * @export
 * @interface ViewsApiViewViewRequest
 */
export interface ViewsApiViewViewRequest {
    /**
     * View id
     * @type {number}
     * @memberof ViewsApiViewView
     */
    readonly id: number
}

/**
 * ViewsApi - object-oriented interface
 * @export
 * @class ViewsApi
 * @extends {BaseAPI}
 */
export class ViewsApi extends BaseAPI {
    /**
     * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a View can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.  There are different subtypes of `Views` (e.g. `Views::WorkPackagesTable`) with each having its own endpoint for creating that subtype e.g.  * `/api/v3/views/work_packages_table` for `Views::WorkPackagesTable` * `/api/v3/views/team_planner` for `Views::TeamPlanner` * `/api/v3/views/work_packages_calendar` for `Views::WorkPackagesCalendar`  **Not yet implemented** To get the list of available subtypes and by that the endpoints for creating a subtype, use the ```   /api/v3/views/schemas ``` endpoint.
     * @summary Create view
     * @param {ViewsApiCreateViewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public createViews(requestParameters: ViewsApiCreateViewsRequest, options?: AxiosRequestConfig) {
        return ViewsApiFp(this.configuration).createViews(requestParameters.id, requestParameters.createViewsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a collection of Views. The collection can be filtered via query parameters similar to how work packages are filtered.
     * @summary List views
     * @param {ViewsApiListViewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public listViews(requestParameters: ViewsApiListViewsRequest = {}, options?: AxiosRequestConfig) {
        return ViewsApiFp(this.configuration).listViews(requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View view
     * @param {ViewsApiViewViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewView(requestParameters: ViewsApiViewViewRequest, options?: AxiosRequestConfig) {
        return ViewsApiFp(this.configuration).viewView(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WikiPagesApi - axios parameter creator
 * @export
 */
export const WikiPagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an individual wiki page as identified by the id parameter
         * @summary View Wiki Page
         * @param {number} id Wiki page identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewWikiPage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewWikiPage', 'id', id)
            const localVarPath = `/api/v3/wiki_pages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WikiPagesApi - functional programming interface
 * @export
 */
export const WikiPagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WikiPagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an individual wiki page as identified by the id parameter
         * @summary View Wiki Page
         * @param {number} id Wiki page identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewWikiPage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiPageModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewWikiPage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WikiPagesApi - factory interface
 * @export
 */
export const WikiPagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WikiPagesApiFp(configuration)
    return {
        /**
         * Retrieve an individual wiki page as identified by the id parameter
         * @summary View Wiki Page
         * @param {number} id Wiki page identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewWikiPage(id: number, options?: any): AxiosPromise<WikiPageModel> {
            return localVarFp.viewWikiPage(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for viewWikiPage operation in WikiPagesApi.
 * @export
 * @interface WikiPagesApiViewWikiPageRequest
 */
export interface WikiPagesApiViewWikiPageRequest {
    /**
     * Wiki page identifier
     * @type {number}
     * @memberof WikiPagesApiViewWikiPage
     */
    readonly id: number
}

/**
 * WikiPagesApi - object-oriented interface
 * @export
 * @class WikiPagesApi
 * @extends {BaseAPI}
 */
export class WikiPagesApi extends BaseAPI {
    /**
     * Retrieve an individual wiki page as identified by the id parameter
     * @summary View Wiki Page
     * @param {WikiPagesApiViewWikiPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WikiPagesApi
     */
    public viewWikiPage(requestParameters: WikiPagesApiViewWikiPageRequest, options?: AxiosRequestConfig) {
        return WikiPagesApiFp(this.configuration).viewWikiPage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkPackagesApi - axios parameter creator
 * @export
 */
export const WorkPackagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a watcher to the specified work package.  The request is expected to contain a single JSON object, that contains a link object under the `user` key.  The response will be user added as watcher. In case the user was already watching the work package an `HTTP 200` is returned, an `HTTP 201` if the user was added as a new watcher.
         * @summary Add watcher
         * @param {number} id Work package id
         * @param {AddWatcherRequest} [addWatcherRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWatcher: async (id: number, addWatcherRequest?: AddWatcherRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addWatcher', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/watchers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addWatcherRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of users that can be assigned to work packages in the given project.
         * @summary Available assignees
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableAssignees: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('availableAssignees', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/available_assignees`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of projects that are available as projects to which the work package can be moved.
         * @summary Available projects for work package
         * @param {number} id work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableProjectsForWorkPackage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('availableProjectsForWorkPackage', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/available_projects`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Available relation candidates
         * @param {number} id Project id
         * @param {number} [pageSize] Maximum number of candidates to list (default 10)
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same filters as the [work packages](https://www.openproject.org/docs/api/endpoints/work-packages/) endpoint.
         * @param {string} [query] Shortcut for filtering by ID or subject
         * @param {string} [type] Type of relation to find candidates for (default \&quot;relates\&quot;)
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same sort criteria as the [work packages](https://www.openproject.org/docs/api/endpoints/work-packages/) endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableRelationCandidates: async (id: number, pageSize?: number, filters?: string, query?: string, type?: string, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('availableRelationCandidates', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/available_relation_candidates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of users that can be assigned as the responsible of a work package in the given project.
         * @summary Available responsibles
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableResponsibles: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('availableResponsibles', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/available_responsibles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of users that are able to be watchers of the specified work package.
         * @summary Available watchers
         * @param {number} id work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableWatchers: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('availableWatchers', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/available_watchers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an activity for the selected work package and, on success, returns the updated activity.
         * @summary Comment work package
         * @param {number} id Work package id
         * @param {boolean} [notify] Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
         * @param {CommentWorkPackageRequest} [commentWorkPackageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentWorkPackage: async (id: number, notify?: boolean, commentWorkPackageRequest?: CommentWorkPackageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commentWorkPackage', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (notify !== undefined) {
                localVarQueryParameter['notify'] = notify;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentWorkPackageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a WorkPackage can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.
         * @summary Create work package in project
         * @param {number} id Project id
         * @param {boolean} [notify] Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectWorkPackage: async (id: number, notify?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createProjectWorkPackage', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/work_packages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (notify !== undefined) {
                localVarQueryParameter['notify'] = notify;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a Relation can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.
         * @summary Create Relation
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelation: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createRelation', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/relations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a WorkPackage can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.  A project link must be set when creating work packages through this route.  When setting start date, finish date, and duration together, their correctness will be checked and a 422 error will be returned if one value does not match with the two others. You can make the server compute a value: set only two values in the request and the third one will be computed and returned in the response. For instance, when sending `{ \"startDate\": \"2022-08-23\", duration: \"P2D\" }`, the response will include `{ \"dueDate\": \"2022-08-24\" }`.
         * @summary Create Work Package
         * @param {boolean} [notify] Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
         * @param {WorkPackageModel} [workPackageModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkPackage: async (notify?: boolean, workPackageModel?: WorkPackageModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/work_packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (notify !== undefined) {
                localVarQueryParameter['notify'] = notify;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workPackageModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates file links on a work package.  The request is interpreted as a bulk insert, where every element of the collection is validated separately. Each element contains the origin meta data and a link to the storage, the file link is about to point to. The storage link can be provided as a resource link with id or as the host url.  The file\'s id and name are considered mandatory information. The rest of the origin meta data SHOULD be provided by the client. The _mimeType_ SHOULD be a standard mime type. An empty mime type will be handled as unknown. To link a folder, the custom mime type `application/x-op-directory` MUST be used.  Up to 20 file links can be submitted at once.  If any element data is invalid, no file links will be created.  If a file link with matching origin id, work package, and storage already exists, then it will not create an additional file link or update the meta data. Instead the information from the existing file link will be returned.
         * @summary Creates file links.
         * @param {number} id Work package id
         * @param {FileLinkCollectionWriteModel} [fileLinkCollectionWriteModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkPackageFileLink: async (id: number, fileLinkCollectionWriteModel?: FileLinkCollectionWriteModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createWorkPackageFileLink', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/file_links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileLinkCollectionWriteModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the work package, as well as:  - all associated time entries - its hierarchy of child work packages
         * @summary Delete Work Package
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkPackage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWorkPackage', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. Note that it is only allowed to provide properties or links supporting the **write** operation.  Additionally to the fields the client wants to change, it is mandatory to provide the value of `lockVersion` which was received by the `GET` request this change originates from.  The value of `lockVersion` is used to implement [optimistic locking](https://en.wikipedia.org/wiki/Optimistic_concurrency_control).
         * @summary Edit Work Package
         * @param {number} id Work package id
         * @param {boolean} [notify] Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
         * @param {WorkPackageModel} [workPackageModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWorkPackage: async (id: number, notify?: boolean, workPackageModel?: WorkPackageModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editWorkPackage', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (notify !== undefined) {
                localVarQueryParameter['notify'] = notify;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workPackageModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the collection of work packages that are related to the given project.
         * @summary Get work packages of project
         * @param {number} id Project id
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {string} [groupBy] The column to group by.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it.
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectWorkPackageCollection: async (id: number, offset?: number, pageSize?: number, filters?: string, sortBy?: string, groupBy?: string, showSums?: boolean, select?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProjectWorkPackageCollection', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/work_packages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (showSums !== undefined) {
                localVarQueryParameter['showSums'] = showSums;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all relations this work package is involved in.
         * @summary List relations
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRelations: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listRelations', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/relations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List watchers
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchers: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listWatchers', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/watchers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List work package activities
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkPackageActivities: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listWorkPackageActivities', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all file links of a work package.  As a side effect, for every file link a request is sent to the storage\'s origin to fetch live data and patch the file link\'s data before returning, as well as retrieving permissions of the user on this origin file. 
         * @summary Gets all file links of a work package
         * @param {number} id Work package id
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. The following filters are supported:  - storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkPackageFileLinks: async (id: number, filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listWorkPackageFileLinks', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/file_links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List work package schemas.
         * @summary List Work Package Schemas
         * @param {string} filters JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: The schema\&#39;s id  Schema id has the form &#x60;project_id-work_package_type_id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkPackageSchemas: async (filters: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filters' is not null or undefined
            assertParamExists('listWorkPackageSchemas', 'filters', filters)
            const localVarPath = `/api/v3/work_packages/schemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a collection of work packages.
         * @summary List work packages
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;), otherwise a default filter is applied. A Currently supported filters are (there are additional filters added by modules):  - assigned_to - assignee_or_group - attachment_base - attachment_content - attachment_file_name - author - blocked - blocks - category - comment - created_at - custom_field - dates_interval - description - done_ratio - due_date - duplicated - duplicates - duration - estimated_hours - file_link_origin_id - follows - group - id - includes - linkable_to_storage_id - linkable_to_storage_url - manual_sort - milestone - only_subproject - parent - partof - precedes - principal_base - priority - project - relatable - relates - required - requires - responsible - role - search - start_date - status - storage_id - storage_url - subject - subject_or_id - subproject - type - typeahead - updated_at - version - watcher - work_package
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {string} [groupBy] The column to group by.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it.
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkPackages: async (offset?: number, pageSize?: number, filters?: string, sortBy?: string, groupBy?: string, showSums?: boolean, select?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/work_packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (showSums !== undefined) {
                localVarQueryParameter['showSums'] = showSums;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the specified user from the list of watchers for the given work package.  If the request succeeds, the specified user is not watching the work package anymore.  *Note: This might also be the case, if the specified user did not watch the work package prior to the request.*
         * @summary Remove watcher
         * @param {number} id Work package id
         * @param {number} userId User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWatcher: async (id: number, userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeWatcher', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeWatcher', 'userId', userId)
            const localVarPath = `/api/v3/work_packages/{id}/watchers/{user_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of revisions that are linked to this work package, e.g., because it is referenced in the commit message of the revision. Only linked revisions from repositories are shown if the user has the view changesets permission in the defining project.
         * @summary Revisions
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revisions: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('revisions', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/revisions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the origin file data of a all file links within a work package.  The cached data is updated (overwritten) with the new data. If any data point is not available in the new data, but in the old cache, it is not overwritten.  After a successful update the client SHOULD retrieve the links of file links again to obtain the new data.
         * @summary Updated the origin data of the file links of a work package.
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkPackageFileLinks: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWorkPackageFileLinks', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/update_file_links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified work package.
         * @summary View Work Package
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewWorkPackage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewWorkPackage', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View Work Package Schema
         * @param {string} identifier Identifier of the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewWorkPackageSchema: async (identifier: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('viewWorkPackageSchema', 'identifier', identifier)
            const localVarPath = `/api/v3/work_packages/schemas/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Work Package Create Form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workPackageCreateForm: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/work_packages/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Work Package Create Form For Project
         * @param {number} id ID of the project in which the work package will be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workPackageCreateFormForProject: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workPackageCreateFormForProject', 'id', id)
            const localVarPath = `/api/v3/projects/{id}/work_packages/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When calling this endpoint, the client provides a single object containing the properties and links to be edited, in the body.  Note that it is only allowed to provide properties or links supporting the write operation.  When setting start date, finish date, and duration together, their correctness will be checked and a 422 error will be returned if one value does not match with the two others. You can make the server compute a value: set only two values in the request and the third one will be computed and returned in the response. For instance, when sending `{ \"startDate\": \"2022-08-23\", duration: \"P2D\" }`, the response will include `{ \"dueDate\": \"2022-08-24\" }`.
         * @summary Work Package Edit Form
         * @param {number} id ID of the work package being modified
         * @param {WorkPackageModel} [workPackageModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workPackageEditForm: async (id: number, workPackageModel?: WorkPackageModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workPackageEditForm', 'id', id)
            const localVarPath = `/api/v3/work_packages/{id}/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workPackageModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkPackagesApi - functional programming interface
 * @export
 */
export const WorkPackagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkPackagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a watcher to the specified work package.  The request is expected to contain a single JSON object, that contains a link object under the `user` key.  The response will be user added as watcher. In case the user was already watching the work package an `HTTP 200` is returned, an `HTTP 201` if the user was added as a new watcher.
         * @summary Add watcher
         * @param {number} id Work package id
         * @param {AddWatcherRequest} [addWatcherRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWatcher(id: number, addWatcherRequest?: AddWatcherRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWatcher(id, addWatcherRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of users that can be assigned to work packages in the given project.
         * @summary Available assignees
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableAssignees(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableAssignees(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of projects that are available as projects to which the work package can be moved.
         * @summary Available projects for work package
         * @param {number} id work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableProjectsForWorkPackage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableProjectsForWorkPackage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Available relation candidates
         * @param {number} id Project id
         * @param {number} [pageSize] Maximum number of candidates to list (default 10)
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same filters as the [work packages](https://www.openproject.org/docs/api/endpoints/work-packages/) endpoint.
         * @param {string} [query] Shortcut for filtering by ID or subject
         * @param {string} [type] Type of relation to find candidates for (default \&quot;relates\&quot;)
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same sort criteria as the [work packages](https://www.openproject.org/docs/api/endpoints/work-packages/) endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableRelationCandidates(id: number, pageSize?: number, filters?: string, query?: string, type?: string, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableRelationCandidates(id, pageSize, filters, query, type, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of users that can be assigned as the responsible of a work package in the given project.
         * @summary Available responsibles
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableResponsibles(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableResponsibles(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of users that are able to be watchers of the specified work package.
         * @summary Available watchers
         * @param {number} id work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableWatchers(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableWatchers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates an activity for the selected work package and, on success, returns the updated activity.
         * @summary Comment work package
         * @param {number} id Work package id
         * @param {boolean} [notify] Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
         * @param {CommentWorkPackageRequest} [commentWorkPackageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentWorkPackage(id: number, notify?: boolean, commentWorkPackageRequest?: CommentWorkPackageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentWorkPackage(id, notify, commentWorkPackageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a WorkPackage can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.
         * @summary Create work package in project
         * @param {number} id Project id
         * @param {boolean} [notify] Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectWorkPackage(id: number, notify?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkPackageModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectWorkPackage(id, notify, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a Relation can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.
         * @summary Create Relation
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRelation(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRelation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a WorkPackage can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.  A project link must be set when creating work packages through this route.  When setting start date, finish date, and duration together, their correctness will be checked and a 422 error will be returned if one value does not match with the two others. You can make the server compute a value: set only two values in the request and the third one will be computed and returned in the response. For instance, when sending `{ \"startDate\": \"2022-08-23\", duration: \"P2D\" }`, the response will include `{ \"dueDate\": \"2022-08-24\" }`.
         * @summary Create Work Package
         * @param {boolean} [notify] Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
         * @param {WorkPackageModel} [workPackageModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkPackage(notify?: boolean, workPackageModel?: WorkPackageModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkPackageModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkPackage(notify, workPackageModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates file links on a work package.  The request is interpreted as a bulk insert, where every element of the collection is validated separately. Each element contains the origin meta data and a link to the storage, the file link is about to point to. The storage link can be provided as a resource link with id or as the host url.  The file\'s id and name are considered mandatory information. The rest of the origin meta data SHOULD be provided by the client. The _mimeType_ SHOULD be a standard mime type. An empty mime type will be handled as unknown. To link a folder, the custom mime type `application/x-op-directory` MUST be used.  Up to 20 file links can be submitted at once.  If any element data is invalid, no file links will be created.  If a file link with matching origin id, work package, and storage already exists, then it will not create an additional file link or update the meta data. Instead the information from the existing file link will be returned.
         * @summary Creates file links.
         * @param {number} id Work package id
         * @param {FileLinkCollectionWriteModel} [fileLinkCollectionWriteModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkPackageFileLink(id: number, fileLinkCollectionWriteModel?: FileLinkCollectionWriteModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileLinkCollectionReadModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkPackageFileLink(id, fileLinkCollectionWriteModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the work package, as well as:  - all associated time entries - its hierarchy of child work packages
         * @summary Delete Work Package
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkPackage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkPackage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. Note that it is only allowed to provide properties or links supporting the **write** operation.  Additionally to the fields the client wants to change, it is mandatory to provide the value of `lockVersion` which was received by the `GET` request this change originates from.  The value of `lockVersion` is used to implement [optimistic locking](https://en.wikipedia.org/wiki/Optimistic_concurrency_control).
         * @summary Edit Work Package
         * @param {number} id Work package id
         * @param {boolean} [notify] Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
         * @param {WorkPackageModel} [workPackageModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editWorkPackage(id: number, notify?: boolean, workPackageModel?: WorkPackageModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkPackageModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editWorkPackage(id, notify, workPackageModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the collection of work packages that are related to the given project.
         * @summary Get work packages of project
         * @param {number} id Project id
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {string} [groupBy] The column to group by.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it.
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectWorkPackageCollection(id: number, offset?: number, pageSize?: number, filters?: string, sortBy?: string, groupBy?: string, showSums?: boolean, select?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkPackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectWorkPackageCollection(id, offset, pageSize, filters, sortBy, groupBy, showSums, select, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all relations this work package is involved in.
         * @summary List relations
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRelations(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRelations(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List watchers
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWatchers(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchersModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWatchers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List work package activities
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkPackageActivities(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkPackageActivities(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all file links of a work package.  As a side effect, for every file link a request is sent to the storage\'s origin to fetch live data and patch the file link\'s data before returning, as well as retrieving permissions of the user on this origin file. 
         * @summary Gets all file links of a work package
         * @param {number} id Work package id
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. The following filters are supported:  - storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkPackageFileLinks(id: number, filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileLinkCollectionReadModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkPackageFileLinks(id, filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List work package schemas.
         * @summary List Work Package Schemas
         * @param {string} filters JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: The schema\&#39;s id  Schema id has the form &#x60;project_id-work_package_type_id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkPackageSchemas(filters: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkPackageSchemas(filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a collection of work packages.
         * @summary List work packages
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;), otherwise a default filter is applied. A Currently supported filters are (there are additional filters added by modules):  - assigned_to - assignee_or_group - attachment_base - attachment_content - attachment_file_name - author - blocked - blocks - category - comment - created_at - custom_field - dates_interval - description - done_ratio - due_date - duplicated - duplicates - duration - estimated_hours - file_link_origin_id - follows - group - id - includes - linkable_to_storage_id - linkable_to_storage_url - manual_sort - milestone - only_subproject - parent - partof - precedes - principal_base - priority - project - relatable - relates - required - requires - responsible - role - search - start_date - status - storage_id - storage_url - subject - subject_or_id - subproject - type - typeahead - updated_at - version - watcher - work_package
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {string} [groupBy] The column to group by.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it.
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkPackages(offset?: number, pageSize?: number, filters?: string, sortBy?: string, groupBy?: string, showSums?: boolean, select?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkPackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkPackages(offset, pageSize, filters, sortBy, groupBy, showSums, select, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the specified user from the list of watchers for the given work package.  If the request succeeds, the specified user is not watching the work package anymore.  *Note: This might also be the case, if the specified user did not watch the work package prior to the request.*
         * @summary Remove watcher
         * @param {number} id Work package id
         * @param {number} userId User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeWatcher(id: number, userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeWatcher(id, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of revisions that are linked to this work package, e.g., because it is referenced in the commit message of the revision. Only linked revisions from repositories are shown if the user has the view changesets permission in the defining project.
         * @summary Revisions
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revisions(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revisions(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the origin file data of a all file links within a work package.  The cached data is updated (overwritten) with the new data. If any data point is not available in the new data, but in the old cache, it is not overwritten.  After a successful update the client SHOULD retrieve the links of file links again to obtain the new data.
         * @summary Updated the origin data of the file links of a work package.
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkPackageFileLinks(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkPackageFileLinks(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the specified work package.
         * @summary View Work Package
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewWorkPackage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkPackageModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewWorkPackage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View Work Package Schema
         * @param {string} identifier Identifier of the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewWorkPackageSchema(identifier: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewWorkPackageSchema(identifier, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Work Package Create Form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workPackageCreateForm(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workPackageCreateForm(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Work Package Create Form For Project
         * @param {number} id ID of the project in which the work package will be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workPackageCreateFormForProject(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workPackageCreateFormForProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When calling this endpoint, the client provides a single object containing the properties and links to be edited, in the body.  Note that it is only allowed to provide properties or links supporting the write operation.  When setting start date, finish date, and duration together, their correctness will be checked and a 422 error will be returned if one value does not match with the two others. You can make the server compute a value: set only two values in the request and the third one will be computed and returned in the response. For instance, when sending `{ \"startDate\": \"2022-08-23\", duration: \"P2D\" }`, the response will include `{ \"dueDate\": \"2022-08-24\" }`.
         * @summary Work Package Edit Form
         * @param {number} id ID of the work package being modified
         * @param {WorkPackageModel} [workPackageModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workPackageEditForm(id: number, workPackageModel?: WorkPackageModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workPackageEditForm(id, workPackageModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkPackagesApi - factory interface
 * @export
 */
export const WorkPackagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkPackagesApiFp(configuration)
    return {
        /**
         * Adds a watcher to the specified work package.  The request is expected to contain a single JSON object, that contains a link object under the `user` key.  The response will be user added as watcher. In case the user was already watching the work package an `HTTP 200` is returned, an `HTTP 201` if the user was added as a new watcher.
         * @summary Add watcher
         * @param {number} id Work package id
         * @param {AddWatcherRequest} [addWatcherRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWatcher(id: number, addWatcherRequest?: AddWatcherRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addWatcher(id, addWatcherRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of users that can be assigned to work packages in the given project.
         * @summary Available assignees
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableAssignees(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.availableAssignees(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of projects that are available as projects to which the work package can be moved.
         * @summary Available projects for work package
         * @param {number} id work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableProjectsForWorkPackage(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.availableProjectsForWorkPackage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Available relation candidates
         * @param {number} id Project id
         * @param {number} [pageSize] Maximum number of candidates to list (default 10)
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same filters as the [work packages](https://www.openproject.org/docs/api/endpoints/work-packages/) endpoint.
         * @param {string} [query] Shortcut for filtering by ID or subject
         * @param {string} [type] Type of relation to find candidates for (default \&quot;relates\&quot;)
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same sort criteria as the [work packages](https://www.openproject.org/docs/api/endpoints/work-packages/) endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableRelationCandidates(id: number, pageSize?: number, filters?: string, query?: string, type?: string, sortBy?: string, options?: any): AxiosPromise<object> {
            return localVarFp.availableRelationCandidates(id, pageSize, filters, query, type, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of users that can be assigned as the responsible of a work package in the given project.
         * @summary Available responsibles
         * @param {number} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableResponsibles(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.availableResponsibles(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of users that are able to be watchers of the specified work package.
         * @summary Available watchers
         * @param {number} id work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableWatchers(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.availableWatchers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an activity for the selected work package and, on success, returns the updated activity.
         * @summary Comment work package
         * @param {number} id Work package id
         * @param {boolean} [notify] Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
         * @param {CommentWorkPackageRequest} [commentWorkPackageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentWorkPackage(id: number, notify?: boolean, commentWorkPackageRequest?: CommentWorkPackageRequest, options?: any): AxiosPromise<void> {
            return localVarFp.commentWorkPackage(id, notify, commentWorkPackageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a WorkPackage can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.
         * @summary Create work package in project
         * @param {number} id Project id
         * @param {boolean} [notify] Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectWorkPackage(id: number, notify?: boolean, options?: any): AxiosPromise<WorkPackageModel> {
            return localVarFp.createProjectWorkPackage(id, notify, options).then((request) => request(axios, basePath));
        },
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a Relation can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.
         * @summary Create Relation
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelation(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.createRelation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a WorkPackage can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.  A project link must be set when creating work packages through this route.  When setting start date, finish date, and duration together, their correctness will be checked and a 422 error will be returned if one value does not match with the two others. You can make the server compute a value: set only two values in the request and the third one will be computed and returned in the response. For instance, when sending `{ \"startDate\": \"2022-08-23\", duration: \"P2D\" }`, the response will include `{ \"dueDate\": \"2022-08-24\" }`.
         * @summary Create Work Package
         * @param {boolean} [notify] Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
         * @param {WorkPackageModel} [workPackageModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkPackage(notify?: boolean, workPackageModel?: WorkPackageModel, options?: any): AxiosPromise<WorkPackageModel> {
            return localVarFp.createWorkPackage(notify, workPackageModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates file links on a work package.  The request is interpreted as a bulk insert, where every element of the collection is validated separately. Each element contains the origin meta data and a link to the storage, the file link is about to point to. The storage link can be provided as a resource link with id or as the host url.  The file\'s id and name are considered mandatory information. The rest of the origin meta data SHOULD be provided by the client. The _mimeType_ SHOULD be a standard mime type. An empty mime type will be handled as unknown. To link a folder, the custom mime type `application/x-op-directory` MUST be used.  Up to 20 file links can be submitted at once.  If any element data is invalid, no file links will be created.  If a file link with matching origin id, work package, and storage already exists, then it will not create an additional file link or update the meta data. Instead the information from the existing file link will be returned.
         * @summary Creates file links.
         * @param {number} id Work package id
         * @param {FileLinkCollectionWriteModel} [fileLinkCollectionWriteModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkPackageFileLink(id: number, fileLinkCollectionWriteModel?: FileLinkCollectionWriteModel, options?: any): AxiosPromise<FileLinkCollectionReadModel> {
            return localVarFp.createWorkPackageFileLink(id, fileLinkCollectionWriteModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the work package, as well as:  - all associated time entries - its hierarchy of child work packages
         * @summary Delete Work Package
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkPackage(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkPackage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. Note that it is only allowed to provide properties or links supporting the **write** operation.  Additionally to the fields the client wants to change, it is mandatory to provide the value of `lockVersion` which was received by the `GET` request this change originates from.  The value of `lockVersion` is used to implement [optimistic locking](https://en.wikipedia.org/wiki/Optimistic_concurrency_control).
         * @summary Edit Work Package
         * @param {number} id Work package id
         * @param {boolean} [notify] Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
         * @param {WorkPackageModel} [workPackageModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWorkPackage(id: number, notify?: boolean, workPackageModel?: WorkPackageModel, options?: any): AxiosPromise<WorkPackageModel> {
            return localVarFp.editWorkPackage(id, notify, workPackageModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the collection of work packages that are related to the given project.
         * @summary Get work packages of project
         * @param {number} id Project id
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {string} [groupBy] The column to group by.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it.
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectWorkPackageCollection(id: number, offset?: number, pageSize?: number, filters?: string, sortBy?: string, groupBy?: string, showSums?: boolean, select?: string, options?: any): AxiosPromise<WorkPackagesModel> {
            return localVarFp.getProjectWorkPackageCollection(id, offset, pageSize, filters, sortBy, groupBy, showSums, select, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all relations this work package is involved in.
         * @summary List relations
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRelations(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.listRelations(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List watchers
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchers(id: number, options?: any): AxiosPromise<WatchersModel> {
            return localVarFp.listWatchers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List work package activities
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkPackageActivities(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.listWorkPackageActivities(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all file links of a work package.  As a side effect, for every file link a request is sent to the storage\'s origin to fetch live data and patch the file link\'s data before returning, as well as retrieving permissions of the user on this origin file. 
         * @summary Gets all file links of a work package
         * @param {number} id Work package id
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. The following filters are supported:  - storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkPackageFileLinks(id: number, filters?: string, options?: any): AxiosPromise<FileLinkCollectionReadModel> {
            return localVarFp.listWorkPackageFileLinks(id, filters, options).then((request) => request(axios, basePath));
        },
        /**
         * List work package schemas.
         * @summary List Work Package Schemas
         * @param {string} filters JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: The schema\&#39;s id  Schema id has the form &#x60;project_id-work_package_type_id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkPackageSchemas(filters: string, options?: any): AxiosPromise<object> {
            return localVarFp.listWorkPackageSchemas(filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a collection of work packages.
         * @summary List work packages
         * @param {number} [offset] Page number inside the requested collection.
         * @param {number} [pageSize] Number of elements to display per page.
         * @param {string} [filters] JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;), otherwise a default filter is applied. A Currently supported filters are (there are additional filters added by modules):  - assigned_to - assignee_or_group - attachment_base - attachment_content - attachment_file_name - author - blocked - blocks - category - comment - created_at - custom_field - dates_interval - description - done_ratio - due_date - duplicated - duplicates - duration - estimated_hours - file_link_origin_id - follows - group - id - includes - linkable_to_storage_id - linkable_to_storage_url - manual_sort - milestone - only_subproject - parent - partof - precedes - principal_base - priority - project - relatable - relates - required - requires - responsible - role - search - start_date - status - storage_id - storage_url - subject - subject_or_id - subproject - type - typeahead - updated_at - version - watcher - work_package
         * @param {string} [sortBy] JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
         * @param {string} [groupBy] The column to group by.
         * @param {boolean} [showSums] Indicates whether properties should be summed up if they support it.
         * @param {string} [select] Comma separated list of properties to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkPackages(offset?: number, pageSize?: number, filters?: string, sortBy?: string, groupBy?: string, showSums?: boolean, select?: string, options?: any): AxiosPromise<WorkPackagesModel> {
            return localVarFp.listWorkPackages(offset, pageSize, filters, sortBy, groupBy, showSums, select, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the specified user from the list of watchers for the given work package.  If the request succeeds, the specified user is not watching the work package anymore.  *Note: This might also be the case, if the specified user did not watch the work package prior to the request.*
         * @summary Remove watcher
         * @param {number} id Work package id
         * @param {number} userId User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWatcher(id: number, userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.removeWatcher(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of revisions that are linked to this work package, e.g., because it is referenced in the commit message of the revision. Only linked revisions from repositories are shown if the user has the view changesets permission in the defining project.
         * @summary Revisions
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revisions(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.revisions(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the origin file data of a all file links within a work package.  The cached data is updated (overwritten) with the new data. If any data point is not available in the new data, but in the old cache, it is not overwritten.  After a successful update the client SHOULD retrieve the links of file links again to obtain the new data.
         * @summary Updated the origin data of the file links of a work package.
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkPackageFileLinks(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.updateWorkPackageFileLinks(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified work package.
         * @summary View Work Package
         * @param {number} id Work package id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewWorkPackage(id: number, options?: any): AxiosPromise<WorkPackageModel> {
            return localVarFp.viewWorkPackage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View Work Package Schema
         * @param {string} identifier Identifier of the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewWorkPackageSchema(identifier: string, options?: any): AxiosPromise<void> {
            return localVarFp.viewWorkPackageSchema(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Work Package Create Form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workPackageCreateForm(options?: any): AxiosPromise<void> {
            return localVarFp.workPackageCreateForm(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Work Package Create Form For Project
         * @param {number} id ID of the project in which the work package will be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workPackageCreateFormForProject(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.workPackageCreateFormForProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * When calling this endpoint, the client provides a single object containing the properties and links to be edited, in the body.  Note that it is only allowed to provide properties or links supporting the write operation.  When setting start date, finish date, and duration together, their correctness will be checked and a 422 error will be returned if one value does not match with the two others. You can make the server compute a value: set only two values in the request and the third one will be computed and returned in the response. For instance, when sending `{ \"startDate\": \"2022-08-23\", duration: \"P2D\" }`, the response will include `{ \"dueDate\": \"2022-08-24\" }`.
         * @summary Work Package Edit Form
         * @param {number} id ID of the work package being modified
         * @param {WorkPackageModel} [workPackageModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workPackageEditForm(id: number, workPackageModel?: WorkPackageModel, options?: any): AxiosPromise<void> {
            return localVarFp.workPackageEditForm(id, workPackageModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addWatcher operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiAddWatcherRequest
 */
export interface WorkPackagesApiAddWatcherRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiAddWatcher
     */
    readonly id: number

    /**
     * 
     * @type {AddWatcherRequest}
     * @memberof WorkPackagesApiAddWatcher
     */
    readonly addWatcherRequest?: AddWatcherRequest
}

/**
 * Request parameters for availableAssignees operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiAvailableAssigneesRequest
 */
export interface WorkPackagesApiAvailableAssigneesRequest {
    /**
     * Project id
     * @type {number}
     * @memberof WorkPackagesApiAvailableAssignees
     */
    readonly id: number
}

/**
 * Request parameters for availableProjectsForWorkPackage operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiAvailableProjectsForWorkPackageRequest
 */
export interface WorkPackagesApiAvailableProjectsForWorkPackageRequest {
    /**
     * work package id
     * @type {number}
     * @memberof WorkPackagesApiAvailableProjectsForWorkPackage
     */
    readonly id: number
}

/**
 * Request parameters for availableRelationCandidates operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiAvailableRelationCandidatesRequest
 */
export interface WorkPackagesApiAvailableRelationCandidatesRequest {
    /**
     * Project id
     * @type {number}
     * @memberof WorkPackagesApiAvailableRelationCandidates
     */
    readonly id: number

    /**
     * Maximum number of candidates to list (default 10)
     * @type {number}
     * @memberof WorkPackagesApiAvailableRelationCandidates
     */
    readonly pageSize?: number

    /**
     * JSON specifying filter conditions. Accepts the same filters as the [work packages](https://www.openproject.org/docs/api/endpoints/work-packages/) endpoint.
     * @type {string}
     * @memberof WorkPackagesApiAvailableRelationCandidates
     */
    readonly filters?: string

    /**
     * Shortcut for filtering by ID or subject
     * @type {string}
     * @memberof WorkPackagesApiAvailableRelationCandidates
     */
    readonly query?: string

    /**
     * Type of relation to find candidates for (default \&quot;relates\&quot;)
     * @type {string}
     * @memberof WorkPackagesApiAvailableRelationCandidates
     */
    readonly type?: string

    /**
     * JSON specifying sort criteria. Accepts the same sort criteria as the [work packages](https://www.openproject.org/docs/api/endpoints/work-packages/) endpoint.
     * @type {string}
     * @memberof WorkPackagesApiAvailableRelationCandidates
     */
    readonly sortBy?: string
}

/**
 * Request parameters for availableResponsibles operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiAvailableResponsiblesRequest
 */
export interface WorkPackagesApiAvailableResponsiblesRequest {
    /**
     * Project id
     * @type {number}
     * @memberof WorkPackagesApiAvailableResponsibles
     */
    readonly id: number
}

/**
 * Request parameters for availableWatchers operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiAvailableWatchersRequest
 */
export interface WorkPackagesApiAvailableWatchersRequest {
    /**
     * work package id
     * @type {number}
     * @memberof WorkPackagesApiAvailableWatchers
     */
    readonly id: number
}

/**
 * Request parameters for commentWorkPackage operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiCommentWorkPackageRequest
 */
export interface WorkPackagesApiCommentWorkPackageRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiCommentWorkPackage
     */
    readonly id: number

    /**
     * Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
     * @type {boolean}
     * @memberof WorkPackagesApiCommentWorkPackage
     */
    readonly notify?: boolean

    /**
     * 
     * @type {CommentWorkPackageRequest}
     * @memberof WorkPackagesApiCommentWorkPackage
     */
    readonly commentWorkPackageRequest?: CommentWorkPackageRequest
}

/**
 * Request parameters for createProjectWorkPackage operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiCreateProjectWorkPackageRequest
 */
export interface WorkPackagesApiCreateProjectWorkPackageRequest {
    /**
     * Project id
     * @type {number}
     * @memberof WorkPackagesApiCreateProjectWorkPackage
     */
    readonly id: number

    /**
     * Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
     * @type {boolean}
     * @memberof WorkPackagesApiCreateProjectWorkPackage
     */
    readonly notify?: boolean
}

/**
 * Request parameters for createRelation operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiCreateRelationRequest
 */
export interface WorkPackagesApiCreateRelationRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiCreateRelation
     */
    readonly id: number
}

/**
 * Request parameters for createWorkPackage operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiCreateWorkPackageRequest
 */
export interface WorkPackagesApiCreateWorkPackageRequest {
    /**
     * Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
     * @type {boolean}
     * @memberof WorkPackagesApiCreateWorkPackage
     */
    readonly notify?: boolean

    /**
     * 
     * @type {WorkPackageModel}
     * @memberof WorkPackagesApiCreateWorkPackage
     */
    readonly workPackageModel?: WorkPackageModel
}

/**
 * Request parameters for createWorkPackageFileLink operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiCreateWorkPackageFileLinkRequest
 */
export interface WorkPackagesApiCreateWorkPackageFileLinkRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiCreateWorkPackageFileLink
     */
    readonly id: number

    /**
     * 
     * @type {FileLinkCollectionWriteModel}
     * @memberof WorkPackagesApiCreateWorkPackageFileLink
     */
    readonly fileLinkCollectionWriteModel?: FileLinkCollectionWriteModel
}

/**
 * Request parameters for deleteWorkPackage operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiDeleteWorkPackageRequest
 */
export interface WorkPackagesApiDeleteWorkPackageRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiDeleteWorkPackage
     */
    readonly id: number
}

/**
 * Request parameters for editWorkPackage operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiEditWorkPackageRequest
 */
export interface WorkPackagesApiEditWorkPackageRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiEditWorkPackage
     */
    readonly id: number

    /**
     * Indicates whether change notifications (e.g. via E-Mail) should be sent. Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
     * @type {boolean}
     * @memberof WorkPackagesApiEditWorkPackage
     */
    readonly notify?: boolean

    /**
     * 
     * @type {WorkPackageModel}
     * @memberof WorkPackagesApiEditWorkPackage
     */
    readonly workPackageModel?: WorkPackageModel
}

/**
 * Request parameters for getProjectWorkPackageCollection operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiGetProjectWorkPackageCollectionRequest
 */
export interface WorkPackagesApiGetProjectWorkPackageCollectionRequest {
    /**
     * Project id
     * @type {number}
     * @memberof WorkPackagesApiGetProjectWorkPackageCollection
     */
    readonly id: number

    /**
     * Page number inside the requested collection.
     * @type {number}
     * @memberof WorkPackagesApiGetProjectWorkPackageCollection
     */
    readonly offset?: number

    /**
     * Number of elements to display per page.
     * @type {number}
     * @memberof WorkPackagesApiGetProjectWorkPackageCollection
     */
    readonly pageSize?: number

    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;).
     * @type {string}
     * @memberof WorkPackagesApiGetProjectWorkPackageCollection
     */
    readonly filters?: string

    /**
     * JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
     * @type {string}
     * @memberof WorkPackagesApiGetProjectWorkPackageCollection
     */
    readonly sortBy?: string

    /**
     * The column to group by.
     * @type {string}
     * @memberof WorkPackagesApiGetProjectWorkPackageCollection
     */
    readonly groupBy?: string

    /**
     * Indicates whether properties should be summed up if they support it.
     * @type {boolean}
     * @memberof WorkPackagesApiGetProjectWorkPackageCollection
     */
    readonly showSums?: boolean

    /**
     * Comma separated list of properties to include.
     * @type {string}
     * @memberof WorkPackagesApiGetProjectWorkPackageCollection
     */
    readonly select?: string
}

/**
 * Request parameters for listRelations operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiListRelationsRequest
 */
export interface WorkPackagesApiListRelationsRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiListRelations
     */
    readonly id: number
}

/**
 * Request parameters for listWatchers operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiListWatchersRequest
 */
export interface WorkPackagesApiListWatchersRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiListWatchers
     */
    readonly id: number
}

/**
 * Request parameters for listWorkPackageActivities operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiListWorkPackageActivitiesRequest
 */
export interface WorkPackagesApiListWorkPackageActivitiesRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiListWorkPackageActivities
     */
    readonly id: number
}

/**
 * Request parameters for listWorkPackageFileLinks operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiListWorkPackageFileLinksRequest
 */
export interface WorkPackagesApiListWorkPackageFileLinksRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiListWorkPackageFileLinks
     */
    readonly id: number

    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. The following filters are supported:  - storage
     * @type {string}
     * @memberof WorkPackagesApiListWorkPackageFileLinks
     */
    readonly filters?: string
}

/**
 * Request parameters for listWorkPackageSchemas operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiListWorkPackageSchemasRequest
 */
export interface WorkPackagesApiListWorkPackageSchemasRequest {
    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + id: The schema\&#39;s id  Schema id has the form &#x60;project_id-work_package_type_id&#x60;.
     * @type {string}
     * @memberof WorkPackagesApiListWorkPackageSchemas
     */
    readonly filters: string
}

/**
 * Request parameters for listWorkPackages operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiListWorkPackagesRequest
 */
export interface WorkPackagesApiListWorkPackagesRequest {
    /**
     * Page number inside the requested collection.
     * @type {number}
     * @memberof WorkPackagesApiListWorkPackages
     */
    readonly offset?: number

    /**
     * Number of elements to display per page.
     * @type {number}
     * @memberof WorkPackagesApiListWorkPackages
     */
    readonly pageSize?: number

    /**
     * JSON specifying filter conditions. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. If no filter is to be applied, the client should send an empty array (&#x60;[]&#x60;), otherwise a default filter is applied. A Currently supported filters are (there are additional filters added by modules):  - assigned_to - assignee_or_group - attachment_base - attachment_content - attachment_file_name - author - blocked - blocks - category - comment - created_at - custom_field - dates_interval - description - done_ratio - due_date - duplicated - duplicates - duration - estimated_hours - file_link_origin_id - follows - group - id - includes - linkable_to_storage_id - linkable_to_storage_url - manual_sort - milestone - only_subproject - parent - partof - precedes - principal_base - priority - project - relatable - relates - required - requires - responsible - role - search - start_date - status - storage_id - storage_url - subject - subject_or_id - subproject - type - typeahead - updated_at - version - watcher - work_package
     * @type {string}
     * @memberof WorkPackagesApiListWorkPackages
     */
    readonly filters?: string

    /**
     * JSON specifying sort criteria. Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
     * @type {string}
     * @memberof WorkPackagesApiListWorkPackages
     */
    readonly sortBy?: string

    /**
     * The column to group by.
     * @type {string}
     * @memberof WorkPackagesApiListWorkPackages
     */
    readonly groupBy?: string

    /**
     * Indicates whether properties should be summed up if they support it.
     * @type {boolean}
     * @memberof WorkPackagesApiListWorkPackages
     */
    readonly showSums?: boolean

    /**
     * Comma separated list of properties to include.
     * @type {string}
     * @memberof WorkPackagesApiListWorkPackages
     */
    readonly select?: string
}

/**
 * Request parameters for removeWatcher operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiRemoveWatcherRequest
 */
export interface WorkPackagesApiRemoveWatcherRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiRemoveWatcher
     */
    readonly id: number

    /**
     * User id
     * @type {number}
     * @memberof WorkPackagesApiRemoveWatcher
     */
    readonly userId: number
}

/**
 * Request parameters for revisions operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiRevisionsRequest
 */
export interface WorkPackagesApiRevisionsRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiRevisions
     */
    readonly id: number
}

/**
 * Request parameters for updateWorkPackageFileLinks operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiUpdateWorkPackageFileLinksRequest
 */
export interface WorkPackagesApiUpdateWorkPackageFileLinksRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiUpdateWorkPackageFileLinks
     */
    readonly id: number
}

/**
 * Request parameters for viewWorkPackage operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiViewWorkPackageRequest
 */
export interface WorkPackagesApiViewWorkPackageRequest {
    /**
     * Work package id
     * @type {number}
     * @memberof WorkPackagesApiViewWorkPackage
     */
    readonly id: number
}

/**
 * Request parameters for viewWorkPackageSchema operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiViewWorkPackageSchemaRequest
 */
export interface WorkPackagesApiViewWorkPackageSchemaRequest {
    /**
     * Identifier of the schema
     * @type {string}
     * @memberof WorkPackagesApiViewWorkPackageSchema
     */
    readonly identifier: string
}

/**
 * Request parameters for workPackageCreateFormForProject operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiWorkPackageCreateFormForProjectRequest
 */
export interface WorkPackagesApiWorkPackageCreateFormForProjectRequest {
    /**
     * ID of the project in which the work package will be created
     * @type {number}
     * @memberof WorkPackagesApiWorkPackageCreateFormForProject
     */
    readonly id: number
}

/**
 * Request parameters for workPackageEditForm operation in WorkPackagesApi.
 * @export
 * @interface WorkPackagesApiWorkPackageEditFormRequest
 */
export interface WorkPackagesApiWorkPackageEditFormRequest {
    /**
     * ID of the work package being modified
     * @type {number}
     * @memberof WorkPackagesApiWorkPackageEditForm
     */
    readonly id: number

    /**
     * 
     * @type {WorkPackageModel}
     * @memberof WorkPackagesApiWorkPackageEditForm
     */
    readonly workPackageModel?: WorkPackageModel
}

/**
 * WorkPackagesApi - object-oriented interface
 * @export
 * @class WorkPackagesApi
 * @extends {BaseAPI}
 */
export class WorkPackagesApi extends BaseAPI {
    /**
     * Adds a watcher to the specified work package.  The request is expected to contain a single JSON object, that contains a link object under the `user` key.  The response will be user added as watcher. In case the user was already watching the work package an `HTTP 200` is returned, an `HTTP 201` if the user was added as a new watcher.
     * @summary Add watcher
     * @param {WorkPackagesApiAddWatcherRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public addWatcher(requestParameters: WorkPackagesApiAddWatcherRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).addWatcher(requestParameters.id, requestParameters.addWatcherRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of users that can be assigned to work packages in the given project.
     * @summary Available assignees
     * @param {WorkPackagesApiAvailableAssigneesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public availableAssignees(requestParameters: WorkPackagesApiAvailableAssigneesRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).availableAssignees(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of projects that are available as projects to which the work package can be moved.
     * @summary Available projects for work package
     * @param {WorkPackagesApiAvailableProjectsForWorkPackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public availableProjectsForWorkPackage(requestParameters: WorkPackagesApiAvailableProjectsForWorkPackageRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).availableProjectsForWorkPackage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Available relation candidates
     * @param {WorkPackagesApiAvailableRelationCandidatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public availableRelationCandidates(requestParameters: WorkPackagesApiAvailableRelationCandidatesRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).availableRelationCandidates(requestParameters.id, requestParameters.pageSize, requestParameters.filters, requestParameters.query, requestParameters.type, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of users that can be assigned as the responsible of a work package in the given project.
     * @summary Available responsibles
     * @param {WorkPackagesApiAvailableResponsiblesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public availableResponsibles(requestParameters: WorkPackagesApiAvailableResponsiblesRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).availableResponsibles(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of users that are able to be watchers of the specified work package.
     * @summary Available watchers
     * @param {WorkPackagesApiAvailableWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public availableWatchers(requestParameters: WorkPackagesApiAvailableWatchersRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).availableWatchers(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an activity for the selected work package and, on success, returns the updated activity.
     * @summary Comment work package
     * @param {WorkPackagesApiCommentWorkPackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public commentWorkPackage(requestParameters: WorkPackagesApiCommentWorkPackageRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).commentWorkPackage(requestParameters.id, requestParameters.notify, requestParameters.commentWorkPackageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a WorkPackage can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.
     * @summary Create work package in project
     * @param {WorkPackagesApiCreateProjectWorkPackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public createProjectWorkPackage(requestParameters: WorkPackagesApiCreateProjectWorkPackageRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).createProjectWorkPackage(requestParameters.id, requestParameters.notify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a Relation can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.
     * @summary Create Relation
     * @param {WorkPackagesApiCreateRelationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public createRelation(requestParameters: WorkPackagesApiCreateRelationRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).createRelation(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a WorkPackage can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.  A project link must be set when creating work packages through this route.  When setting start date, finish date, and duration together, their correctness will be checked and a 422 error will be returned if one value does not match with the two others. You can make the server compute a value: set only two values in the request and the third one will be computed and returned in the response. For instance, when sending `{ \"startDate\": \"2022-08-23\", duration: \"P2D\" }`, the response will include `{ \"dueDate\": \"2022-08-24\" }`.
     * @summary Create Work Package
     * @param {WorkPackagesApiCreateWorkPackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public createWorkPackage(requestParameters: WorkPackagesApiCreateWorkPackageRequest = {}, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).createWorkPackage(requestParameters.notify, requestParameters.workPackageModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates file links on a work package.  The request is interpreted as a bulk insert, where every element of the collection is validated separately. Each element contains the origin meta data and a link to the storage, the file link is about to point to. The storage link can be provided as a resource link with id or as the host url.  The file\'s id and name are considered mandatory information. The rest of the origin meta data SHOULD be provided by the client. The _mimeType_ SHOULD be a standard mime type. An empty mime type will be handled as unknown. To link a folder, the custom mime type `application/x-op-directory` MUST be used.  Up to 20 file links can be submitted at once.  If any element data is invalid, no file links will be created.  If a file link with matching origin id, work package, and storage already exists, then it will not create an additional file link or update the meta data. Instead the information from the existing file link will be returned.
     * @summary Creates file links.
     * @param {WorkPackagesApiCreateWorkPackageFileLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public createWorkPackageFileLink(requestParameters: WorkPackagesApiCreateWorkPackageFileLinkRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).createWorkPackageFileLink(requestParameters.id, requestParameters.fileLinkCollectionWriteModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the work package, as well as:  - all associated time entries - its hierarchy of child work packages
     * @summary Delete Work Package
     * @param {WorkPackagesApiDeleteWorkPackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public deleteWorkPackage(requestParameters: WorkPackagesApiDeleteWorkPackageRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).deleteWorkPackage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. Note that it is only allowed to provide properties or links supporting the **write** operation.  Additionally to the fields the client wants to change, it is mandatory to provide the value of `lockVersion` which was received by the `GET` request this change originates from.  The value of `lockVersion` is used to implement [optimistic locking](https://en.wikipedia.org/wiki/Optimistic_concurrency_control).
     * @summary Edit Work Package
     * @param {WorkPackagesApiEditWorkPackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public editWorkPackage(requestParameters: WorkPackagesApiEditWorkPackageRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).editWorkPackage(requestParameters.id, requestParameters.notify, requestParameters.workPackageModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the collection of work packages that are related to the given project.
     * @summary Get work packages of project
     * @param {WorkPackagesApiGetProjectWorkPackageCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public getProjectWorkPackageCollection(requestParameters: WorkPackagesApiGetProjectWorkPackageCollectionRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).getProjectWorkPackageCollection(requestParameters.id, requestParameters.offset, requestParameters.pageSize, requestParameters.filters, requestParameters.sortBy, requestParameters.groupBy, requestParameters.showSums, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all relations this work package is involved in.
     * @summary List relations
     * @param {WorkPackagesApiListRelationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public listRelations(requestParameters: WorkPackagesApiListRelationsRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).listRelations(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List watchers
     * @param {WorkPackagesApiListWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public listWatchers(requestParameters: WorkPackagesApiListWatchersRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).listWatchers(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List work package activities
     * @param {WorkPackagesApiListWorkPackageActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public listWorkPackageActivities(requestParameters: WorkPackagesApiListWorkPackageActivitiesRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).listWorkPackageActivities(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all file links of a work package.  As a side effect, for every file link a request is sent to the storage\'s origin to fetch live data and patch the file link\'s data before returning, as well as retrieving permissions of the user on this origin file. 
     * @summary Gets all file links of a work package
     * @param {WorkPackagesApiListWorkPackageFileLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public listWorkPackageFileLinks(requestParameters: WorkPackagesApiListWorkPackageFileLinksRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).listWorkPackageFileLinks(requestParameters.id, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List work package schemas.
     * @summary List Work Package Schemas
     * @param {WorkPackagesApiListWorkPackageSchemasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public listWorkPackageSchemas(requestParameters: WorkPackagesApiListWorkPackageSchemasRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).listWorkPackageSchemas(requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a collection of work packages.
     * @summary List work packages
     * @param {WorkPackagesApiListWorkPackagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public listWorkPackages(requestParameters: WorkPackagesApiListWorkPackagesRequest = {}, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).listWorkPackages(requestParameters.offset, requestParameters.pageSize, requestParameters.filters, requestParameters.sortBy, requestParameters.groupBy, requestParameters.showSums, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the specified user from the list of watchers for the given work package.  If the request succeeds, the specified user is not watching the work package anymore.  *Note: This might also be the case, if the specified user did not watch the work package prior to the request.*
     * @summary Remove watcher
     * @param {WorkPackagesApiRemoveWatcherRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public removeWatcher(requestParameters: WorkPackagesApiRemoveWatcherRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).removeWatcher(requestParameters.id, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of revisions that are linked to this work package, e.g., because it is referenced in the commit message of the revision. Only linked revisions from repositories are shown if the user has the view changesets permission in the defining project.
     * @summary Revisions
     * @param {WorkPackagesApiRevisionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public revisions(requestParameters: WorkPackagesApiRevisionsRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).revisions(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the origin file data of a all file links within a work package.  The cached data is updated (overwritten) with the new data. If any data point is not available in the new data, but in the old cache, it is not overwritten.  After a successful update the client SHOULD retrieve the links of file links again to obtain the new data.
     * @summary Updated the origin data of the file links of a work package.
     * @param {WorkPackagesApiUpdateWorkPackageFileLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public updateWorkPackageFileLinks(requestParameters: WorkPackagesApiUpdateWorkPackageFileLinksRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).updateWorkPackageFileLinks(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified work package.
     * @summary View Work Package
     * @param {WorkPackagesApiViewWorkPackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public viewWorkPackage(requestParameters: WorkPackagesApiViewWorkPackageRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).viewWorkPackage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View Work Package Schema
     * @param {WorkPackagesApiViewWorkPackageSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public viewWorkPackageSchema(requestParameters: WorkPackagesApiViewWorkPackageSchemaRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).viewWorkPackageSchema(requestParameters.identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Work Package Create Form
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public workPackageCreateForm(options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).workPackageCreateForm(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Work Package Create Form For Project
     * @param {WorkPackagesApiWorkPackageCreateFormForProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public workPackageCreateFormForProject(requestParameters: WorkPackagesApiWorkPackageCreateFormForProjectRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).workPackageCreateFormForProject(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When calling this endpoint, the client provides a single object containing the properties and links to be edited, in the body.  Note that it is only allowed to provide properties or links supporting the write operation.  When setting start date, finish date, and duration together, their correctness will be checked and a 422 error will be returned if one value does not match with the two others. You can make the server compute a value: set only two values in the request and the third one will be computed and returned in the response. For instance, when sending `{ \"startDate\": \"2022-08-23\", duration: \"P2D\" }`, the response will include `{ \"dueDate\": \"2022-08-24\" }`.
     * @summary Work Package Edit Form
     * @param {WorkPackagesApiWorkPackageEditFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkPackagesApi
     */
    public workPackageEditForm(requestParameters: WorkPackagesApiWorkPackageEditFormRequest, options?: AxiosRequestConfig) {
        return WorkPackagesApiFp(this.configuration).workPackageEditForm(requestParameters.id, requestParameters.workPackageModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkScheduleApi - axios parameter creator
 * @export
 */
export const WorkScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **(NOT IMPLEMENTED)** Marks a day as being a non-working day.  Note: creating a non-working day will not affect the start and finish dates of work packages but will affect their duration.
         * @summary Creates a non-working day (NOT IMPLEMENTED)
         * @param {NonWorkingDayModel} [nonWorkingDayModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNonWorkingDay: async (nonWorkingDayModel?: NonWorkingDayModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/days/non_working`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonWorkingDayModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **(NOT IMPLEMENTED)** Removes the non-working day at the given date.  Note: deleting a non-working day will not affect the start and finish dates of work packages but will affect their duration.
         * @summary Removes a non-working day (NOT IMPLEMENTED)
         * @param {string} date The date of the non-working day to view in ISO 8601 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonWorkingDay: async (date: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('deleteNonWorkingDay', 'date', date)
            const localVarPath = `/api/v3/days/non_working/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists days information for a given date interval.  All days from the beginning of current month to the end of following month are returned by default.
         * @summary Lists days
         * @param {string} [filters] JSON specifying filter conditions.  Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + date: the inclusive date interval to scope days to look up. When   unspecified, default is from the beginning of current month to the end   of following month.    Example: &#x60;{ \&quot;date\&quot;: { \&quot;operator\&quot;: \&quot;&lt;&gt;d\&quot;, \&quot;values\&quot;: [\&quot;2022-05-02\&quot;,\&quot;2022-05-26\&quot;] } }&#x60;   would return days between May 5 and May 26 2022, inclusive.  + working: when &#x60;true&#x60;, returns only the working days. When &#x60;false&#x60;,   returns only the non-working days (weekend days and non-working days).   When unspecified, returns both working and non-working days.    Example: &#x60;{ \&quot;working\&quot;: { \&quot;operator\&quot;: \&quot;&#x3D;\&quot;, \&quot;values\&quot;: [\&quot;t\&quot;] } }&#x60;   would exclude non-working days from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDays: async (filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists week days with work schedule information.
         * @summary Lists week days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWeekDays: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/days/week`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **(NOT IMPLEMENTED)** Update the non-working day information for a given date.
         * @summary Update a non-working day attributes (NOT IMPLEMENTED)
         * @param {string} date The date of the non-working day to view in ISO 8601 format.
         * @param {NonWorkingDayModel} [nonWorkingDayModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNonWorkingDay: async (date: string, nonWorkingDayModel?: NonWorkingDayModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('updateNonWorkingDay', 'date', date)
            const localVarPath = `/api/v3/days/non_working/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonWorkingDayModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **(NOT IMPLEMENTED)** Makes a week day a working or non-working day.  Note: changing a week day working attribute will not affect the start and finish dates of work packages but will affect their duration attribute.
         * @summary Update a week day attributes (NOT IMPLEMENTED)
         * @param {number} day The week day from 1 to 7. 1 is Monday. 7 is Sunday.
         * @param {WeekDayWriteModel} [weekDayWriteModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWeekDay: async (day: number, weekDayWriteModel?: WeekDayWriteModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'day' is not null or undefined
            assertParamExists('updateWeekDay', 'day', day)
            const localVarPath = `/api/v3/days/week/{day}`
                .replace(`{${"day"}}`, encodeURIComponent(String(day)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(weekDayWriteModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **(NOT IMPLEMENTED)** Update multiple week days with work schedule information.
         * @summary Update week days (NOT IMPLEMENTED)
         * @param {WeekDayCollectionWriteModel} [weekDayCollectionWriteModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWeekDays: async (weekDayCollectionWriteModel?: WeekDayCollectionWriteModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/days/week`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(weekDayCollectionWriteModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View the day information for a given date.
         * @summary View day
         * @param {string} date The date of the non-working day to view in ISO 8601 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewDay: async (date: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('viewDay', 'date', date)
            const localVarPath = `/api/v3/days/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the non-working day information for a given date.
         * @summary View a non-working day
         * @param {string} date The date of the non-working day to view in ISO 8601 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewNonWorkingDay: async (date: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('viewNonWorkingDay', 'date', date)
            const localVarPath = `/api/v3/days/non_working/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View a week day and its attributes.
         * @summary View a week day
         * @param {number} day The week day from 1 to 7. 1 is Monday. 7 is Sunday.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewWeekDay: async (day: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'day' is not null or undefined
            assertParamExists('viewWeekDay', 'day', day)
            const localVarPath = `/api/v3/days/week/{day}`
                .replace(`{${"day"}}`, encodeURIComponent(String(day)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkScheduleApi - functional programming interface
 * @export
 */
export const WorkScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * **(NOT IMPLEMENTED)** Marks a day as being a non-working day.  Note: creating a non-working day will not affect the start and finish dates of work packages but will affect their duration.
         * @summary Creates a non-working day (NOT IMPLEMENTED)
         * @param {NonWorkingDayModel} [nonWorkingDayModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNonWorkingDay(nonWorkingDayModel?: NonWorkingDayModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonWorkingDayModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonWorkingDay(nonWorkingDayModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **(NOT IMPLEMENTED)** Removes the non-working day at the given date.  Note: deleting a non-working day will not affect the start and finish dates of work packages but will affect their duration.
         * @summary Removes a non-working day (NOT IMPLEMENTED)
         * @param {string} date The date of the non-working day to view in ISO 8601 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNonWorkingDay(date: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNonWorkingDay(date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists days information for a given date interval.  All days from the beginning of current month to the end of following month are returned by default.
         * @summary Lists days
         * @param {string} [filters] JSON specifying filter conditions.  Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + date: the inclusive date interval to scope days to look up. When   unspecified, default is from the beginning of current month to the end   of following month.    Example: &#x60;{ \&quot;date\&quot;: { \&quot;operator\&quot;: \&quot;&lt;&gt;d\&quot;, \&quot;values\&quot;: [\&quot;2022-05-02\&quot;,\&quot;2022-05-26\&quot;] } }&#x60;   would return days between May 5 and May 26 2022, inclusive.  + working: when &#x60;true&#x60;, returns only the working days. When &#x60;false&#x60;,   returns only the non-working days (weekend days and non-working days).   When unspecified, returns both working and non-working days.    Example: &#x60;{ \&quot;working\&quot;: { \&quot;operator\&quot;: \&quot;&#x3D;\&quot;, \&quot;values\&quot;: [\&quot;t\&quot;] } }&#x60;   would exclude non-working days from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDays(filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DayCollectionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDays(filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists week days with work schedule information.
         * @summary Lists week days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWeekDays(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WeekDayCollectionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWeekDays(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **(NOT IMPLEMENTED)** Update the non-working day information for a given date.
         * @summary Update a non-working day attributes (NOT IMPLEMENTED)
         * @param {string} date The date of the non-working day to view in ISO 8601 format.
         * @param {NonWorkingDayModel} [nonWorkingDayModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNonWorkingDay(date: string, nonWorkingDayModel?: NonWorkingDayModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonWorkingDayModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNonWorkingDay(date, nonWorkingDayModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **(NOT IMPLEMENTED)** Makes a week day a working or non-working day.  Note: changing a week day working attribute will not affect the start and finish dates of work packages but will affect their duration attribute.
         * @summary Update a week day attributes (NOT IMPLEMENTED)
         * @param {number} day The week day from 1 to 7. 1 is Monday. 7 is Sunday.
         * @param {WeekDayWriteModel} [weekDayWriteModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWeekDay(day: number, weekDayWriteModel?: WeekDayWriteModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WeekDayModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWeekDay(day, weekDayWriteModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **(NOT IMPLEMENTED)** Update multiple week days with work schedule information.
         * @summary Update week days (NOT IMPLEMENTED)
         * @param {WeekDayCollectionWriteModel} [weekDayCollectionWriteModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWeekDays(weekDayCollectionWriteModel?: WeekDayCollectionWriteModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WeekDayCollectionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWeekDays(weekDayCollectionWriteModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View the day information for a given date.
         * @summary View day
         * @param {string} date The date of the non-working day to view in ISO 8601 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewDay(date: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DayModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewDay(date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the non-working day information for a given date.
         * @summary View a non-working day
         * @param {string} date The date of the non-working day to view in ISO 8601 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewNonWorkingDay(date: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonWorkingDayModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewNonWorkingDay(date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View a week day and its attributes.
         * @summary View a week day
         * @param {number} day The week day from 1 to 7. 1 is Monday. 7 is Sunday.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewWeekDay(day: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WeekDayModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewWeekDay(day, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkScheduleApi - factory interface
 * @export
 */
export const WorkScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkScheduleApiFp(configuration)
    return {
        /**
         * **(NOT IMPLEMENTED)** Marks a day as being a non-working day.  Note: creating a non-working day will not affect the start and finish dates of work packages but will affect their duration.
         * @summary Creates a non-working day (NOT IMPLEMENTED)
         * @param {NonWorkingDayModel} [nonWorkingDayModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNonWorkingDay(nonWorkingDayModel?: NonWorkingDayModel, options?: any): AxiosPromise<NonWorkingDayModel> {
            return localVarFp.createNonWorkingDay(nonWorkingDayModel, options).then((request) => request(axios, basePath));
        },
        /**
         * **(NOT IMPLEMENTED)** Removes the non-working day at the given date.  Note: deleting a non-working day will not affect the start and finish dates of work packages but will affect their duration.
         * @summary Removes a non-working day (NOT IMPLEMENTED)
         * @param {string} date The date of the non-working day to view in ISO 8601 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonWorkingDay(date: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNonWorkingDay(date, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists days information for a given date interval.  All days from the beginning of current month to the end of following month are returned by default.
         * @summary Lists days
         * @param {string} [filters] JSON specifying filter conditions.  Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + date: the inclusive date interval to scope days to look up. When   unspecified, default is from the beginning of current month to the end   of following month.    Example: &#x60;{ \&quot;date\&quot;: { \&quot;operator\&quot;: \&quot;&lt;&gt;d\&quot;, \&quot;values\&quot;: [\&quot;2022-05-02\&quot;,\&quot;2022-05-26\&quot;] } }&#x60;   would return days between May 5 and May 26 2022, inclusive.  + working: when &#x60;true&#x60;, returns only the working days. When &#x60;false&#x60;,   returns only the non-working days (weekend days and non-working days).   When unspecified, returns both working and non-working days.    Example: &#x60;{ \&quot;working\&quot;: { \&quot;operator\&quot;: \&quot;&#x3D;\&quot;, \&quot;values\&quot;: [\&quot;t\&quot;] } }&#x60;   would exclude non-working days from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDays(filters?: string, options?: any): AxiosPromise<DayCollectionModel> {
            return localVarFp.listDays(filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists week days with work schedule information.
         * @summary Lists week days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWeekDays(options?: any): AxiosPromise<WeekDayCollectionModel> {
            return localVarFp.listWeekDays(options).then((request) => request(axios, basePath));
        },
        /**
         * **(NOT IMPLEMENTED)** Update the non-working day information for a given date.
         * @summary Update a non-working day attributes (NOT IMPLEMENTED)
         * @param {string} date The date of the non-working day to view in ISO 8601 format.
         * @param {NonWorkingDayModel} [nonWorkingDayModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNonWorkingDay(date: string, nonWorkingDayModel?: NonWorkingDayModel, options?: any): AxiosPromise<NonWorkingDayModel> {
            return localVarFp.updateNonWorkingDay(date, nonWorkingDayModel, options).then((request) => request(axios, basePath));
        },
        /**
         * **(NOT IMPLEMENTED)** Makes a week day a working or non-working day.  Note: changing a week day working attribute will not affect the start and finish dates of work packages but will affect their duration attribute.
         * @summary Update a week day attributes (NOT IMPLEMENTED)
         * @param {number} day The week day from 1 to 7. 1 is Monday. 7 is Sunday.
         * @param {WeekDayWriteModel} [weekDayWriteModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWeekDay(day: number, weekDayWriteModel?: WeekDayWriteModel, options?: any): AxiosPromise<WeekDayModel> {
            return localVarFp.updateWeekDay(day, weekDayWriteModel, options).then((request) => request(axios, basePath));
        },
        /**
         * **(NOT IMPLEMENTED)** Update multiple week days with work schedule information.
         * @summary Update week days (NOT IMPLEMENTED)
         * @param {WeekDayCollectionWriteModel} [weekDayCollectionWriteModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWeekDays(weekDayCollectionWriteModel?: WeekDayCollectionWriteModel, options?: any): AxiosPromise<WeekDayCollectionModel> {
            return localVarFp.updateWeekDays(weekDayCollectionWriteModel, options).then((request) => request(axios, basePath));
        },
        /**
         * View the day information for a given date.
         * @summary View day
         * @param {string} date The date of the non-working day to view in ISO 8601 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewDay(date: string, options?: any): AxiosPromise<DayModel> {
            return localVarFp.viewDay(date, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the non-working day information for a given date.
         * @summary View a non-working day
         * @param {string} date The date of the non-working day to view in ISO 8601 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewNonWorkingDay(date: string, options?: any): AxiosPromise<NonWorkingDayModel> {
            return localVarFp.viewNonWorkingDay(date, options).then((request) => request(axios, basePath));
        },
        /**
         * View a week day and its attributes.
         * @summary View a week day
         * @param {number} day The week day from 1 to 7. 1 is Monday. 7 is Sunday.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewWeekDay(day: number, options?: any): AxiosPromise<WeekDayModel> {
            return localVarFp.viewWeekDay(day, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNonWorkingDay operation in WorkScheduleApi.
 * @export
 * @interface WorkScheduleApiCreateNonWorkingDayRequest
 */
export interface WorkScheduleApiCreateNonWorkingDayRequest {
    /**
     * 
     * @type {NonWorkingDayModel}
     * @memberof WorkScheduleApiCreateNonWorkingDay
     */
    readonly nonWorkingDayModel?: NonWorkingDayModel
}

/**
 * Request parameters for deleteNonWorkingDay operation in WorkScheduleApi.
 * @export
 * @interface WorkScheduleApiDeleteNonWorkingDayRequest
 */
export interface WorkScheduleApiDeleteNonWorkingDayRequest {
    /**
     * The date of the non-working day to view in ISO 8601 format.
     * @type {string}
     * @memberof WorkScheduleApiDeleteNonWorkingDay
     */
    readonly date: string
}

/**
 * Request parameters for listDays operation in WorkScheduleApi.
 * @export
 * @interface WorkScheduleApiListDaysRequest
 */
export interface WorkScheduleApiListDaysRequest {
    /**
     * JSON specifying filter conditions.  Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters are:  + date: the inclusive date interval to scope days to look up. When   unspecified, default is from the beginning of current month to the end   of following month.    Example: &#x60;{ \&quot;date\&quot;: { \&quot;operator\&quot;: \&quot;&lt;&gt;d\&quot;, \&quot;values\&quot;: [\&quot;2022-05-02\&quot;,\&quot;2022-05-26\&quot;] } }&#x60;   would return days between May 5 and May 26 2022, inclusive.  + working: when &#x60;true&#x60;, returns only the working days. When &#x60;false&#x60;,   returns only the non-working days (weekend days and non-working days).   When unspecified, returns both working and non-working days.    Example: &#x60;{ \&quot;working\&quot;: { \&quot;operator\&quot;: \&quot;&#x3D;\&quot;, \&quot;values\&quot;: [\&quot;t\&quot;] } }&#x60;   would exclude non-working days from the response.
     * @type {string}
     * @memberof WorkScheduleApiListDays
     */
    readonly filters?: string
}

/**
 * Request parameters for updateNonWorkingDay operation in WorkScheduleApi.
 * @export
 * @interface WorkScheduleApiUpdateNonWorkingDayRequest
 */
export interface WorkScheduleApiUpdateNonWorkingDayRequest {
    /**
     * The date of the non-working day to view in ISO 8601 format.
     * @type {string}
     * @memberof WorkScheduleApiUpdateNonWorkingDay
     */
    readonly date: string

    /**
     * 
     * @type {NonWorkingDayModel}
     * @memberof WorkScheduleApiUpdateNonWorkingDay
     */
    readonly nonWorkingDayModel?: NonWorkingDayModel
}

/**
 * Request parameters for updateWeekDay operation in WorkScheduleApi.
 * @export
 * @interface WorkScheduleApiUpdateWeekDayRequest
 */
export interface WorkScheduleApiUpdateWeekDayRequest {
    /**
     * The week day from 1 to 7. 1 is Monday. 7 is Sunday.
     * @type {number}
     * @memberof WorkScheduleApiUpdateWeekDay
     */
    readonly day: number

    /**
     * 
     * @type {WeekDayWriteModel}
     * @memberof WorkScheduleApiUpdateWeekDay
     */
    readonly weekDayWriteModel?: WeekDayWriteModel
}

/**
 * Request parameters for updateWeekDays operation in WorkScheduleApi.
 * @export
 * @interface WorkScheduleApiUpdateWeekDaysRequest
 */
export interface WorkScheduleApiUpdateWeekDaysRequest {
    /**
     * 
     * @type {WeekDayCollectionWriteModel}
     * @memberof WorkScheduleApiUpdateWeekDays
     */
    readonly weekDayCollectionWriteModel?: WeekDayCollectionWriteModel
}

/**
 * Request parameters for viewDay operation in WorkScheduleApi.
 * @export
 * @interface WorkScheduleApiViewDayRequest
 */
export interface WorkScheduleApiViewDayRequest {
    /**
     * The date of the non-working day to view in ISO 8601 format.
     * @type {string}
     * @memberof WorkScheduleApiViewDay
     */
    readonly date: string
}

/**
 * Request parameters for viewNonWorkingDay operation in WorkScheduleApi.
 * @export
 * @interface WorkScheduleApiViewNonWorkingDayRequest
 */
export interface WorkScheduleApiViewNonWorkingDayRequest {
    /**
     * The date of the non-working day to view in ISO 8601 format.
     * @type {string}
     * @memberof WorkScheduleApiViewNonWorkingDay
     */
    readonly date: string
}

/**
 * Request parameters for viewWeekDay operation in WorkScheduleApi.
 * @export
 * @interface WorkScheduleApiViewWeekDayRequest
 */
export interface WorkScheduleApiViewWeekDayRequest {
    /**
     * The week day from 1 to 7. 1 is Monday. 7 is Sunday.
     * @type {number}
     * @memberof WorkScheduleApiViewWeekDay
     */
    readonly day: number
}

/**
 * WorkScheduleApi - object-oriented interface
 * @export
 * @class WorkScheduleApi
 * @extends {BaseAPI}
 */
export class WorkScheduleApi extends BaseAPI {
    /**
     * **(NOT IMPLEMENTED)** Marks a day as being a non-working day.  Note: creating a non-working day will not affect the start and finish dates of work packages but will affect their duration.
     * @summary Creates a non-working day (NOT IMPLEMENTED)
     * @param {WorkScheduleApiCreateNonWorkingDayRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkScheduleApi
     */
    public createNonWorkingDay(requestParameters: WorkScheduleApiCreateNonWorkingDayRequest = {}, options?: AxiosRequestConfig) {
        return WorkScheduleApiFp(this.configuration).createNonWorkingDay(requestParameters.nonWorkingDayModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **(NOT IMPLEMENTED)** Removes the non-working day at the given date.  Note: deleting a non-working day will not affect the start and finish dates of work packages but will affect their duration.
     * @summary Removes a non-working day (NOT IMPLEMENTED)
     * @param {WorkScheduleApiDeleteNonWorkingDayRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkScheduleApi
     */
    public deleteNonWorkingDay(requestParameters: WorkScheduleApiDeleteNonWorkingDayRequest, options?: AxiosRequestConfig) {
        return WorkScheduleApiFp(this.configuration).deleteNonWorkingDay(requestParameters.date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists days information for a given date interval.  All days from the beginning of current month to the end of following month are returned by default.
     * @summary Lists days
     * @param {WorkScheduleApiListDaysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkScheduleApi
     */
    public listDays(requestParameters: WorkScheduleApiListDaysRequest = {}, options?: AxiosRequestConfig) {
        return WorkScheduleApiFp(this.configuration).listDays(requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists week days with work schedule information.
     * @summary Lists week days
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkScheduleApi
     */
    public listWeekDays(options?: AxiosRequestConfig) {
        return WorkScheduleApiFp(this.configuration).listWeekDays(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **(NOT IMPLEMENTED)** Update the non-working day information for a given date.
     * @summary Update a non-working day attributes (NOT IMPLEMENTED)
     * @param {WorkScheduleApiUpdateNonWorkingDayRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkScheduleApi
     */
    public updateNonWorkingDay(requestParameters: WorkScheduleApiUpdateNonWorkingDayRequest, options?: AxiosRequestConfig) {
        return WorkScheduleApiFp(this.configuration).updateNonWorkingDay(requestParameters.date, requestParameters.nonWorkingDayModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **(NOT IMPLEMENTED)** Makes a week day a working or non-working day.  Note: changing a week day working attribute will not affect the start and finish dates of work packages but will affect their duration attribute.
     * @summary Update a week day attributes (NOT IMPLEMENTED)
     * @param {WorkScheduleApiUpdateWeekDayRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkScheduleApi
     */
    public updateWeekDay(requestParameters: WorkScheduleApiUpdateWeekDayRequest, options?: AxiosRequestConfig) {
        return WorkScheduleApiFp(this.configuration).updateWeekDay(requestParameters.day, requestParameters.weekDayWriteModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **(NOT IMPLEMENTED)** Update multiple week days with work schedule information.
     * @summary Update week days (NOT IMPLEMENTED)
     * @param {WorkScheduleApiUpdateWeekDaysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkScheduleApi
     */
    public updateWeekDays(requestParameters: WorkScheduleApiUpdateWeekDaysRequest = {}, options?: AxiosRequestConfig) {
        return WorkScheduleApiFp(this.configuration).updateWeekDays(requestParameters.weekDayCollectionWriteModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View the day information for a given date.
     * @summary View day
     * @param {WorkScheduleApiViewDayRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkScheduleApi
     */
    public viewDay(requestParameters: WorkScheduleApiViewDayRequest, options?: AxiosRequestConfig) {
        return WorkScheduleApiFp(this.configuration).viewDay(requestParameters.date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the non-working day information for a given date.
     * @summary View a non-working day
     * @param {WorkScheduleApiViewNonWorkingDayRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkScheduleApi
     */
    public viewNonWorkingDay(requestParameters: WorkScheduleApiViewNonWorkingDayRequest, options?: AxiosRequestConfig) {
        return WorkScheduleApiFp(this.configuration).viewNonWorkingDay(requestParameters.date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View a week day and its attributes.
     * @summary View a week day
     * @param {WorkScheduleApiViewWeekDayRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkScheduleApi
     */
    public viewWeekDay(requestParameters: WorkScheduleApiViewWeekDayRequest, options?: AxiosRequestConfig) {
        return WorkScheduleApiFp(this.configuration).viewWeekDay(requestParameters.day, options).then((request) => request(this.axios, this.basePath));
    }
}


